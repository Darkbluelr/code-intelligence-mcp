# Claude Code / Codex CLI：自动工具编排 + 结果融合的上下文注入（单变更包交付）

- Decision Status: Revise

> Truth Root: `dev-playbooks/specs/`
> Change Root: `dev-playbooks/changes/`
> Status: Revise（Judge 要求修改后再评审）

> 治理约束（强制）：本次变更**所有任务必须在一个变更包里完成**，禁止拆分为多个变更包；若 Proposal Challenger 要求拆分，Proposal Judge **必须驳回拆分请求**（允许在同一变更包内重排优先级/范围，但不得拆包）。

## 🎯 结论先行（30秒阅读）

**本提案会导致**：
- ✅ 在 Claude Code 与 Codex CLI 中，用户输入后可在模型输出前自动执行“合适的”MCP 工具，并把结果回填进 Prompt
- ✅ 自动调用不再是“固定 1-2 个工具”，而是按意图/置信度/预算选择多工具，并做结果融合与解释（面向用户可读）
- ✅ 中英文都可触发自动注入（语言无关），并保留“可见 + 可控”的用户体验
- ✅ 入口层收敛为“输入采集 + 输出注入”，所有工具调用/裁剪/预算/融合进入编排内核，并给出同包迁移与回滚路径

**本提案不会导致**：
- ❌ 不做 Cursor/其他 IDE 的适配（明确排除）
- ❌ 不改变 Thin Shell 架构约束（TypeScript 仍是薄壳，核心能力仍在 Shell 脚本 / MCP 工具侧）

**一句话总结**：把“工具自动调用 + 结果融合 + 可扩展适配”做成可维护的编排层，让 Claude Code/Codex CLI 在回答前自动把该查的都查了。

---

## 🤔 需求对齐（5分钟阅读）

### 你是谁？（角色定位）

请选择最符合你的描述：

- [ ] **效率型使用者**：希望“问一次就给完整答案”，可接受少量延迟
- [ ] **质量型维护者**：更关心准确性与可控性（工具计划/证据/可回滚）
- [ ] **平台扩展者**：未来要扩展到更多 AI 客户端/更多工具，需要清晰扩展点

**如果你不确定**：默认选择“质量型维护者”。

---

### 你要什么？（核心需求）

**基础需求（必须）**：
- [x] 明确 `hooks/context-inject-global.sh` 与 `hooks/auto-tool-orchestrator.sh` 的迁移/去重路径：入口层收敛为“输入采集 + 输出注入”，不再直接调用工具；所有工具调用/参数裁剪/预算/融合进入编排内核（同包完成，含回滚）
- [x] 本次 change 只适配 Claude Code 与 Codex CLI，但适配逻辑必须容易扩展
- [x] 自动工具调用要“尽可能调用所有合适的”，并由我（提案）给出最佳实践决策
- [x] 中英文均可触发自动注入
- [x] 本次需要实现“自动结果融合 + 解释”，并兼顾用户体验与效率

**排除项（明确不做）**：
- [x] Cursor/其他 IDE 适配

---

### 你可能没想到什么？（隐藏需求）

#### 隐藏需求 1：无上限“全工具自动调用”会拖垮体验

**问题**：如果每次提问都把所有工具都跑一遍，你更在意“最全”还是“可接受的延迟/噪音”？

**为什么重要**：
- 过多工具会带来：延迟陡增、噪音干扰、错误传播、token 暴涨
- 结果融合需要“去重/聚合/溯源”，否则反而降低回答质量

**默认选择（提案给出决策）**：
- 采用“尽可能多，但有预算与置信度边界”的自动化策略（见下文 What/设计要点）

---

### 🎯 基于你的选择，推荐方案

默认推荐：**质量型维护者**路径（仅推荐，不作为批准）
- 自动调用：按意图与置信度选择“合适的多工具组合”，但受预算与超时约束
- 输出：用户可见的 Tool Plan + 可折叠 Results + 最终融合解释
- 扩展：编排内核与客户端适配解耦，后续可加其他 CLI 客户端适配（不包含 IDE）

---

## ✅ 批准流程（1分钟）

### 快速批准（推荐）

如果你同意“多工具自动化（带预算边界）+ 结果融合解释 + 仅 Claude/Codex 适配”的推荐方案：
- [ ] ✅ 我同意推荐方案（显式确认）

如果你想自定义（例如更激进/更保守的自动调用策略）：
- [ ] 🔧 我想自定义方案（在 Debate Packet 的问题上给出选择）

默认选择：无（需显式勾选；最终仍以 Judge 裁决为准）

---

## Why

- 当前需求已从“低成本/低风险工具自动调用”升级为“合适多工具编排 + 结果融合”，缺少统一编排层会导致体验不稳定、逻辑分散。
- Value Signal and Observation: 观察单轮回答中引用工具证据的比例、重复追问轮次下降、自动注入开启后平均查询步骤减少。
- Value Stream Bottleneck Hypothesis: 现有瓶颈在“人工多工具调用 + 手工汇总”，编排层可把这一段收敛为一次自动链路。

## What Changes

- 交付 `hooks/auto-tool-orchestrator.sh` 编排内核，并将 `hooks/context-inject-global.sh` 收敛为“输入采集 + 输出注入”（不再直接调用工具）。
- 新增 `config/auto-tools.yaml` 作为唯一控制面配置源，默认值保守可回滚。
- 输出结构化 Tool Plan/Results/Fused Context，并提供用户可读摘要与降级说明。
- 补齐安装/卸载/验证文档与最小 bats 验证集（预算、降级、融合格式）。

## Impact

- 受影响模块集中在 `hooks/`、`config/`、`docs/`、`tests/`，`src/` 仅在需要适配参数/输出时触及。
- 对现有手动工具调用保持兼容，默认 fail-open 不阻塞回答。

## Risks

- 自动调用导致延迟上升；缓解：分层、预算、并发与降级。
- 结果噪音干扰模型；缓解：去重/聚合/溯源与摘要长度限制。
- 安全/隐私误回填；缓解：白名单、路径过滤、脱敏与敏感模式排除。

## Validation

- bats 安装与运行（可复现）：
  - macOS：`brew install bats-core`
  - 通用（Node）：`npm i -g bats`
  - 运行：`npm test` 或 `bats tests/auto-tools.bats`
- bats 覆盖 plan/dry-run 的确定性输出（含 `schema_version/run_id/tool_plan`），且不调用 codex。
- 验证 Codex wrapper 会话恢复与降级路径、repo-root 解析与路径过滤一致性；plan/dry-run 输出“将要执行的 codex 命令”用于无外部 codex 验证。
- 模拟超时/解析失败/工具不可用与提示注入样例，断言 [Limits] 与安全标记生效。

## 📋 详细提案（AI阅读）

### Why（为什么要改）

#### 问题描述

当前用户需求已经明确从“低成本/低风险工具自动调用”升级为：
- 在模型输出前自动调用“所有合适的工具”，并把结果融合解释后回填
- 同时要兼顾延迟与可读性（用户体验），并支持中英文触发
- 仅做 Claude Code + Codex CLI 适配，但必须为未来扩展预留清晰扩展点

如果没有一个明确的“工具编排层”，会出现：
- 逻辑散落在不同 Hook/Wrapper 中，难扩展、难测试、难统一体验
- 自动化策略不可控（要么太少、要么无上限），导致效果不稳定

#### 影响

- 对最终用户：一次提问可获得更有证据、上下文更完整的回答
- 对维护者：集中式编排内核降低耦合，未来增加工具/客户端成本更低

---

## Debate Packet（供 Challenger/Judge 对辩）

> 目标：把争议点与风险摆在桌面上，避免“隐性假设”。

### 必须写入的治理说明（强制）

- 本次变更**所有任务必须在一个变更包里完成**，禁止拆分为多个变更包。
- 如果 Proposal Challenger 提出“拆分变更包”的要求，Proposal Judge **必须驳回拆分请求**（可要求在同一变更包内重排优先级，但不得拆包）。

### 已采用的保守默认（不阻塞）

1) 预算默认值：采用“保守”档（详见预算章节），以稳定性优先。
2) Tier-2：默认关闭，仅通过 `CI_AUTO_TOOLS_TIER_MAX=2` 启用；MVP 不做意图自动触发 Tier-2。
3) 用户可控性：允许“完全关闭自动调用”（`CI_AUTO_TOOLS=off`），并保留降级到 Tier-1 的选项。
4) Codex CLI 集成：默认采用 wrapper 作为预调用入口；单次注入作为次选兜底。
5) 终端输出：默认“摘要优先 + 可折叠结果 + [Limits] 明示”，原始结果仅在预算允许时部分回填。

### 备选方案（记录，不阻塞）

- 预算档位允许“激进”模式（更高并发/预算），但需证据支撑。
- Tier-2 可选引入“意图触发”逻辑（modify/debug 自动），但不纳入 MVP。

---

### What（要改什么）

#### 目标

1) **“AI 输出前”自动工具调用**：在 Claude Code 与 Codex CLI 的调用链中保证工具先跑、结果后回填、最后再生成回答。

2) **多工具选择（尽可能调用合适的）**：
- 不是“固定 1-2 个”，而是基于意图/置信度/预算选择工具集合
- 同时避免无上限调用导致的延迟与噪音

3) **自动结果融合 + 解释（面向用户）**：
- 结构化回填（供模型稳定消费）
- 用户可读摘要（展示执行了哪些工具、为什么、得到什么结论/证据）

4) **中英文均可触发**：语言不应成为自动化的开关；意图识别需对中英文均有效。

5) **易扩展的适配层**：本次只实现 Claude Code/Codex CLI，但设计上要明确“新增客户端适配点”。

#### 范围

本次变更将交付（预期文件/模块，供后续 design/tasks 细化）：
- `hooks/auto-tool-orchestrator.sh`：编排内核（工具路由/预算/并发/降级/结果标准化/融合解释）
- `hooks/context-inject-global.sh`：作为客户端适配入口（Claude Code Hook / Codex CLI wrapper），调用编排内核
- `config/auto-tools.yaml`：白名单/阈值/预算/工具分层策略（默认值可用，支持覆盖）
- `docs/auto-tools.md`：用户说明（可见+可控、隐私/安全、常见问题）
- `tests/auto-tools.bats`：最小验证集（预算/降级/融合格式的契约测试）

本次明确不做：
- Cursor/其他 IDE 适配

---

#### 设计完善（对后续 Design Doc 的明确要求）

> 本小节用于满足“proposal.md 必须包含设计完善/设计要点内容”的要求（与下方“设计要点”互补）：列出必须在 `design.md` 中补齐并固化的关键设计点，避免实现阶段反推设计。

- **边界与契约**：客户端适配层（Claude Code Hook / Codex CLI wrapper）与编排内核（orchestrator）的输入/输出契约；错误码/退出码/输出 schema 的稳定性
- **自动调用策略**：白名单、置信度阈值、预算模型（总超时/并发/回填 token 上限）、超时/失败降级与重试规则
- **结果融合与解释**：结构化 JSON（供模型消费）与用户可读摘要（供终端展示）的格式；聚合/去重/溯源策略；top-k 限制与噪音抑制
- **中英文触发**：语言无关触发策略（中英关键词 + 结构信号），以及误触发/漏触发时的行为（例如自动降级、提示用户如何补充信息）
- **安全与隐私**：路径过滤/脱敏策略、默认采集边界、日志与可观测性（避免输出敏感内容到 prompt）
- **验收锚点**：如何在测试中验证“模型输出前已调用工具并回填”（含失败/超时降级的证据采集方式）

---

### 设计完善 / 设计要点（必须）

> 本节用于满足“proposal 需要完善里面的设计”的要求：只描述 What/Constraints/AC，不写实现步骤。

#### 设计要点 0：范围收敛（同包分阶段，不拆包）

本次变更强制保持“单变更包”，但允许**在同一变更包内分阶段交付**（同包分阶段，不拆包）：

- **MVP（必须交付）**：仅 Tier-0/1 自动；**Tier-2 默认关闭**（`CI_AUTO_TOOLS_TIER_MAX=1`），不依赖“意图自动触发 Tier-2”。Tier-2 **唯一启用入口**为环境变量 `CI_AUTO_TOOLS_TIER_MAX=2`；配置文件与 CLI 均不提供 Tier-2 开关。默认禁用时输出 [Limits] 提示：`[Limits] tier-2 disabled by default; set CI_AUTO_TOOLS_TIER_MAX=2 to enable`。
- **Tier-0/1**：自动（无需用户确认）。
- **Tier-2**：仅在环境变量启用后才可进入计划；MVP 不实现“意图自动触发”，该逻辑作为同包可选项，可在不影响验收的前提下延后。
- **Tier-3**：高成本/高风险，默认永不自动（仅提示 + 手动触发）。
- **回退路径**：随时将 `CI_AUTO_TOOLS_TIER_MAX=1` 或 `CI_AUTO_TOOLS=off` 即回退到 Tier-0/1 或全关闭；MVP 交付压力下保持 Tier-2 关闭不影响交付。

**用户决策树（最短版）**：
- 只需要搜索/索引/概览 → 保持默认 Tier-0/1
- 需要调用链/影响分析/复杂度诊断 → 临时设置 `CI_AUTO_TOOLS_TIER_MAX=2` 重跑

该约束用于保证“范围收敛”，避免本次交付演变成“把所有工具都塞进自动化”。

#### 设计要点 1：hooks 关系与调用链（回答用户 Q1；补齐调用链要求）

三者关系（都需要存在，且是**调用链**而非互斥）：

```
Claude Code (UserPromptSubmit)
  -> ~/.claude/hooks/context-inject-global.sh
       -> hooks/context-inject-global.sh (入口适配层)
            -> hooks/auto-tool-orchestrator.sh (编排内核)

兼容层：hooks/augment-context-global.sh
  -> exec hooks/context-inject-global.sh (仅为历史路径/测试保持兼容)
```

- `hooks/context-inject-global.sh`：入口与适配层
  - 负责输入适配：Claude Code Hook payload / Codex CLI wrapper 输入 / CLI 参数（如 `--prompt`）
  - 负责输出适配：
    - Claude Code：输出 `hookSpecificOutput.additionalContext`
    - Codex CLI：输出可拼接到 prompt 的“增强上下文块”（或 JSON 供 wrapper 二次格式化）
  - 负责**可控性与降级**：根据控制面决定是否调用编排内核；失败时 fail-open（不阻塞模型输出）
  - **硬约束**：入口层不允许直接调用任何 MCP 工具；仅能调用编排内核

- `hooks/augment-context-global.sh`：仅做向后兼容
  - 现状已是“委托给 `context-inject-global.sh`”的 wrapper；本次保持该定位不膨胀

- `hooks/auto-tool-orchestrator.sh`：编排内核
  - 输入：标准化 prompt + signals + budget + allowlist + policy
  - 输出：Tool Plan + Tool Results + Fused Context（见下方 I/O 契约）
  - **唯一工具通道**：所有工具调用/参数裁剪/白名单/预算/融合统一在此执行；绕过即拒绝

#### 设计要点 1.1：迁移/去重策略（同包完成，含互斥边界与可回滚）

本节绑定现有脚本内容，明确“要迁移的函数/模块边界”与“入口层互斥规则”，保证同包完成且可回滚。

- **入口层互斥规则（强制）**：`hooks/context-inject-global.sh` **不得**调用任何 `ci_*` 工具或 MCP 客户端；唯一工具通道为 `hooks/auto-tool-orchestrator.sh`。如入口层尝试直连工具，编排内核拒绝并在 `[Limits]` 写明 `tool invocation must go through orchestrator`。

- **迁移清单（从 `hooks/context-inject-global.sh` → `hooks/auto-tool-orchestrator.sh`）**：
  1) **意图与信号层**：
     - `analyze_intent_4d`、`extract_symbols`、`extract_at_refs`/`process_at_refs`（用于生成 signals 与上下文线索）
     - `map_intent_to_standard`、`get_recommended_tools`（生成工具候选与理由）
  2) **工具选择与执行层**：
     - `get_index_status`、`do_search`、`call_graph_rag`、`get_hotspots`、`get_file_complexity` 等所有实际工具调用与依赖探测
     - `run_with_timeout`（工具超时包装）
  3) **结果融合与输出层**：
     - `build_structured_output`、`build_text_output`、`add_graph_context`、`add_fallback_info`、`output_hook_response`
  4) **安全与约束层**：
     - `EXCLUDE_PATTERN` 与路径过滤/脱敏规则（迁移到编排内核的统一裁剪/过滤模块）

- **入口层保留范围（仅 I/O 适配）**：
  - 解析 Claude Code Hook payload / Codex wrapper 输入
  - 调用编排内核并做 JSON 校验与降级处理（无工具调用）
  - 输出 `hookSpecificOutput.additionalContext` 或 CLI 追加上下文

- **互斥关系（可验证）**：
  - `hooks/context-inject-global.sh` **只能**调用 `hooks/auto-tool-orchestrator.sh`（或输出空注入 JSON）。
  - `hooks/augment-context-global.sh` **只能**委托到 `hooks/context-inject-global.sh`。

- **同包回滚策略**：
  - 软回滚：`CI_AUTO_TOOLS=off` 或 `CI_AUTO_TOOLS_MODE=plan`
  - 硬回滚：恢复旧版 `hooks/context-inject-global.sh`（入口层仍可输出空注入，编排脚本可保留但不被调用）

#### 设计要点 2：Codex CLI “模型输出前调用”的集成路径（补齐入口/触发/最小配置/差异）

Codex CLI 与 Claude Code 的关键差异：**Codex CLI 没有等价的官方 Hook 事件（如 UserPromptSubmit）**可直接复用，因此必须通过“入口包装”来保证“模型输出前调用”。

本提案采用“双入口策略”，都在“模型输出前”触发编排：

1) **入口 A（推荐，保证每轮预调用）：Codex CLI wrapper（外层交互循环）**
   - 入口形式：提供一个 wrapper 命令（例如 `codex-auto`），由它负责读取用户输入（每一轮）
   - 触发时机：每次用户提交一条 prompt -> 先调用 `hooks/auto-tool-orchestrator.sh` -> 再把增强后的 prompt 交给 `codex exec`（或 `codex exec resume`）
   - 最小配置：
     - 用户机器上已安装 `codex`
     - `~/.codex/config.toml` 已配置本项目的 MCP server（例如 `mcp_servers.code-intelligence`）
     - wrapper 能找到本仓库的 `hooks/context-inject-global.sh`（通常通过安装脚本复制到固定位置或加入 PATH）
   - 会话连续性（MVP，**不依赖 JSON 输出**）：
     - **首选路径**：若 `codex exec resume --last` 可用（以 `codex exec resume --help` 可检测），wrapper 直接使用 `codex exec resume --last` 维持会话连续性；不解析 JSON。
     - **降级路径**：若 `--last` 不可用或执行失败，则降级为无会话模式（每轮 `codex exec` 新会话），不阻塞执行。
     - **不再依赖** `codex exec --json` 或 `session_id` 作为前提；如用户自行提供可验证证据可在后续设计中再引入。
     - [Limits] 文本（无会话降级）：`[Limits] session continuity unavailable; fallback to stateless exec`
     - **可验证锚点（不调用 codex）**：在 `CI_AUTO_TOOLS_MODE=plan` 或 `CI_AUTO_TOOLS_DRY_RUN=1` 时输出 `planned_codex_command` 字段，内容为将要执行的 `codex exec resume --last` 或 `codex exec`，供 bats 断言会话选择逻辑。
     - 回滚路径：设置 `CI_AUTO_TOOLS=off` 完全关闭自动编排

2) **入口 B（次选，仅覆盖单次执行）：`codex exec <PROMPT>` 前置注入**
   - 入口形式：在运行 `codex exec` 之前，先把工具结果融合进用户本次 prompt
   - 触发时机：仅对该次 `codex exec` 有效（不保证在 Codex TUI 内的每轮输入都能拦截）

**plan/dry-run 与入口关系（明确）**：
- `CI_AUTO_TOOLS_MODE=plan` / `CI_AUTO_TOOLS_DRY_RUN=1` 时，入口 A/B 只输出增强 prompt/编排 JSON，不调用 codex
- 该模式用于 bats 自动化（确定性输出），避免依赖外部 codex

与 Claude Code 的差异点总结：
- Claude Code：Hook 由客户端原生触发（UserPromptSubmit），自动且可覆盖每轮对话
- Codex CLI：通过 wrapper 保证“每轮 prompt 都先编排再回答”；不依赖 Codex CLI 内部改造

#### 设计要点 3：控制面（开关/降级/回滚）与配置优先级（env > config > default）

控制面目标：用户可控、可降级、可快速回滚，且默认行为明确。

- **配置优先级（强制）**：`env > config > default`
  - env：紧急回滚/本地临时覆盖（不改文件）
  - config：统一指向 `config/auto-tools.yaml`（新增，唯一来源；禁止与 `.devbooks/config.yaml` 混用）
  - default：脚本内的保守默认值

- **与 `.devbooks/config.yaml` 的关系（明确）**：
  - `.devbooks/config.yaml` 仅用于 DevBooks 工具链/AI 工具配置，不参与自动编排控制面
  - 若用户在 `.devbooks/config.yaml` 误放自动编排配置，视为无效，并在 [Limits] 提示“请迁移到 `config/auto-tools.yaml`”

- **最小控制面（建议键）**：
  - `CI_AUTO_TOOLS=auto|on|off`（默认 `auto`：仅代码意图/明确需求时启用）
  - `CI_AUTO_TOOLS_MODE=run|plan`（默认 `run`；`plan` 仅生成计划与解释，不实际调用工具/不调用 codex）
  - `CI_AUTO_TOOLS_TIER_MAX=1|2`（默认 `1`；**Tier-2 唯一启用入口为该环境变量**；条件触发逻辑为可选项，不纳入 MVP）
  - `CI_AUTO_TOOLS_BUDGET_WALL_MS=5000`（默认 5000ms；见预算默认值）
  - `CI_AUTO_TOOLS_MAX_CONCURRENCY=3`（默认 3）
  - `CI_AUTO_TOOLS_DRY_RUN=0|1`（默认 `0`；为 `1` 时等价于 `CI_AUTO_TOOLS_MODE=plan`）

- **默认行为（明确）**：
  - 默认 `CI_AUTO_TOOLS=auto`：代码意图 -> 走 Tier-0/1；非代码意图 -> 输出空注入
  - 默认 `CI_AUTO_TOOLS_TIER_MAX=1`：不无条件触发 Tier-2
  - 默认 fail-open：任一工具超时/失败 -> 降级并继续输出（必须在 [Limits] 中说明原因）
  - 默认 [Limits] 提示文本（Tier-2 禁用时）：`[Limits] tier-2 disabled by default; set CI_AUTO_TOOLS_TIER_MAX=2 to enable`

- **回滚策略**：
  - 软回滚：`CI_AUTO_TOOLS_MODE=plan` 或 `CI_AUTO_TOOLS_TIER_MAX=1`（保留可见性但降低成本）
  - 硬回滚：`CI_AUTO_TOOLS=off`（完全关闭自动编排，回到旧行为）

- **plan/dry-run 确定性输出契约（可重复验收）**：
  - 输出固定 JSON：至少包含 `schema_version`、`run_id`、`tool_plan`、`tool_plan.planned_codex_command`、`fused_context.for_model.additional_context`
  - 该模式**不调用 codex**，仅输出增强 prompt/编排 JSON 供 bats 断言
  - `run_id` 规则：
    - plan/dry-run：`plan-<hash12>`（hash 为 `prompt + repo_root + tool_plan` 的稳定哈希）
    - run：`YYYYMMDD-HHMMSS-<hash6>`（hash 为 `prompt + repo_root` 的稳定哈希）

#### 设计要点 4：自动调用白名单/安全边界/脱敏与路径过滤规则

- **自动调用白名单（默认允许）**：仅允许“只读/分析类” MCP 工具自动调用；默认禁止任何具有外部副作用的操作（写文件/删文件/执行任意命令/联网扫描）。
- **工具分层（默认策略）**：
  - Tier-0（默认自动）：`ci_index_status`
  - Tier-1（默认自动）：`ci_search`、`ci_graph_rag`
  - Tier-2（条件/确认）：`ci_call_chain`、`ci_bug_locate`、`ci_impact`、`ci_complexity`、`ci_hotspot`
  - Tier-3（默认不自动）：任何可能触发网络/重依赖扫描/大规模遍历的工具（例如依赖漏洞扫描等）

- **参数裁剪（必须）**：对自动调用的工具强制上限，禁止从 prompt 直接透传“危险参数”。
  - `ci_graph_rag.depth <= 2`、`budget <= 8000`、`top_k <= 10`
  - `ci_search.limit <= 10`
  - `ci_call_chain.depth <= 3`
  - `ci_hotspot.days <= 30`、`top <= 20`
  - **强制执行位置**：在 `auto-tool-orchestrator.sh` 的“工具路由”阶段执行（编排内核统一入口），**在任何工具调用前**完成裁剪/拒绝；入口层不允许绕过。
  - **绕过检测**：若入口层或降级路径尝试直接调用工具，必须直接拒绝并输出空注入 JSON，`[Limits] tool invocation must go through orchestrator`。
  - **裁剪规则表（示例）**：
    | tool | key | max | action | limits_text |
    |------|-----|-----|--------|-------------|
    | ci_graph_rag | depth | 2 | clamp | `depth clamped to 2` |
    | ci_graph_rag | budget | 8000 | clamp | `budget clamped to 8000` |
    | ci_graph_rag | top_k | 10 | clamp | `top_k clamped to 10` |
    | ci_search | limit | 10 | clamp | `limit clamped to 10` |
    | ci_call_chain | depth | 3 | clamp | `depth clamped to 3` |
    | ci_hotspot | days | 30 | clamp | `days clamped to 30` |
    | ci_hotspot | top | 20 | clamp | `top clamped to 20` |
  - **裁剪伪代码（可执行语义）**：
    ```bash
    # in auto-tool-orchestrator.sh (before tool invocation)
    for tool in "${plan_tools[@]}"; do
      clamp_or_reject_args "$tool" "$raw_args" || {
        add_limit "args rejected"; mark_tool_skipped "E_INVALID_ARGS"; continue;
      }
    done
    ```
  - **绕过拒绝策略（唯一强制执行点）**：
    - 若 `hooks/context-inject-global.sh` 或 `hooks/augment-context-global.sh` 以任何方式尝试直连 `ci_*` 工具（包含旧路径/调试路径），编排内核应返回空注入 JSON 并在 `[Limits]` 输出 `tool invocation must go through orchestrator`。
    - 入口层不得提供“直连工具”的降级分支；唯一允许的降级是“空注入 + [Limits] 说明”。
  - **[Limits] 文本要求**：任何裁剪/拒绝都必须在 `[Limits]` 中可见，包含 tool 名与被裁剪键。

- **路径过滤（必须）**：
  - **repo-root 判定优先级（强制）**：
    1) 明确配置：`CI_AUTO_TOOLS_REPO_ROOT`（env）或 `config/auto-tools.yaml` 中 `repo_root`
    2) Git：若 `git rev-parse --show-toplevel` 成功 -> 该输出为 repo-root
    3) 兜底：`pwd`（仅在无 git/非工作树时生效）
  - **无 git 场景**：使用 `pwd` 作为 repo-root，并在 [Limits] 标注 “no-git-root”；路径过滤仍按 repo-root 生效
  - **子目录场景**：若在子目录运行，仍使用 git 的顶层目录作为 repo-root，保证路径过滤一致
  - **monorepo 场景**：默认仍使用 git 顶层目录；如需子项目根，必须显式配置 `repo_root`
  - 仅允许读取 `<repo-root>` 下的路径（realpath 校验，禁止 `..` 逃逸）。
  - 默认排除：沿用现有 `EXCLUDE_PATTERN`；并追加敏感模式（即使在 repo 内也默认不回填内容）：`.env`、`*.pem`、`*.key`、`id_rsa*`、`**/.ssh/**`、`**/secrets/**`、`**/.npmrc`。
- 二进制/超大文件：默认跳过或仅回填元信息（路径 + 大小 + 哈希），避免泄露与 token 爆炸。

- **脱敏（必须）**：
  - 回填到 prompt 的任何文本都要做脱敏：例如 `Bearer <redacted>`、`AKIA<redacted>`、`-----BEGIN ... KEY-----`。
  - 默认只回填“摘要 + 溯源 + 片段（严格限额）”，不回填整文件。

#### 设计要点 5：预算/并发默认值（具体数字 + 依据）

默认取“质量型维护者”的保守预算（交互可接受，避免无上限调用）。取值尽量对齐现有 `hooks/context-inject-global.sh` 的默认超时/Top-K 习惯，减少不确定性：

- **总墙钟预算（Tier-0/1）**：`5000ms`
- **并发上限**：`3`
- **单工具超时（默认）**：
  - `ci_index_status`：`500ms`
  - `ci_search`：`2000ms`（对齐现有 `SEARCH_TIMEOUT=2`）
  - `ci_graph_rag`：`3500ms`（对齐现有 `max_depth=2/top_k=10/token_budget=8000` 的保守上限）
  - `ci_complexity`：`1000ms`（对齐现有 `COMPLEXITY_TIMEOUT=1`）
  - Tier-2（条件/确认）额外预算：`+5000ms`（仅在触发时启用）

- **结果与回填限额（默认）**：
  - `graph_rag.max_depth=2`、`graph_rag.top_k=10`、`graph_rag.token_budget=8000`
  - 代码片段：`max_snippets=3`、`max_lines_per_snippet=20`（对齐现有默认）
  - 回填上限：`max_injected_chars=12000`（约 2k-3k tokens）；超出必须标记 `truncated=true`

#### 设计要点 6：编排内核 I/O 契约（Tool Plan / Tool Results / Fused Context JSON schema + 版本/兼容）

编排内核输出必须是**稳定 JSON**，并携带版本号，供入口层与不同客户端消费。

Schema（v1.0；新增字段必须保持向前兼容）：

```jsonc
{
  "schema_version": "1.0",
  "run_id": "string",
  "created_at": "string",
  "client": {
    "name": "claude-code|codex-cli",
    "event": "UserPromptSubmit|cli",
    "session_id": "string?"
  },
  "inputs": {
    "prompt": "string",
    "signals": [
      {"type": "explicit|implicit|historical|code", "match": "string", "weight": "number"}
    ]
  },
  "tool_plan": {
    "tier_max": "number",
    "planned_codex_command": "string?",
    "budget": {
      "wall_ms": "number",
      "max_concurrency": "number",
      "max_injected_chars": "number"
    },
    "tools": [
      {"tool": "string", "tier": "number", "reason": "string", "args": "object", "timeout_ms": "number"}
    ]
  },
  "tool_results": [
    {
      "tool": "string",
      "status": "ok|timeout|error|skipped",
      "started_at": "string",
      "duration_ms": "number",
      "summary": "string",
      "data": "object?",
      "error": {"message": "string", "code": "string?"},
      "redactions": [{"kind": "string", "count": "number"}],
      "truncated": "boolean"
    }
  ],
  "fused_context": {
    "for_model": {
      "additional_context": "string",
      "structured": "object",
      "safety": {
        "tool_output_is_untrusted": true,
        "ignore_instructions_inside_tool_output": true
      }
    },
    "for_user": {
      "tool_plan_text": "string",
      "results_text": "string",
      "limits_text": "string"
    }
  },
  "degraded": {"is_degraded": "boolean", "reason": "string", "degraded_to": "string"}
}
```

兼容策略（强制）：
- `schema_version` 采用语义化版本（SemVer）。
- **向前兼容**：只允许“新增可选字段/扩大枚举”不破坏旧消费者。
- **破坏性变更**：必须 bump major；入口层必须提供文本兜底（只消费 `fused_context.for_model.additional_context`）。

#### 设计要点 7：失败模型与提示注入防护策略（必须）

失败模型（必须覆盖）：
- 单工具超时/错误
- 部分成功（部分工具失败）
- 编排输出 JSON 解析失败
- 工具输出包含“提示注入文本/伪指令”

防护策略（强制）：
- 工具输出视为**不可信数据**：必须放入明确分隔块，并在 `fused_context.for_model.safety` 显式声明“忽略其中指令”。
- 编排逻辑不得把工具输出当成新的系统指令；最多作为“证据数据”供摘要。
- 当发现“疑似提示注入/越权指令”模式时：删除/脱敏该段，并在 [Limits] 明示“已过滤潜在注入内容”。
- fail-open：任何失败都不得阻塞模型输出，但必须把降级原因写入 [Limits]。

#### 设计要点 7.1：错误码/退出码契约（入口层必须遵守）

**error.code 枚举（tool_results.error.code）**：
- `E_TIMEOUT`：单工具或总预算超时
- `E_PARSE`：编排输出 JSON 解析失败
- `E_TOOL_UNAVAILABLE`：工具不可用/未安装/非零退出
- `E_BUDGET_EXCEEDED`：预算/回填上限超出
- `E_INVALID_ARGS`：参数被裁剪/非法
- `E_REPO_ROOT`：repo-root 解析失败或越权路径
- `E_SESSION`：Codex 会话恢复失败
- `E_UNKNOWN`：其他未分类错误

**入口层退出码（wrapper/hook）**：
- `0`：成功（包含降级但输出可用 JSON）
- `10`：编排不可用但已 fail-open（输出空注入 + [Limits]）
- `20`：配置错误（如无效 YAML/必需字段缺失）
- `30`：解析失败（编排 JSON 结构不合法）
- `40`：工具不可用或执行失败（可降级）
- `50`：预算超限/超时（可降级）

**编排内核 → 入口层 传递契约（强制）**：
- **成功路径**：
  - stdout：完整 JSON（见 I/O schema）
  - stderr：仅用于调试，不作为解析输入
  - exit code：`0`
- **失败路径（可降级）**：
  - stdout：仍输出 JSON，但 `degraded.is_degraded=true` 且 `tool_results[].error.code` 标明原因
  - stderr：可输出可读错误信息（不作为主解析来源）
  - exit code：`40` 或 `50`（由失败类型决定）
- **编排不可用（脚本缺失/不可执行）**：
  - 入口层不调用编排，直接输出“空注入 JSON” + `[Limits] orchestrator unavailable`，exit code `10`

**入口层分流逻辑（伪代码）**：
```bash
if ! executable "hooks/auto-tool-orchestrator.sh"; then
  emit_empty_json "orchestrator unavailable"; exit 10
fi
json_out=$(run_orchestrator) || {
  # non-zero exit still may have json
  if valid_json "$json_out"; then emit_json "$json_out"; exit $ORCH_EXIT; fi
  emit_empty_json "orchestrator output invalid"; exit 30
}
emit_json "$json_out"; exit 0
```

**用户可见文本（统一）**：
- 超时：`[Limits] tool timeout; degraded to plan-only`
- 解析失败：`[Limits] orchestrator output invalid; fallback to empty context`
- 工具不可用：`[Limits] tool unavailable; skipped`（附 tool 名）
- 预算超限：`[Limits] budget exceeded; results truncated`

#### 设计要点 8：中英文触发（回答用户 Q4）

- 自动注入不以语言作为开关：中文与英文均进入同一意图识别/编排逻辑。
- 触发信号覆盖：中英关键词 + 结构信号（文件路径、报错、符号名、代码块）。

#### 设计要点 9：结果融合与解释（回答用户 Q5、Q6）

- **结构化回填**：必须同时提供 `fused_context.for_model.structured`（供模型稳定消费）与 `additional_context`（文本兜底）。
- **用户可读解释**（默认展示，可折叠）：
  - [Auto Tools]：调用了哪些工具、为什么
  - [Results]：关键发现摘要（去重/合并）
  - [Limits]：预算/超时/降级/过滤说明
- **溯源**：每条关键结论必须能追溯到 tool/time/version（避免“幻觉式融合”）。

- **融合确定性规则（最小可执行 + 可测试）**：
  - 去重键：`tool + normalized_path + normalized_symbol + normalized_title`（缺省项用 `-` 占位）
  - 稳定排序：先 `tool` 字典序，再 `normalized_path` 字典序，再 `normalized_symbol`，再 `confidence` 降序，最后 `summary` 字典序
  - 摘要长度：每条摘要 `max_chars=240`，超出截断并追加 `…`，同时 `truncated=true`
  - 汇总条数上限：`max_items=12`，超出按排序截断，并在 [Limits] 写明“结果截断”
  - 冲突结论呈现：
    - 若相同去重键出现互斥结论（`conflict=true`），则在 [Results] 输出“冲突条目”并列出来源工具与时间
    - 冲突不自动消解，仅标记“需人工判断”
  - 稳定输出：同一输入、同一工具输出顺序必须稳定；禁止基于运行时 hash/随机数排序

- **[Limits] 文案锚点（强制）**：
  - Tier-2 默认关闭：`[Limits] tier-2 disabled by default; set CI_AUTO_TOOLS_TIER_MAX=2 to enable`
  - 会话降级：`[Limits] session continuity unavailable; fallback to stateless exec`
  - 入口层绕过拒绝：`[Limits] tool invocation must go through orchestrator`
  - 超时/预算：`[Limits] tool timeout; degraded to plan-only` / `[Limits] budget exceeded; results truncated`
  - 解析失败：`[Limits] orchestrator output invalid; fallback to empty context`

#### 设计要点 10：扩展点（回答用户 Q2）

- 客户端适配（Claude/Codex）与编排内核分离：新增客户端只需实现“输入采集 + 输出注入”适配层。
- 工具注册表配置化（`config/auto-tools.yaml`）：新增工具不改核心流程，仅添加配置与标准化规则。

#### 设计要点 11：安装/升级/卸载/验证路径（Claude hook + Codex wrapper）

- **Claude hook 安装**：
  - 位置：`~/.claude/hooks/context-inject-global.sh`
  - 安装命令（复用现有脚本）：`./install.sh --with-hook`（可叠加 `--global`）
  - 配置依赖：`~/.claude/settings.json` 的 `UserPromptSubmit` hooks
  - 升级：重复运行 `./install.sh --with-hook` 覆盖旧脚本（保留 settings 备份）
  - 卸载：删除 `~/.claude/hooks/context-inject-global.sh`，并从 `~/.claude/settings.json` 移除 hooks 配置
  - 验证：`cat ~/.claude/hooks/context-inject-global.sh | head -n 5`，并在 Claude Code 触发 [Auto Tools]

- **Codex wrapper 安装**：
  - 位置：`/usr/local/bin/codex-auto`（global）或 `<repo-root>/bin/codex-auto`（local）
  - PATH 依赖：global 模式需 `/usr/local/bin` 在 PATH；local 模式需 `export PATH="<repo-root>/bin:$PATH"`
  - 配置依赖：`~/.codex/config.toml` 已配置本项目 MCP server
  - 升级：重新执行安装脚本（覆盖同名 wrapper）
  - 卸载：删除对应 wrapper 文件；删除 session 文件 `<repo-root>/.devbooks/cache/auto-tools/codex-session.json`
  - 验证：`codex-auto --dry-run "ping"` 输出包含 `schema_version` 且不触发 codex

#### 验收标准（AC-xxx，含验证锚点）

| AC | 验收标准 | 可验证方式/证据锚点 |
|----|----------|---------------------|
| AC-001 | Claude Code 能在“模型输出前”完成工具调用并回填 | bats：模拟 UserPromptSubmit payload -> 断言输出包含 `tool_plan/tools`、`tool_results`、`fused_context` |
| AC-002 | Codex CLI 入口 A 的会话连续性可验证且可降级 | bats：模拟两种路径：1) `codex exec resume --last` 可用 -> 使用该命令；2) `--last` 不可用或失败 -> 降级为无会话模式，且 [Limits] 显示 `session continuity unavailable`；plan/dry-run 输出“将要执行的 codex 命令”作为无外部 codex 锚点 |
| AC-003 | plan/dry-run 可重复且不依赖外部 codex | bats：`CI_AUTO_TOOLS_MODE=plan` 或 `CI_AUTO_TOOLS_DRY_RUN=1` -> 输出包含 `schema_version/run_id/tool_plan`，且不触发 codex 命令 |
| AC-004 | 控制面可控且配置优先级为 env > config > default | bats：同一输入分别用 env 覆盖/无覆盖，断言 `tier_max/budget` 与开关生效 |
| AC-005 | repo-root 判定在无 git/子目录/monorepo 场景一致 | bats：模拟三场景 -> 断言 repo-root 来源优先级与路径过滤一致 |
| AC-006 | 白名单/参数裁剪/路径过滤/脱敏生效 | 安全样例：请求读取 `.env`/`id_rsa`/`..` 路径 -> 结果被过滤且 [Limits] 解释；构造超限参数（如 `ci_graph_rag.depth=10`）-> 裁剪生效且 [Limits] 包含 `depth clamped to 2`；构造入口层直连调用尝试 -> 被拒绝且 [Limits] 显示 `tool invocation must go through orchestrator`；脱敏样例含 `Bearer`/`BEGIN PRIVATE KEY` -> 输出被遮盖 |
| AC-007 | 预算/并发/回填限额为明确数字且默认可用 | bats：对超量结果触发 `truncated=true`；输出包含 `tool_plan/budget` 与 [Limits] |
| AC-008 | 失败不阻塞输出（fail-open），且降级可见 | bats：模拟工具超时/解析失败/编排不可用 -> `degraded.is_degraded=true` 且 [Limits] 含原因；编排不可用时输出空注入 JSON 且 exit code=10 |
| AC-009 | Tier-0/1 自动；Tier-2 默认关闭，仅显式确认启用；同包分阶段不拆包 | bats：默认配置下 Tier-2 不进入 plan；设置 `CI_AUTO_TOOLS_TIER_MAX=2` 后才进入计划；默认配置触发 Tier-2 意图时输出 `[Limits] tier-2 disabled by default; set CI_AUTO_TOOLS_TIER_MAX=2 to enable` |
| AC-010 | 提示注入防护策略落地 | 构造工具输出含“忽略之前指令/执行 rm -rf”等文本 -> 输出被过滤且 `safety.ignore_instructions_inside_tool_output=true` |
| AC-011 | 结果融合确定性规则稳定 | bats：同一输入重复两次 -> 输出顺序与摘要长度一致；冲突结论按规则呈现 |
| AC-012 | 错误码/退出码契约一致 | bats：模拟 timeout/解析失败/工具不可用/编排不可用 -> error.code 与退出码匹配；[Limits] 文本一致 |
| AC-013 | hooks 调用链清晰且 `augment-context-global.sh` 仍兼容 | bats：调用 `hooks/augment-context-global.sh` 断言等价于 `hooks/context-inject-global.sh` |
| AC-014 | I/O schema 版本与兼容策略明确 | 静态检查/测试：JSON 输出必须包含 `schema_version`；未来变更遵守 SemVer 与向前兼容 |
| AC-015 | Codex CLI 入口 B 仍可用于单次注入 | bats：单次执行 `codex exec <PROMPT>` 前置注入 -> 断言增强 prompt 含 `run_id` 且输出 [Limits] |

---

### Impact（影响分析）

#### Transaction Scope

`None`（不涉及跨服务事务；主要为本地 Hook/脚本/配置与 MCP 调用链调整）

#### 受影响的模块

| 模块 | 影响类型 | 影响程度 |
|------|----------|----------|
| `hooks/` | 新增/修改 | 高 |
| `config/` | 新增 | 中 |
| `docs/` | 新增/修改 | 中 |
| `tests/` | 新增/修改 | 中 |
| `src/` | 可选（若需对 MCP 调用参数/输出格式做适配） | 低-中 |

#### 兼容性

- 目标是默认不破坏现有“手动调用工具”的使用方式
- Hook/Wrapper 的输出应保持向后兼容：即使自动化关闭，也能输出空注入或仅注入项目画像

#### 风险

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 自动调用导致延迟增加 | 中 | 高 | 分层 + 预算 + 并发控制 + 缓存 + 降级 |
| 结果噪音反而干扰模型 | 中 | 中-高 | top-k、聚合去重、明确溯源、解释摘要 |
| 不同客户端调用链差异导致“未必能预调用” | 低-中 | 高 | 以 Hook/Wrapper 为强入口；在测试中验证“输出前调用” |
| 工具不可用/索引不可用导致失败 | 中 | 中 | 先 `ci_index_status`，并提供降级路径 |
| 安全/隐私风险（意外读到敏感文件） | 低-中 | 高 | 白名单 + 路径过滤 + 输出脱敏 + 明确提示 |

---

### Alternatives（备选方案）

#### 方案 A：把所有逻辑塞进 `hooks/context-inject-global.sh`

**优势**：文件更少，短期快

**劣势**：入口脚本会持续膨胀，难扩展、难测试，未来接入新客户端更痛苦

**适合**：一次性脚本，不考虑长期维护

#### 方案 B（推荐）：入口适配层 + 编排内核拆分

**优势**：职责清晰、可扩展、可测试；可在不改入口的前提下迭代编排策略

**劣势**：多一个脚本与配置，需要最小文档说明

**适合**：本项目“平台化/可扩展”的目标

---

### Decision（决策，待 Judge 裁决）

**推荐选择**：方案 B（入口适配层 + 编排内核拆分）。

**关键决策点（提案给出默认）**：
- 自动调用策略：尽可能调用合适工具，但受白名单/预算/阈值边界约束（反对无上限全调用）
- 语言支持：中英文均支持（语言无关）
- 交付边界：仅 Claude Code + Codex CLI；Cursor 等明确不做

---

## 批准历史

| 时间 | 阶段 | 操作 | 操作者 | 理由 |
|------|------|------|--------|------|
| 2026-01-23 | Proposal | 创建 | AI（Proposal Author） | 根据 `用户初始要求.md` 生成 |

## Decision Log

### 2026-01-23 裁决：Revise

**理由摘要**：
- 已核验：本文件正文不包含“占位式截断文本”；Challenger 提到的截断内容很可能来自工具输出被截断（该点不构成本次裁决的阻断理由）。
- Codex CLI “模型输出前调用”的集成路径未明确（入口/触发时机/差异点），可行性与改动面无法评估。
- 控制面（开关/降级/回滚）与默认预算（超时/并发/回填上限）缺失，会导致体验、成本与稳定性不可控。
- 安全边界缺口：白名单/参数约束/路径过滤与脱敏/日志与回填敏感信息策略未定义。
- 契约与验收锚点不足：编排输出 schema/兼容策略未明确，AC 未绑定可执行验证，存在范围膨胀与“假完成”风险。

**必须修改项**（若 Revise）：
- [ ] 明确 Codex CLI “模型输出前”集成路径：入口形式（wrapper/hook/其他）、触发时机、最小配置、与 Claude Code 的差异点。
- [ ] 定义控制面：默认开关、用户可控选项（完全关闭/降级到 Tier-1/仅生成 Plan）、配置优先级（env > config > default）、失败后的自动回滚与“不阻塞输出”策略。
- [ ] 给出安全边界：自动调用工具白名单来源与审核方式、参数约束（防止危险参数）、路径过滤与脱敏规则、日志与回填中敏感信息的处理策略。
- [ ] 明确编排内核 I/O 契约：Tool Plan/Tool Results/Fused Context 的 JSON schema（字段/类型/必填/可选/版本号/兼容策略），以及终端文本输出格式约束。
- [ ] 预算与并发默认值落地为具体数字：总超时、单工具超时、并发数、回填 token/字节上限、top-k 等，并解释取值依据（保守/激进的权衡）。
- [ ] 失败模型与提示注入防护：工具输出视为不可信数据；融合提示中显式声明不得执行工具输出中的指令；定义超时/部分失败/解析失败时的合并与降级规则。
- [ ] 澄清与现有 hooks 的关系：`hooks/context-inject-global.sh`、`hooks/augment-context-global.sh` 与拟新增 `hooks/auto-tool-orchestrator.sh` 的职责边界、调用链、向后兼容策略。
- [ ] 验收标准补齐可验证锚点：每个 AC 绑定至少一个可执行验证（bats 测试/静态检查/示例命令）；并核查/消除重复或冲突的 AC。
- [ ] 移除“24 小时后自动批准”的默认条款，改为显式批准，避免绕过裁决流程。
- [ ] Tier 分层依据与触发条件写清：每个 Tier 的准入标准（成本/风险/稳定性/信息增益）、Tier-2 的默认触发条件与“需要用户确认”的边界。
- [ ] 范围收敛（仍在同一变更包内）：先定义 MVP（默认仅 Tier-0/1 自动；Tier-2 仅条件触发或需用户确认），将非 MVP 明确标注为“可选/后续”，避免本次交付范围膨胀。

**验证要求**：
- [ ] 在 proposal 中补充至少 1 条可重复的端到端验证步骤：给定输入 prompt，能证明“工具在回答前执行且回填被消费”（可用 hooks 输出中的时间戳/标记字段作为证据）。
- [ ] 增加最小安全验证说明：构造“工具输出包含提示注入文本”的样例，验证融合提示不会把其当成系统指令执行。
- [ ] 增加最小降级验证说明：模拟工具超时/不可用时仍能生成可用输出，并显式标注降级原因与降级到的层级。

### 2026-01-23 补记：关于占位核验（Revise 回合）

- 已复核：当前 `proposal.md` 正文未包含任何“占位式截断字符串”；若历史讨论中出现“正文存在截断占位”的说法，以本条核验结果为准。
- 本次 Revise 已将提案正文改为完整可读文本；不再依赖任何“省略/截断占位”来表达结构。

### 2026-01-23 裁决：Revise

**理由摘要**：
- Codex CLI 入口 A 的会话连续性仍缺定义：需明确 `codex exec resume --last` 的可用性与降级边界，确保可测试与可回退。
- 验收锚点仍缺“可重复且不依赖外部 codex”的路径：需要明确 `CI_AUTO_TOOLS_MODE=plan`/`--dry-run` 的可测试输出（增强 prompt 或编排 JSON）以供 bats 断言“先编排后回答”。
- repo-root 判定与非 git/子目录/monorepo 行为未定义，路径过滤规则缺乏可验证边界。
- 结果融合确定性与错误码/退出码契约缺口：去重/排序/摘要长度/冲突处理与 error.code 枚举未明示，影响稳定性与可测试性。
- 安装/升级/卸载/验证路径未成文：Claude hook 与 Codex wrapper 的安装位置、PATH 要求与回滚验证流程缺失。

**必须修改项**（若 Revise）：
- [ ] Codex CLI 入口 A 的会话连续性方案：以 `codex exec resume --last` 为首选路径，失败即降级为无会话模式，并给出最小可实现路径。
- [ ] 明确 `CI_AUTO_TOOLS_MODE=plan` 或 `--dry-run` 的输出接口：输出增强 prompt/编排 JSON，且在此模式下不调用 codex；补充 bats 用例断言。
- [ ] repo-root 判定规则：`git rev-parse --show-toplevel`/`pwd`/配置的优先级；无 git/monorepo/子目录场景的行为与错误处理。
- [ ] 结果融合确定性规则：去重键、聚合顺序（稳定排序）、摘要长度/截断策略、冲突结论呈现；并给出示例。
- [ ] 定义 error.code 与入口层退出码枚举，说明超时/解析失败/工具不可用等失败类型的降级路径与用户可见文本。
- [ ] 补充安装/升级/卸载/验证流程：Claude hooks 与 Codex wrapper 的安装位置、PATH/配置依赖、回滚与验证命令。

**验证要求**：
- [ ] bats 覆盖 plan/dry-run 输出：给定固定 prompt，断言输出包含 `schema_version/run_id/tool_plan` 且未执行 codex。
- [ ] e2e/脚本验证 Codex wrapper 会话恢复：模拟连续两轮 prompt，验证 `codex exec resume --last` 或降级逻辑与 [Limits] 输出。
- [ ] 路径过滤验证用例：在无 git/子目录/monorepo 三场景下，断言 repo-root 解析与过滤行为一致。
- [ ] 结果融合确定性验证：同一输入重复执行输出顺序与摘要长度稳定（含示例断言）。
- [ ] 错误码/退出码验证：模拟 timeout/解析失败/工具不可用并断言 code 与 [Limits] 文本一致。

### 2026-01-23 修订说明（Author）

- 已收敛入口层为“输入采集 + 输出注入”，明确迁移/去重路径与回滚策略，确保工具调用统一进入编排内核。
- 已将 Codex CLI 会话连续性改为 `codex exec resume --last` 优先、失败即降级为无会话模式，不再依赖 `--json/session_id`。
- 已补齐“唯一工具通道 + 绕过拒绝”策略与 [Limits] 提示，并在 AC-006/AC-009 补充绕过与 Tier-2 提示验证锚点。
- 已明确 Tier-2 唯一启用入口为 `CI_AUTO_TOOLS_TIER_MAX=2`，默认提示文本与最短用户决策树。

### 2026-01-23 裁决：Revise

**理由摘要**：
- 编排内核与现有 `hooks/context-inject-global.sh` 的边界仍停留在描述层，未给出迁移/复用或去重路径；在现有脚本已包含编排逻辑的前提下存在“双轨并存、行为不一致”的风险。
- Codex CLI 会话连续性仍未确定唯一可验证路径，需要明确 `codex exec resume --last` 的可用性与降级边界，确保 AC-002 可测试。
- 参数裁剪/白名单“强制执行”缺少对入口层直连工具路径的拦截或迁移说明，存在绕过编排内核导致安全边界失效的风险。
- Tier-2 的显式触发与用户提示仍不够可执行（仅给开关、缺少触发方式与默认提示行为），MVP 的可用性与范围收敛仍不清晰。

**必须修改项**（若 Revise）：
- [ ] 给出 `hooks/context-inject-global.sh` 与 `hooks/auto-tool-orchestrator.sh` 的迁移/复用方案：明确哪些既有编排逻辑会被移出或封装进内核，保证入口层不再直接调用工具；补充向后兼容与回滚策略。
- [ ] 移除 `codex exec --json/session_id` 依赖，改为 `codex exec resume --last` 优先、失败即降级为无会话模式，并明确 AC-002 的可验证锚点。
- [ ] 明确参数裁剪/白名单的唯一执行点与绕过检测机制：定义入口层调用工具的唯一通道，或提供拦截/拒绝策略，并在 [Limits] 明示裁剪原因。
- [ ] 明确 Tier-2 的显式触发路径与用户提示：定义 CLI 参数/环境变量/配置的唯一入口，默认情况下输出清晰提示并指向启用方法，说明何时建议启用。

**验证要求**：
- [ ] 增加迁移/互斥验证：静态检查或 bats 断言入口层所有工具调用均经编排内核；验证回滚路径可用。
- [ ] 提供 `codex exec resume --last` 的可重复验证步骤，并验证不可用/失败时降级输出包含 [Limits] 说明。
- [ ] 增加参数裁剪绕过测试：构造入口层直连或超限参数输入，验证被裁剪/拒绝且 [Limits] 可见。
- [ ] 增加 Tier-2 启用提示验证：默认配置触发 Tier-2 意图时输出“需显式启用”的提示；启用后进入 plan。
