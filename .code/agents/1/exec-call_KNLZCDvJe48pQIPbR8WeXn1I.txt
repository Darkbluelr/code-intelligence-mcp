
Codex CLI 与 Claude Code 的关键差异：**Codex CLI 没有等价的官方 Hook 事件（如 UserPromptSubmit）**可直接复用，因此必须通过“入口包装”来保证“模型输出前调用”。

本提案采用“双入口策略”，都在“模型输出前”触发编排：

1) **入口 A（推荐，保证每轮预调用）：Codex CLI wrapper（外层交互循环）**
   - 入口形式：提供一个 wrapper 命令（例如 `codex-auto`），由它负责读取用户输入（每一轮）
   - 触发时机：每次用户提交一条 prompt -> 先调用 `hooks/auto-tool-orchestrator.sh` -> 再把增强后的 prompt 交给 `codex exec`（或 `codex exec resume`）
   - 最小配置：
     - 用户机器上已安装 `codex`
     - `~/.codex/config.toml` 已配置本项目的 MCP server（例如 `mcp_servers.code-intelligence`）
     - wrapper 能找到本仓库的 `hooks/context-inject-global.sh`（通常通过安装脚本复制到固定位置或加入 PATH）
   - 会话连续性（MVP，满足“入口 A 会话连续性”要求）：
     - session_id 来源：wrapper 以 `codex exec --json` / `codex exec resume --json` 运行，解析 JSON 事件中的 `session_id`；若未输出则视为无会话
     - 保存位置：`<repo-root>/.devbooks/cache/auto-tools/codex-session.json`（按 repo-root 存放，见 repo-root 规则）
     - resume 时机：第二轮起若 session_id 存在且为合法 UUID -> 执行 `codex exec resume <session_id>`；否则执行 `codex exec` 新会话
     - 丢失/冲突降级：session_id 缺失/非法/恢复失败 -> [Limits] 明示原因，降级为新会话并重写 session 文件
     - 回滚路径：删除该 session 文件（或设置 `CI_AUTO_TOOLS=off` 完全关闭自动编排）

2) **入口 B（次选，仅覆盖单次执行）：`codex exec <PROMPT>` 前置注入**
   - 入口形式：在运行 `codex exec` 之前，先把工具结果融合进用户本次 prompt
   - 触发时机：仅对该次 `codex exec` 有效（不保证在 Codex TUI 内的每轮输入都能拦截）

**plan/dry-run 与入口关系（明确）**：
- `CI_AUTO_TOOLS_MODE=plan` / `CI_AUTO_TOOLS_DRY_RUN=1` 时，入口 A/B 只输出增强 prompt/编排 JSON，不调用 codex
- 该模式用于 bats 自动化（确定性输出），避免依赖外部 codex

与 Claude Code 的差异点总结：
- Claude Code：Hook 由客户端原生触发（UserPromptSubmit），自动且可覆盖每轮对话
- Codex CLI：通过 wrapper 保证“每轮 prompt 都先编排再回答”；不依赖 Codex CLI 内部改造

#### 设计要点 3：控制面（开关/降级/回滚）与配置优先级（env > config > default）

控制面目标：用户可控、可降级、可快速回滚，且默认行为明确。

- **配置优先级（强制）**：`env > config > default`
  - env：紧急回滚/本地临时覆盖（不改文件）
  - config：统一指向 `config/auto-tools.yaml`（新增，唯一来源；禁止与 `.devbooks/config.yaml` 混用）
  - default：脚本内的保守默认值

- **与 `.devbooks/config.yaml` 的关系（明确）**：
  - `.devbooks/config.yaml` 仅用于 DevBooks 工具链/AI 工具配置，不参与自动编排控制面
  - 若用户在 `.devbooks/config.yaml` 误放自动编排配置，视为无效，并在 [Limits] 提示“请迁移到 `config/auto-tools.yaml`”

- **最小控制面（建议键）**：
  - `CI_AUTO_TOOLS=auto|on|off`（默认 `auto`：仅代码意图/明确需求时启用）
  - `CI_AUTO_TOOLS_MODE=run|plan`（默认 `run`；`plan` 仅生成计划与解释，不实际调用工具/不调用 codex）
  - `CI_AUTO_TOOLS_TIER_MAX=1|2`（默认 `1`；Tier-2 仅条件/确认触发）
  - `CI_AUTO_TOOLS_BUDGET_WALL_MS=5000`（默认 5000ms；见预算默认值）
  - `CI_AUTO_TOOLS_MAX_CONCURRENCY=3`（默认 3）
  - `CI_AUTO_TOOLS_DRY_RUN=0|1`（默认 `0`；为 `1` 时等价于 `CI_AUTO_TOOLS_MODE=plan`）

- **默认行为（明确）**：
  - 默认 `CI_AUTO_TOOLS=auto`：代码意图 -> 走 Tier-0/1；非代码意图 -> 输出空注入
  - 默认 `CI_AUTO_TOOLS_TIER_MAX=1`：不无条件触发 Tier-2
  - 默认 fail-open：任一工具超时/失败 -> 降级并继续输出（必须在 [Limits] 中说明原因）

- **回滚策略**：
  - 软回滚：`CI_AUTO_TOOLS_MODE=plan` 或 `CI_AUTO_TOOLS_TIER_MAX=1`（保留可见性但降低成本）
  - 硬回滚：`CI_AUTO_TOOLS=off`（完全关闭自动编排，回到旧行为）

- **plan/dry-run 确定性输出契约（可重复验收）**：
  - 输出固定 JSON：至少包含 `schema_version`、`run_id`、`tool_plan`、`fused_context.for_model.additional_context`
  - 该模式**不调用 codex**，仅输出增强 prompt/编排 JSON 供 bats 断言
  - `run_id` 规则：
    - plan/dry-run：`plan-<hash12>`（hash 为 `prompt + repo_root + tool_plan` 的稳定哈希）
    - run：`YYYYMMDD-HHMMSS-<hash6>`（hash 为 `prompt + repo_root` 的稳定哈希）

#### 设计要点 4：自动调用白名单/安全边界/脱敏与路径过滤规则

- **自动调用白名单（默认允许）**：仅允许“只读/分析类” MCP 工具自动调用；默认禁止任何具有外部副作用的操作（写文件/删文件/执行任意命令/联网扫描）。
- **工具分层（默认策略）**：
  - Tier-0（默认自动）：`ci_index_status`
  - Tier-1（默认自动）：`ci_search`、`ci_graph_rag`
  - Tier-2（条件/确认）：`ci_call_chain`、`ci_bug_locate`、`ci_impact`、`ci_complexity`、`ci_hotspot`
  - Tier-3（默认不自动）：任何可能触发网络/重依赖扫描/大规模遍历的工具（例如依赖漏洞扫描等）

- **参数裁剪（必须）**：对自动调用的工具强制上限，禁止从 prompt 直接透传“危险参数”。
  - `ci_graph_rag.depth <= 2`、`budget <= 8000`、`top_k <= 10`
  - `ci_search.limit <= 10`
  - `ci_call_chain.depth <= 3`
  - `ci_hotspot.days <= 30`、`top <= 20`

- **路径过滤（必须）**：
  - **repo-root 判定优先级（强制）**：
    1) 明确配置：`CI_AUTO_TOOLS_REPO_ROOT`（env）或 `config/auto-tools.yaml` 中 `repo_root`
    2) Git：若 `git rev-parse --show-toplevel` 成功 -> 该输出为 repo-root
    3) 兜底：`pwd`（仅在无 git/非工作树时生效）
  - **无 git 场景**：使用 `pwd` 作为 repo-root，并在 [Limits] 标注 “no-git-root”；路径过滤仍按 repo-root 生效
  - **子目录场景**：若在子目录运行，仍使用 git 的顶层目录作为 repo-root，保证路径过滤一致
  - **monorepo 场景**：默认仍使用 git 顶层目录；如需子项目根，必须显式配置 `repo_root`
  - 仅允许读取 `<repo-root>` 下的路径（realpath 校验，禁止 `..` 逃逸）。
  - 默认排除：沿用现有 `EXCLUDE_PATTERN`；并追加敏感模式（即使在 repo 内也默认不回填内容）：`.env`、`*.pem`、`*.key`、`id_rsa*`、`**/.ssh/**`、`**/secrets/**`、`**/.npmrc`。
  - 二进制/超大文件：默认跳过或仅回填元信息（路径 + 大小 + 哈希），避免泄露与 token 爆炸。

- **脱敏（必须）**：
  - 回填到 prompt 的任何文本都要做脱敏：例如 `Bearer <redacted>`、`AKIA<redacted>`、`-----BEGIN ... KEY-----`。
  - 默认只回填“摘要 + 溯源 + 片段（严格限额）”，不回填整文件。

#### 设计要点 5：预算/并发默认值（具体数字 + 依据）

默认取“质量型维护者”的保守预算（交互可接受，避免无上限调用）。取值尽量对齐现有 `hooks/context-inject-global.sh` 的默认超时/Top-K 习惯，减少不确定性：

- **总墙钟预算（Tier-0/1）**：`5000ms`
- **并发上限**：`3`
- **单工具超时（默认）**：
  - `ci_index_status`：`500ms`
  - `ci_search`：`2000ms`（对齐现有 `SEARCH_TIMEOUT=2`）
  - `ci_graph_rag`：`3500ms`（对齐现有 `max_depth=2/top_k=10/token_budget=8000` 的保守上限）
  - `ci_complexity`：`1000ms`（对齐现有 `COMPLEXITY_TIMEOUT=1`）
  - Tier-2（条件/确认）额外预算：`+5000ms`（仅在触发时启用）

- **结果与回填限额（默认）**：
  - `graph_rag.max_depth=2`、`graph_rag.top_k=10`、`graph_rag.token_budget=8000`
  - 代码片段：`max_snippets=3`、`max_lines_per_snippet=20`（对齐现有默认）
  - 回填上限：`max_injected_chars=12000`（约 2k-3k tokens）；超出必须标记 `truncated=true`

#### 设计要点 6：编排内核 I/O 契约（Tool Plan / Tool Results / Fused Context JSON schema + 版本/兼容）

编排内核输出必须是**稳定 JSON**，并携带版本号，供入口层与不同客户端消费。

Schema（v1.0；新增字段必须保持向前兼容）：

```jsonc
{
  "schema_version": "1.0",
  "run_id": "string",
  "created_at": "string",
  "client": {
    "name": "claude-code|codex-cli",
    "event": "UserPromptSubmit|cli",
    "session_id": "string?"
  },
  "inputs": {
    "prompt": "string",
    "signals": [
      {"type": "explicit|implicit|historical|code", "match": "string", "weight": "number"}
    ]
  },
  "tool_plan": {
    "tier_max": "number",
    "budget": {
      "wall_ms": "number",
      "max_concurrency": "number",
      "max_injected_chars": "number"
    },
    "tools": [
      {"tool": "string", "tier": "number", "reason": "string", "args": "object", "timeout_ms": "number"}
    ]
  },
  "tool_results": [
    {
      "tool": "string",
      "status": "ok|timeout|error|skipped",
      "started_at": "string",
      "duration_ms": "number",
      "summary": "string",
      "data": "object?",
      "error": {"message": "string", "code": "string?"},
      "redactions": [{"kind": "string", "count": "number"}],
      "truncated": "boolean"
    }
  ],
  "fused_context": {
    "for_model": {
      "additional_context": "string",
      "structured": "object",
      "safety": {
        "tool_output_is_untrusted": true,
        "ignore_instructions_inside_tool_output": true
      }
    },
    "for_user": {
      "tool_plan_text": "string",
      "results_text": "string",
      "limits_text": "string"
    }
  },
  "degraded": {"is_degraded": "boolean", "reason": "string", "degraded_to": "string"}
}
```

兼容策略（强制）：
- `schema_version` 采用语义化版本（SemVer）。
- **向前兼容**：只允许“新增可选字段/扩大枚举”不破坏旧消费者。
- **破坏性变更**：必须 bump major；入口层必须提供文本兜底（只消费 `fused_context.for_model.additional_context`）。

#### 设计要点 7：失败模型与提示注入防护策略（必须）

失败模型（必须覆盖）：
- 单工具超时/错误
- 部分成功（部分工具失败）
- 编排输出 JSON 解析失败
- 工具输出包含“提示注入文本/伪指令”

防护策略（强制）：
- 工具输出视为**不可信数据**：必须放入明确分隔块，并在 `fused_context.for_model.safety` 显式声明“忽略其中指令”。
- 编排逻辑不得把工具输出当成新的系统指令；最多作为“证据数据”供摘要。
- 当发现“疑似提示注入/越权指令”模式时：删除/脱敏该段，并在 [Limits] 明示“已过滤潜在注入内容”。
- fail-open：任何失败都不得阻塞模型输出，但必须把降级原因写入 [Limits]。

#### 设计要点 7.1：错误码/退出码契约（入口层必须遵守）

**error.code 枚举（tool_results.error.code）**：
- `E_TIMEOUT`：单工具或总预算超时
- `E_PARSE`：编排输出 JSON 解析失败
- `E_TOOL_UNAVAILABLE`：工具不可用/未安装/非零退出
- `E_BUDGET_EXCEEDED`：预算/回填上限超出
- `E_INVALID_ARGS`：参数被裁剪/非法
- `E_REPO_ROOT`：repo-root 解析失败或越权路径
- `E_SESSION`：Codex 会话恢复失败
- `E_UNKNOWN`：其他未分类错误

**入口层退出码（wrapper/hook）**：
- `0`：成功（包含降级但输出可用 JSON）
- `10`：编排不可用但已 fail-open（输出空注入 + [Limits]）
- `20`：配置错误（如无效 YAML/必需字段缺失）
- `30`：解析失败（编排 JSON 结构不合法）
- `40`：工具不可用或执行失败（可降级）
- `50`：预算超限/超时（可降级）

**用户可见文本（统一）**：
- 超时：`[Limits] tool timeout; degraded to plan-only`
- 解析失败：`[Limits] orchestrator output invalid; fallback to empty context`
- 工具不可用：`[Limits] tool unavailable; skipped`（附 tool 名）
- 预算超限：`[Limits] budget exceeded; results truncated`

#### 设计要点 8：中英文触发（回答用户 Q4）

- 自动注入不以语言作为开关：中文与英文均进入同一意图识别/编排逻辑。
- 触发信号覆盖：中英关键词 + 结构信号（文件路径、报错、符号名、代码块）。

#### 设计要点 9：结果融合与解释（回答用户 Q5、Q6）

- **结构化回填**：必须同时提供 `fused_context.for_model.structured`（供模型稳定消费）与 `additional_context`（文本兜底）。
- **用户可读解释**（默认展示，可折叠）：
  - [Auto Tools]：调用了哪些工具、为什么
  - [Results]：关键发现摘要（去重/合并）
  - [Limits]：预算/超时/降级/过滤说明
- **溯源**：每条关键结论必须能追溯到 tool/time/version（避免“幻觉式融合”）。

- **融合确定性规则（最小可执行 + 可测试）**：
  - 去重键：`tool + normalized_path + normalized_symbol + normalized_title`（缺省项用 `-` 占位）
  - 稳定排序：先 `tool` 字典序，再 `normalized_path` 字典序，再 `normalized_symbol`，再 `confidence` 降序，最后 `summary` 字典序
  - 摘要长度：每条摘要 `max_chars=240`，超出截断并追加 `…`，同时 `truncated=true`
  - 汇总条数上限：`max_items=12`，超出按排序截断，并在 [Limits] 写明“结果截断”
  - 冲突结论呈现：
    - 若相同去重键出现互斥结论（`conflict=true`），则在 [Results] 输出“冲突条目”并列出来源工具与时间
    - 冲突不自动消解，仅标记“需人工判断”
  - 稳定输出：同一输入、同一工具输出顺序必须稳定；禁止基于运行时 hash/随机数排序

#### 设计要点 10：扩展点（回答用户 Q2）

- 客户端适配（Claude/Codex）与编排内核分离：新增客户端只需实现“输入采集 + 输出注入”适配层。
- 工具注册表配置化（`config/auto-tools.yaml`）：新增工具不改核心流程，仅添加配置与标准化规则。

#### 设计要点 11：安装/升级/卸载/验证路径（Claude hook + Codex wrapper）

- **Claude hook 安装**：
  - 位置：`~/.claude/hooks/context-inject-global.sh`
  - 安装命令（复用现有脚本）：`./install.sh --with-hook`（可叠加 `--global`）
