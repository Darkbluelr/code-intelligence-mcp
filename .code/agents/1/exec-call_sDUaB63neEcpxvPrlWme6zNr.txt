
三者关系（都需要存在，且是**调用链**而非互斥）：

```
Claude Code (UserPromptSubmit)
  -> ~/.claude/hooks/context-inject-global.sh
       -> hooks/context-inject-global.sh (入口适配层)
            -> hooks/auto-tool-orchestrator.sh (编排内核)

兼容层：hooks/augment-context-global.sh
  -> exec hooks/context-inject-global.sh (仅为历史路径/测试保持兼容)
```

- `hooks/context-inject-global.sh`：入口与适配层
  - 负责输入适配：Claude Code Hook payload / Codex CLI wrapper 输入 / CLI 参数（如 `--prompt`）
  - 负责输出适配：
    - Claude Code：输出 `hookSpecificOutput.additionalContext`
    - Codex CLI：输出可拼接到 prompt 的“增强上下文块”（或 JSON 供 wrapper 二次格式化）
  - 负责**可控性与降级**：根据控制面决定是否调用编排内核；失败时 fail-open（不阻塞模型输出）

- `hooks/augment-context-global.sh`：仅做向后兼容
  - 现状已是“委托给 `context-inject-global.sh`”的 wrapper；本次保持该定位不膨胀

- `hooks/auto-tool-orchestrator.sh`：编排内核
  - 输入：标准化 prompt + signals + budget + allowlist + policy
  - 输出：Tool Plan + Tool Results + Fused Context（见下方 I/O 契约）

#### 设计要点 2：Codex CLI “模型输出前调用”的集成路径（补齐入口/触发/最小配置/差异）

Codex CLI 与 Claude Code 的关键差异：**Codex CLI 没有等价的官方 Hook 事件（如 UserPromptSubmit）**可直接复用，因此必须通过“入口包装”来保证“模型输出前调用”。

本提案采用“双入口策略”，都在“模型输出前”触发编排：

1) **入口 A（推荐，保证每轮预调用）：Codex CLI wrapper（外层交互循环）**
   - 入口形式：提供一个 wrapper 命令（例如 `codex-auto`），由它负责读取用户输入（每一轮）
   - 触发时机：每次用户提交一条 prompt -> 先调用 `hooks/auto-tool-orchestrator.sh` -> 再把增强后的 prompt 交给 `codex exec`（或 `codex exec resume`）
   - 最小配置：
     - 用户机器上已安装 `codex`
     - `~/.codex/config.toml` 已配置本项目的 MCP server（例如 `mcp_servers.code-intelligence`）
     - wrapper 能找到本仓库的 `hooks/context-inject-global.sh`（通常通过安装脚本复制到固定位置或加入 PATH）

2) **入口 B（次选，仅覆盖单次执行）：`codex exec <PROMPT>` 前置注入**
   - 入口形式：在运行 `codex exec` 之前，先把工具结果融合进用户本次 prompt
   - 触发时机：仅对该次 `codex exec` 有效（不保证在 Codex TUI 内的每轮输入都能拦截）

与 Claude Code 的差异点总结：
- Claude Code：Hook 由客户端原生触发（UserPromptSubmit），自动且可覆盖每轮对话
- Codex CLI：通过 wrapper 保证“每轮 prompt 都先编排再回答”；不依赖 Codex CLI 内部改造

#### 设计要点 3：控制面（开关/降级/回滚）与配置优先级（env > config > default）

控制面目标：用户可控、可降级、可快速回滚，且默认行为明确。

- **配置优先级（强制）**：`env > config > default`
  - env：紧急回滚/本地临时覆盖（不改文件）
  - config：项目内持久化策略（例如 `config/auto-tools.yaml`）
  - default：脚本内的保守默认值

- **最小控制面（建议键）**：
  - `CI_AUTO_TOOLS=auto|on|off`（默认 `auto`：仅代码意图/明确需求时启用）
  - `CI_AUTO_TOOLS_MODE=run|plan`（默认 `run`；`plan` 仅生成计划与解释，不实际调用工具）
  - `CI_AUTO_TOOLS_TIER_MAX=1|2`（默认 `1`；Tier-2 仅条件/确认触发）
  - `CI_AUTO_TOOLS_BUDGET_WALL_MS=5000`（默认 5000ms；见预算默认值）
  - `CI_AUTO_TOOLS_MAX_CONCURRENCY=3`（默认 3）

- **默认行为（明确）**：
  - 默认 `CI_AUTO_TOOLS=auto`：代码意图 -> 走 Tier-0/1；非代码意图 -> 输出空注入
  - 默认 `CI_AUTO_TOOLS_TIER_MAX=1`：不无条件触发 Tier-2
  - 默认 fail-open：任一工具超时/失败 -> 降级并继续输出（必须在 [Limits] 中说明原因）

- **回滚策略**：
  - 软回滚：`CI_AUTO_TOOLS_MODE=plan` 或 `CI_AUTO_TOOLS_TIER_MAX=1`（保留可见性但降低成本）
  - 硬回滚：`CI_AUTO_TOOLS=off`（完全关闭自动编排，回到旧行为）

#### 设计要点 4：自动调用白名单/安全边界/脱敏与路径过滤规则

- **自动调用白名单（默认允许）**：仅允许“只读/分析类” MCP 工具自动调用；默认禁止任何具有外部副作用的操作（写文件/删文件/执行任意命令/联网扫描）。
- **工具分层（默认策略）**：
  - Tier-0（默认自动）：`ci_index_status`
  - Tier-1（默认自动）：`ci_search`、`ci_graph_rag`
  - Tier-2（条件/确认）：`ci_call_chain`、`ci_bug_locate`、`ci_impact`、`ci_complexity`、`ci_hotspot`
  - Tier-3（默认不自动）：任何可能触发网络/重依赖扫描/大规模遍历的工具（例如依赖漏洞扫描等）

- **参数裁剪（必须）**：对自动调用的工具强制上限，禁止从 prompt 直接透传“危险参数”。
  - `ci_graph_rag.depth <= 2`、`budget <= 8000`、`top_k <= 10`
  - `ci_search.limit <= 10`
  - `ci_call_chain.depth <= 3`
  - `ci_hotspot.days <= 30`、`top <= 20`

- **路径过滤（必须）**：
  - 仅允许读取 `<repo-root>` 下的路径（realpath 校验，禁止 `..` 逃逸）。
  - 默认排除：沿用现有 `EXCLUDE_PATTERN`；并追加敏感模式（即使在 repo 内也默认不回填内容）：`.env`、`*.pem`、`*.key`、`id_rsa*`、`**/.ssh/**`、`**/secrets/**`、`**/.npmrc`。
  - 二进制/超大文件：默认跳过或仅回填元信息（路径 + 大小 + 哈希），避免泄露与 token 爆炸。

- **脱敏（必须）**：
  - 回填到 prompt 的任何文本都要做脱敏：例如 `Bearer <redacted>`、`AKIA<redacted>`、`-----BEGIN ... KEY-----`。
  - 默认只回填“摘要 + 溯源 + 片段（严格限额）”，不回填整文件。

#### 设计要点 5：预算/并发默认值（具体数字 + 依据）

默认取“质量型维护者”的保守预算（交互可接受，避免无上限调用）。取值尽量对齐现有 `hooks/context-inject-global.sh` 的默认超时/Top-K 习惯，减少不确定性：

- **总墙钟预算（Tier-0/1）**：`5000ms`
- **并发上限**：`3`
- **单工具超时（默认）**：
  - `ci_index_status`：`500ms`
  - `ci_search`：`2000ms`（对齐现有 `SEARCH_TIMEOUT=2`）
  - `ci_graph_rag`：`3500ms`（对齐现有 `max_depth=2/top_k=10/token_budget=8000` 的保守上限）
  - `ci_complexity`：`1000ms`（对齐现有 `COMPLEXITY_TIMEOUT=1`）
  - Tier-2（条件/确认）额外预算：`+5000ms`（仅在触发时启用）

- **结果与回填限额（默认）**：
  - `graph_rag.max_depth=2`、`graph_rag.top_k=10`、`graph_rag.token_budget=8000`
  - 代码片段：`max_snippets=3`、`max_lines_per_snippet=20`（对齐现有默认）
  - 回填上限：`max_injected_chars=12000`（约 2k-3k tokens）；超出必须标记 `truncated=true`

#### 设计要点 6：编排内核 I/O 契约（Tool Plan / Tool Results / Fused Context JSON schema + 版本/兼容）

编排内核输出必须是**稳定 JSON**，并携带版本号，供入口层与不同客户端消费。

Schema（v1.0；新增字段必须保持向前兼容）：

```jsonc
{
  "schema_version": "1.0",
  "run_id": "string",
  "created_at": "string",
  "client": {
    "name": "claude-code|codex-cli",
    "event": "UserPromptSubmit|cli",
    "session_id": "string?"
  },
  "inputs": {
    "prompt": "string",
    "signals": [
      {"type": "explicit|implicit|historical|code", "match": "string", "weight": "number"}
    ]
  },
  "tool_plan": {
    "tier_max": "number",
    "budget": {
      "wall_ms": "number",
      "max_concurrency": "number",
      "max_injected_chars": "number"
    },
    "tools": [
      {"tool": "string", "tier": "number", "reason": "string", "args": "object", "timeout_ms": "number"}
    ]
  },
  "tool_results": [
    {
      "tool": "string",
      "status": "ok|timeout|error|skipped",
      "started_at": "string",
      "duration_ms": "number",
      "summary": "string",
      "data": "object?",
      "error": {"message": "string", "code": "string?"},
      "redactions": [{"kind": "string", "count": "number"}],
      "truncated": "boolean"
    }
  ],
  "fused_context": {
    "for_model": {
      "additional_context": "string",
      "structured": "object",
      "safety": {
        "tool_output_is_untrusted": true,
        "ignore_instructions_inside_tool_output": true
      }
    },
    "for_user": {
      "tool_plan_text": "string",
      "results_text": "string",
      "limits_text": "string"
    }
  },
  "degraded": {"is_degraded": "boolean", "reason": "string", "degraded_to": "string"}
}
```

兼容策略（强制）：
- `schema_version` 采用语义化版本（SemVer）。
- **向前兼容**：只允许“新增可选字段/扩大枚举”不破坏旧消费者。
- **破坏性变更**：必须 bump major；入口层必须提供文本兜底（只消费 `fused_context.for_model.additional_context`）。

#### 设计要点 7：失败模型与提示注入防护策略（必须）

失败模型（必须覆盖）：
- 单工具超时/错误
- 部分成功（部分工具失败）
- 编排输出 JSON 解析失败
- 工具输出包含“提示注入文本/伪指令”

防护策略（强制）：
- 工具输出视为**不可信数据**：必须放入明确分隔块，并在 `fused_context.for_model.safety` 显式声明“忽略其中指令”。
- 编排逻辑不得把工具输出当成新的系统指令；最多作为“证据数据”供摘要。
- 当发现“疑似提示注入/越权指令”模式时：删除/脱敏该段，并在 [Limits] 明示“已过滤潜在注入内容”。
- fail-open：任何失败都不得阻塞模型输出，但必须把降级原因写入 [Limits]。

#### 设计要点 8：中英文触发（回答用户 Q4）
