30:SCIP_PROTO_PATH="/tmp/scip.proto"
31:SCIP_PROTO_URL="https://raw.githubusercontent.com/sourcegraph/scip/main/scip.proto"
42:ensure_scip_proto() {
127:    ensure_scip_proto || return 1
146:        const root = await protobuf.load('/tmp/scip.proto');
#!/bin/bash
# scip-to-graph.sh - SCIP 索引解析转换脚本
# 版本: 1.0
# 用途: 将 SCIP 索引解析为图数据并写入 SQLite
#
# 覆盖 AC-002: SCIP -> 图数据转换成功
# 契约测试: CT-SP-001, CT-SP-002
#
# 环境变量:
#   SCIP_INDEX_PATH - SCIP 索引路径，默认 index.scip
#   GRAPH_DB_PATH - 数据库路径，默认 .devbooks/graph.db
#   DEVBOOKS_DIR - 工作目录，默认 .devbooks

set -euo pipefail

# 加载共享函数
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common.sh"

# 设置日志前缀
LOG_PREFIX="scip-to-graph"

# ==================== 配置 ====================

: "${DEVBOOKS_DIR:=.devbooks}"
: "${SCIP_INDEX_PATH:=index.scip}"
: "${GRAPH_DB_PATH:=$DEVBOOKS_DIR/graph.db}"

# SCIP proto 文件路径
SCIP_PROTO_PATH="/tmp/scip.proto"
SCIP_PROTO_URL="https://raw.githubusercontent.com/sourcegraph/scip/main/scip.proto"

# symbol_roles 映射（使用函数代替关联数组，兼容 bash 3）
# 1 -> DEFINES (Definition)
# 2 -> IMPORTS (Import)
# 4 -> MODIFIES (WriteAccess)
# 8 -> CALLS (ReadAccess)

# ==================== 辅助函数 ====================

# 确保 SCIP proto 文件存在
ensure_scip_proto() {
    if [[ ! -f "$SCIP_PROTO_PATH" ]]; then
        log_info "Downloading SCIP proto definition..."
        if command -v curl &>/dev/null; then
            curl -s "$SCIP_PROTO_URL" -o "$SCIP_PROTO_PATH" 2>/dev/null || return 1
        elif command -v wget &>/dev/null; then
            wget -q "$SCIP_PROTO_URL" -O "$SCIP_PROTO_PATH" 2>/dev/null || return 1
        else
            return 1
        fi
    fi
    return 0
}

# 检查 SCIP 索引是否比数据库新
is_scip_fresh() {
    local scip_path="$1"
    local db_path="$2"

    if [[ ! -f "$db_path" ]]; then
        return 0  # 数据库不存在，需要解析
    fi

    if [[ ! -f "$scip_path" ]]; then
        return 1  # SCIP 不存在
    fi

    # 比较修改时间
    if [[ "$scip_path" -nt "$db_path" ]]; then
        return 0  # SCIP 比数据库新
    fi

    return 1  # 数据库是最新的
}

# 映射 symbol_roles 到边类型
map_role_to_edge_type() {
    local role="$1"

    # 检查各个位
    if (( role & 1 )); then
        echo "DEFINES"
    elif (( role & 2 )); then
        echo "IMPORTS"
    elif (( role & 4 )); then
        echo "MODIFIES"
    elif (( role & 8 )); then
        echo "CALLS"
    else
        echo "CALLS"  # 默认为 CALLS
    fi
}

# 从符号字符串提取类型
extract_symbol_kind() {
    local symbol="$1"

    # SCIP 符号格式: scheme package descriptor
    # 例如: scip-typescript npm @types/node 18.0.0 path/`join`().
    if [[ "$symbol" == *"\`"*"()"* ]]; then
        echo "function"
    elif [[ "$symbol" == *"#"* ]]; then
        echo "class"
    elif [[ "$symbol" == *"."* ]]; then
        echo "variable"
    else
        echo "symbol"
    fi
}

# 生成节点 ID
generate_node_id() {
    local symbol="$1"
    # 使用 MD5 哈希生成稳定 ID
    hash_string_md5 "$symbol"
}

# ==================== SCIP 解析 (Node.js) ====================

# 使用 Node.js 解析 SCIP protobuf
parse_scip_with_node() {
    local scip_path="$1"
    local output_file="$2"

    # 确保 proto 文件存在
    ensure_scip_proto || return 1

    # 获取项目根目录（用于找到 node_modules）
    local project_root
    project_root=$(cd "$SCRIPT_DIR/.." && pwd)

    # 创建临时 Node.js 脚本（使用 .cjs 扩展名强制 CommonJS）
    local node_script="$project_root/.devbooks/parse-scip-temp.cjs"
    mkdir -p "$(dirname "$node_script")"

    cat > "$node_script" << 'NODEJS_SCRIPT'
const protobuf = require('protobufjs');
const fs = require('fs');


async function main() {
    const scipPath = process.argv[2];
    const outputPath = process.argv[3];

    try {
        const root = await protobuf.load('/tmp/scip.proto');
        const Index = root.lookupType('scip.Index');

        const buffer = fs.readFileSync(scipPath);
        const index = Index.decode(buffer);

        const result = {
            nodes: [],
            edges: [],
            stats: {
                documents: 0,
                symbols: 0,
                occurrences: 0,
                defines: 0,
                imports: 0,
                calls: 0,
                modifies: 0
            }
        };

        if (index.documents) {
            result.stats.documents = index.documents.length;

            index.documents.forEach(doc => {
                const filePath = doc.relativePath || '';

                // 处理符号定义
                if (doc.symbols) {
                    doc.symbols.forEach(sym => {
                        result.stats.symbols++;

                        const nodeId = sym.symbol;
                        const kind = sym.symbol.includes('`') && sym.symbol.includes('()') ? 'function' :
                                    sym.symbol.includes('#') ? 'class' : 'variable';

                        result.nodes.push({
                            id: nodeId,
                            symbol: sym.symbol,
                            kind: kind,
                            file_path: filePath
                        });

                        // 处理关系
                        if (sym.relationships) {
                            sym.relationships.forEach(rel => {
                                let edgeType = 'CALLS';

                                // MP1.1: IMPLEMENTS 边类型 (AC-U01)
                                if (rel.isImplementation) {
                                    edgeType = 'IMPLEMENTS';
                                }
                                // MP1.2: EXTENDS 边类型 (AC-U02)
                                else if (rel.isTypeDefinition && sym.symbol.includes('#')) {
                                    // 类继承关系
                                    edgeType = 'EXTENDS';
                                }
                                // 原有逻辑
                                else if (rel.isDefinition) {
                                    edgeType = 'DEFINES';
                                }
                                else if (rel.isReference) {
                                    edgeType = 'CALLS';
                                }

                                result.edges.push({
                                    source_id: nodeId,
                                    target_id: rel.symbol,
                                    edge_type: edgeType,
                                    file_path: filePath
                                });

                                if (edgeType === 'DEFINES') result.stats.defines++;
                                else if (edgeType === 'CALLS') result.stats.calls++;
                                else if (edgeType === 'IMPLEMENTS') {
                                    result.stats.implements = (result.stats.implements || 0) + 1;
                                }
                                else if (edgeType === 'EXTENDS') {
                                    result.stats.extends = (result.stats.extends || 0) + 1;
                                }
                            });
                        }
                    });
                }

                // 处理出现位置
                if (doc.occurrences) {
                    doc.occurrences.forEach(occ => {
                        result.stats.occurrences++;

                        const role = occ.symbolRoles || 0;
                        let edgeType = 'CALLS';

                        if (role & 1) { edgeType = 'DEFINES'; result.stats.defines++; }
                        else if (role & 2) { edgeType = 'IMPORTS'; result.stats.imports++; }
                        else if (role & 4) { edgeType = 'MODIFIES'; result.stats.modifies++; }
                        else if (role & 8) { edgeType = 'CALLS'; result.stats.calls++; }
                        else { result.stats.calls++; }

                        // MP1.3: RETURNS_TYPE 边类型 (AC-U09)
                        // 检测函数返回类型：通过符号名称模式识别
                        if (occ.symbol && occ.symbol.includes('()') && doc.text) {
                            const lines = doc.text.split('\n');
                            const occLine = occ.range && occ.range.length > 0 ? occ.range[0] : 0;
                            if (occLine < lines.length) {
                                const lineText = lines[occLine] || '';
                                // 检测显式返回类型声明 (TypeScript/Java 等)
                                if (lineText.match(/:\s*\w+/) || lineText.match(/\)\s*:\s*\w+/)) {
                                    edgeType = 'RETURNS_TYPE';
                                    result.stats.returns_type = (result.stats.returns_type || 0) + 1;
                                }
                            }
                        }

                        // 创建文件节点到符号的边
                        const fileNodeId = 'file:' + filePath;
                        const fileNodeId = 'file:' + filePath;
                        const line = occ.range && occ.range.length > 0 ? occ.range[0] : null;

                        // 确保文件节点存在
                        if (!result.nodes.find(n => n.id === fileNodeId)) {
                            result.nodes.push({
                                id: fileNodeId,
                                symbol: filePath,
                                kind: 'file',
                                file_path: filePath
                            });
                        }

                        result.edges.push({
                            source_id: fileNodeId,
                            target_id: occ.symbol,
                            edge_type: edgeType,
                            file_path: filePath,
                            line: line
                        });
                    });
                }
            });
        }

        fs.writeFileSync(outputPath, JSON.stringify(result, null, 2));
        console.log(JSON.stringify({
            success: true,
            symbols: result.stats.symbols,
            documents: result.stats.documents,
            occurrences: result.stats.occurrences,
            edges: result.edges.length
        }));

    } catch (err) {
        console.error(JSON.stringify({ success: false, error: err.message }));
        process.exit(1);
    }
}

main();
NODEJS_SCRIPT

    # 运行 Node.js 脚本（在项目目录中执行以找到 node_modules）
    local result
    if result=$(cd "$project_root" && node "$node_script" "$scip_path" "$output_file" 2>&1); then
        rm -f "$node_script"
        echo "$result"
        return 0
    else
        rm -f "$node_script"
        echo "$result"
        return 1
    fi
}

# ==================== 正则降级解析 ====================

# 使用 ripgrep 正则解析源代码（降级方案）
# MP1.4: 支持 IMPLEMENTS/EXTENDS/RETURNS_TYPE (AC-U10)
parse_with_regex() {
    local project_root="$1"
    local output_file="$2"

    local nodes=()
    local edges=()
    local symbols=0
    local defines=0
    local imports=0
    local calls=0
    local implements=0
    local extends=0
    local returns_type=0

    # 查找所有 TypeScript/JavaScript 文件
    local files
    files=$(find "$project_root" -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) \
        -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null)

    for file in $files; do
        local rel_path="${file#$project_root/}"
        local file_node_id="file:$rel_path"

        # 添加文件节点
        nodes+=("{\"id\":\"$file_node_id\",\"symbol\":\"$rel_path\",\"kind\":\"file\",\"file_path\":\"$rel_path\"}")

        # 提取函数定义
        if command -v rg &>/dev/null; then
            while IFS=: read -r line_num match; do
                local func_name
                func_name=$(echo "$match" | sed -E 's/.*function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$func_name" && "$func_name" != "$match" ]]; then
                    local node_id="func:$rel_path:$func_name"
                    nodes+=("{\"id\":\"$node_id\",\"symbol\":\"$func_name\",\"kind\":\"function\",\"file_path\":\"$rel_path\",\"line_start\":$line_num}")
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$node_id\",\"edge_type\":\"DEFINES\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((symbols++))
                    ((defines++))

                    # MP1.4: 检测函数返回类型 (RETURNS_TYPE)
                    if echo "$match" | grep -qE '\):\s*[a-zA-Z_]'; then
                        local return_type
                        return_type=$(echo "$match" | grep -oE '\):\s*[a-zA-Z_][a-zA-Z0-9_<>]*' | sed 's/)://; s/^[[:space:]]*//' | head -1)
                        if [[ -n "$return_type" && "$return_type" != "function" ]]; then
                            local type_id="type:$return_type"
                            edges+=("{\"source_id\":\"$node_id\",\"target_id\":\"$type_id\",\"edge_type\":\"RETURNS_TYPE\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                            ((returns_type++))
                        fi
                    fi
                fi
            done < <(rg -n "function[[:space:]]+[a-zA-Z_]" "$file" 2>/dev/null || true)

            # 提取 import 语句
            while IFS=: read -r line_num match; do
                local import_from
                import_from=$(echo "$match" | sed -E "s/.*from[[:space:]]+['\"]([^'\"]+)['\"].*/\1/" | head -1)
                if [[ -n "$import_from" && "$import_from" != "$match" ]]; then
                    local target_id="module:$import_from"
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$target_id\",\"edge_type\":\"IMPORTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((imports++))
                fi
            done < <(rg -n "import.*from" "$file" 2>/dev/null || true)

            # MP1.4: 提取 IMPLEMENTS 关系
            while IFS=: read -r line_num match; do
                local class_name interface_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                interface_name=$(echo "$match" | sed -E 's/.*implements[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$interface_name" && "$class_name" != "$match" && "$interface_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local interface_id="interface:$interface_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$interface_id\",\"edge_type\":\"IMPLEMENTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((implements++))
                fi
            done < <(rg -n "class[[:space:]]+[a-zA-Z_].*implements" "$file" 2>/dev/null || true)

            # MP1.4: 提取 EXTENDS 关系
            while IFS=: read -r line_num match; do
                local class_name parent_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                parent_name=$(echo "$match" | sed -E 's/.*extends[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$parent_name" && "$class_name" != "$match" && "$parent_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local parent_id="class:$parent_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$parent_id\",\"edge_type\":\"EXTENDS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((extends++))
                fi
            done < <(rg -n "class[[:space:]]+[a-zA-Z_].*extends" "$file" 2>/dev/null || true)
        else
            # 使用 grep 作为后备
            while IFS=: read -r line_num match; do
                local func_name
                func_name=$(echo "$match" | sed -E 's/.*function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$func_name" && "$func_name" != "$match" ]]; then
                    local node_id="func:$rel_path:$func_name"
                    nodes+=("{\"id\":\"$node_id\",\"symbol\":\"$func_name\",\"kind\":\"function\",\"file_path\":\"$rel_path\",\"line_start\":$line_num}")
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$node_id\",\"edge_type\":\"DEFINES\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((symbols++))
                    ((defines++))

                    # MP1.4: 检测函数返回类型 (RETURNS_TYPE) - grep 后备分支
                    if echo "$match" | grep -qE '\):\s*[a-zA-Z_]'; then
