                        const fileNodeId = 'file:' + filePath;
                        const line = occ.range && occ.range.length > 0 ? occ.range[0] : null;

                        // 确保文件节点存在
                        if (!result.nodes.find(n => n.id === fileNodeId)) {
                            result.nodes.push({
                                id: fileNodeId,
                                symbol: filePath,
                                kind: 'file',
                                file_path: filePath
                            });
                        }

                        result.edges.push({
                            source_id: fileNodeId,
                            target_id: occ.symbol,
                            edge_type: edgeType,
                            file_path: filePath,
                            line: line
                        });
                    });
                }
            });
        }

        fs.writeFileSync(outputPath, JSON.stringify(result, null, 2));
        console.log(JSON.stringify({
            success: true,
            symbols: result.stats.symbols,
            documents: result.stats.documents,
            occurrences: result.stats.occurrences,
            edges: result.edges.length
        }));

    } catch (err) {
        console.error(JSON.stringify({ success: false, error: err.message }));
        process.exit(1);
    }
}

main();
NODEJS_SCRIPT

    # 运行 Node.js 脚本（在项目目录中执行以找到 node_modules）
    local result
    if result=$(cd "$project_root" && node "$node_script" "$scip_path" "$output_file" 2>&1); then
        rm -f "$node_script"
        echo "$result"
        return 0
    else
        rm -f "$node_script"
        echo "$result"
        return 1
    fi
}

# ==================== 正则降级解析 ====================

# 使用 ripgrep 正则解析源代码（降级方案）
# MP1.4: 支持 IMPLEMENTS/EXTENDS/RETURNS_TYPE (AC-U10)
parse_with_regex() {
    local project_root="$1"
    local output_file="$2"

    local nodes=()
    local edges=()
    local symbols=0
    local defines=0
    local imports=0
    local calls=0
    local implements=0
    local extends=0
    local returns_type=0

    # 查找所有 TypeScript/JavaScript 文件
    local files
    files=$(find "$project_root" -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) \
        -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null)

    for file in $files; do
        local rel_path="${file#$project_root/}"
        local file_node_id="file:$rel_path"

        # 添加文件节点
        nodes+=("{\"id\":\"$file_node_id\",\"symbol\":\"$rel_path\",\"kind\":\"file\",\"file_path\":\"$rel_path\"}")

        # 提取函数定义
        if command -v rg &>/dev/null; then
            while IFS=: read -r line_num match; do
                local func_name
                func_name=$(echo "$match" | sed -E 's/.*function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$func_name" && "$func_name" != "$match" ]]; then
                    local node_id="func:$rel_path:$func_name"
                    nodes+=("{\"id\":\"$node_id\",\"symbol\":\"$func_name\",\"kind\":\"function\",\"file_path\":\"$rel_path\",\"line_start\":$line_num}")
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$node_id\",\"edge_type\":\"DEFINES\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((symbols++))
                    ((defines++))

                    # MP1.4: 检测函数返回类型 (RETURNS_TYPE)
                    if echo "$match" | grep -qE '\):\s*[a-zA-Z_]'; then
                        local return_type
                        return_type=$(echo "$match" | grep -oE '\):\s*[a-zA-Z_][a-zA-Z0-9_<>]*' | sed 's/)://; s/^[[:space:]]*//' | head -1)
                        if [[ -n "$return_type" && "$return_type" != "function" ]]; then
                            local type_id="type:$return_type"
                            edges+=("{\"source_id\":\"$node_id\",\"target_id\":\"$type_id\",\"edge_type\":\"RETURNS_TYPE\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                            ((returns_type++))
                        fi
                    fi
                fi
            done < <(rg -n "function[[:space:]]+[a-zA-Z_]" "$file" 2>/dev/null || true)

            # 提取 import 语句
            while IFS=: read -r line_num match; do
                local import_from
                import_from=$(echo "$match" | sed -E "s/.*from[[:space:]]+['\"]([^'\"]+)['\"].*/\1/" | head -1)
                if [[ -n "$import_from" && "$import_from" != "$match" ]]; then
                    local target_id="module:$import_from"
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$target_id\",\"edge_type\":\"IMPORTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((imports++))
                fi
            done < <(rg -n "import.*from" "$file" 2>/dev/null || true)

            # MP1.4: 提取 IMPLEMENTS 关系
            while IFS=: read -r line_num match; do
                local class_name interface_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                interface_name=$(echo "$match" | sed -E 's/.*implements[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$interface_name" && "$class_name" != "$match" && "$interface_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local interface_id="interface:$interface_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$interface_id\",\"edge_type\":\"IMPLEMENTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((implements++))
                fi
            done < <(rg -n "class[[:space:]]+[a-zA-Z_].*implements" "$file" 2>/dev/null || true)

            # MP1.4: 提取 EXTENDS 关系
            while IFS=: read -r line_num match; do
                local class_name parent_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                parent_name=$(echo "$match" | sed -E 's/.*extends[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$parent_name" && "$class_name" != "$match" && "$parent_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local parent_id="class:$parent_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$parent_id\",\"edge_type\":\"EXTENDS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((extends++))
                fi
            done < <(rg -n "class[[:space:]]+[a-zA-Z_].*extends" "$file" 2>/dev/null || true)
        else
            # 使用 grep 作为后备
            while IFS=: read -r line_num match; do
                local func_name
                func_name=$(echo "$match" | sed -E 's/.*function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$func_name" && "$func_name" != "$match" ]]; then
                    local node_id="func:$rel_path:$func_name"
                    nodes+=("{\"id\":\"$node_id\",\"symbol\":\"$func_name\",\"kind\":\"function\",\"file_path\":\"$rel_path\",\"line_start\":$line_num}")
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$node_id\",\"edge_type\":\"DEFINES\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((symbols++))
                    ((defines++))

                    # MP1.4: 检测函数返回类型 (RETURNS_TYPE) - grep 后备分支
                    if echo "$match" | grep -qE '\):\s*[a-zA-Z_]'; then
                        local return_type
                        return_type=$(echo "$match" | grep -oE '\):\s*[a-zA-Z_][a-zA-Z0-9_<>]*' | sed 's/)://; s/^[[:space:]]*//' | head -1)
                        if [[ -n "$return_type" && "$return_type" != "function" ]]; then
                            local type_id="type:$return_type"
                            edges+=("{\"source_id\":\"$node_id\",\"target_id\":\"$type_id\",\"edge_type\":\"RETURNS_TYPE\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                            ((returns_type++))
                        fi
                    fi
                fi
            done < <(grep -n "function[[:space:]]*[a-zA-Z_]" "$file" 2>/dev/null || true)

            # 提取 import 语句 - grep 后备分支
            while IFS=: read -r line_num match; do
                local import_from
                import_from=$(echo "$match" | sed -E "s/.*from[[:space:]]+['\"]([^'\"]+)['\"].*/\1/" | head -1)
                if [[ -n "$import_from" && "$import_from" != "$match" ]]; then
                    local target_id="module:$import_from"
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$target_id\",\"edge_type\":\"IMPORTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((imports++))
                fi
            done < <(grep -n "import.*from" "$file" 2>/dev/null || true)

            # MP1.4: 提取 IMPLEMENTS 关系 - grep 后备分支
            while IFS=: read -r line_num match; do
                local class_name interface_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                interface_name=$(echo "$match" | sed -E 's/.*implements[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$interface_name" && "$class_name" != "$match" && "$interface_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local interface_id="interface:$interface_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$interface_id\",\"edge_type\":\"IMPLEMENTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((implements++))
                fi
            done < <(grep -n "class[[:space:]]*[a-zA-Z_].*implements" "$file" 2>/dev/null || true)

            # MP1.4: 提取 EXTENDS 关系 - grep 后备分支
            while IFS=: read -r line_num match; do
                local class_name parent_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                parent_name=$(echo "$match" | sed -E 's/.*extends[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$parent_name" && "$class_name" != "$match" && "$parent_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local parent_id="class:$parent_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$parent_id\",\"edge_type\":\"EXTENDS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((extends++))
                fi
            done < <(grep -n "class[[:space:]]*[a-zA-Z_].*extends" "$file" 2>/dev/null || true)
        fi
    done

    # 生成 JSON 输出
    local nodes_json
    local edges_json

    if [[ ${#nodes[@]} -gt 0 ]]; then
        nodes_json=$(printf '%s\n' "${nodes[@]}" | paste -sd ',' -)
    else
        nodes_json=""
    fi

    if [[ ${#edges[@]} -gt 0 ]]; then
        edges_json=$(printf '%s\n' "${edges[@]}" | paste -sd ',' -)
    else
        edges_json=""
    fi

    cat > "$output_file" << EOF
{
  "nodes": [${nodes_json}],
  "edges": [${edges_json}],
  "stats": {
    "symbols": $symbols,
    "defines": $defines,
    "imports": $imports,
    "calls": $calls,
    "implements": $implements,
    "extends": $extends,
    "returns_type": $returns_type
  }
}
EOF

    echo "{\"success\":true,\"symbols\":$symbols,\"confidence\":\"low\",\"source\":\"regex\"}"
}

# ==================== 命令: parse ====================

cmd_parse() {
    local incremental=false
    local force=false
    local format="text"
    local project_root="${PROJECT_ROOT:-$(pwd)}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --incremental) incremental=true; shift ;;
            --force) force=true; shift ;;
            --format) format="$2"; shift 2 ;;
            --project-root) project_root="$2"; shift 2 ;;
            *) shift ;;
