现在我已经收集了足够的信息，可以输出 Challenger 报告了。

---

# 提案质疑报告（Proposal Challenger）

**配置根目录**：
- `<truth-root>` = `dev-playbooks/specs`
- `<change-root>` = `dev-playbooks/changes`

**质疑对象**：`dev-playbooks/changes/20260123-1206-add-auto-tool-orchestrator/proposal.md`

---

## 1. 结论

**Revise**

**理由**：提案在架构设计与可验证性上已达到较高完整度，但存在 3 个阻断性缺口与 5 个遗漏项，必须修订后才能进入实施阶段。核心问题在于：现有 `context-inject-global.sh` 已包含 1545 行完整编排逻辑（含 40+ 函数），提案未明确"迁移 vs 重构 vs 包装"的具体策略，存在"双轨并存导致行为不一致"的高风险。

---

## 2. 阻断项（Blocking）

### B1. 现有编排逻辑迁移路径不明确（高风险）

**问题**：
- 当前 `hooks/context-inject-global.sh` 已实现完整编排能力（1545 行，40+ 函数），包含：
  - 意图分析：`analyze_intent_4d`、`map_intent_to_standard`、`get_recommended_tools`
  - 工具调用：`do_search`、`call_graph_rag`、`get_hotspots`、`get_file_complexity`
  - 结果融合：`build_structured_output`、`build_text_output`、`add_graph_context`
  - 安全约束：`get_security_constraints`、路径过滤、脱敏
- 提案在"设计要点 1.1"中列出了迁移清单，但未明确：
  1. 是"整体迁移"（把现有函数移入新脚本）还是"重构后迁移"（重写逻辑）？
  2. 迁移期间如何保证行为一致性（现有用户依赖当前行为）？
  3. 如何验证迁移后功能等价（需要哪些回归测试）？

**影响**：
- 若采用"重写"策略，存在引入新 bug 与行为不一致的风险
- 若采用"整体迁移"策略，新脚本会继承现有技术债务（1545 行单文件）
- 缺少迁移验证锚点，无法保证"迁移前后行为等价"

**必须修改**：
- 在 `proposal.md` 的"设计要点 1.1"中明确迁移策略（3 选 1）：
  1. **整体迁移**：把现有函数原样移入 `auto-tool-orchestrator.sh`，入口层仅保留 I/O 适配
  2. **重构迁移**：重写编排逻辑，但必须提供"行为等价验证"方案（如对比测试）
  3. **包装策略**：`auto-tool-orchestrator.sh` 作为薄层包装现有逻辑，逐步重构
- 补充迁移验证 AC：`AC-016: 迁移后行为等价验证`，要求对比迁移前后的输出（给定相同输入）

---

### B2. Tier-2 触发条件与 MVP 范围不自洽

**问题**：
- 提案在"设计要点 0"中声明"MVP 不实现'意图自动触发 Tier-2'"，但在"设计要点 3"的控制面中又保留了 `CI_AUTO_TOOLS=auto`（代码意图自动触发）
- 若 MVP 不支持"意图自动触发 Tier-2"，则 `CI_AUTO_TOOLS=auto` 的行为边界不清晰：
  - 代码意图是否会触发 Tier-1？（提案未明确）
  - 非代码意图是否输出空注入？（提案未明确）
- AC-009 要求"默认配置下 Tier-2 不进入 plan"，但未定义"代码意图 + Tier-2 工具需求"时的行为（是输出 [Limits] 提示还是静默跳过）

**影响**：
- MVP 交付后用户无法理解"为什么有些工具不自动调用"
- 测试无法覆盖"意图触发 Tier-2"的边界（因为 MVP 不实现该逻辑）

**必须修改**：
- 在"设计要点 0"中明确 MVP 的 `CI_AUTO_TOOLS=auto` 行为：
  - 代码意图 → 自动触发 Tier-0/1（不触发 Tier-2）
  - 非代码意图 → 输出空注入或仅注入项目画像
  - 代码意图需要 Tier-2 工具时 → 输出 [Limits] 提示（含启用方法）
- 补充 AC-009 的验证锚点：构造"代码意图 + 需要 Tier-2 工具"的样例，验证输出包含 [Limits] 提示

---

### B3. 参数裁剪"唯一执行点"的可验证性缺失

**问题**：
- 提案在"设计要点 4"中要求"参数裁剪在编排内核统一执行，入口层不允许绕过"，并在 AC-006 中要求验证"入口层直连调用被拒绝"
- 但提案未给出可执行的验证方式：
  - 如何在测试中"构造入口层直连调用"？（需要修改入口脚本才能触发，但这违反了"不修改入口脚本"的约束）
  - 如何在不修改代码的前提下验证"绕过检测"生效？
- 当前 `context-inject-global.sh` 已包含工具调用逻辑（`do_search`、`call_graph_rag` 等），若迁移后这些函数仍在入口层，则"唯一执行点"约束无法强制执行

**影响**：
- AC-006 的"绕过拒绝"验证无法编写（需要修改入口脚本才能触发，但这会破坏测试的非侵入性）
- 安全边界无法在 CI 中自动验证

**必须修改**：
- 在"设计要点 4"中补充可执行的验证方式（2 选 1）：
  1. **静态检查**：在 bats 中用 `grep` 检查入口层脚本不包含 `ci_*` 工具调用或 MCP 客户端调用
  2. **运行时检测**：编排内核在启动时检查调用栈，若发现入口层直连工具则拒绝并输出 [Limits]
- 修订 AC-006 的验证锚点为"静态检查 + 运行时检测"的组合

---

## 3. 遗漏项（Missing）

### M1. 缺少"迁移期间的兼容性策略"

**问题**：
- 提案未定义迁移期间（旧脚本 → 新脚本）的兼容性策略：
  - 是否支持"旧脚本与新脚本并存"（通过环境变量切换）？
  - 若用户在迁移期间遇到问题，如何快速回退到旧行为？
  - 是否需要"迁移检查清单"（验证新脚本功能完整性）？

**建议补充**：
- 在"设计要点 1.1"中补充"迁移期间兼容性策略"：
  - 提供 `CI_AUTO_TOOLS_LEGACY=1` 环境变量，强制使用旧脚本逻辑
  - 在新脚本交付后保留旧脚本 30 天（作为回退路径）
  - 提供迁移检查清单（对比旧脚本与新脚本的输出差异）

---

### M2. 缺少"Codex CLI wrapper 的安装验证"

**问题**：
- 提案在"设计要点 11"中定义了 Codex wrapper 的安装路径（`/usr/local/bin/codex-auto` 或 `<repo-root>/bin/codex-auto`），但未定义：
  - 安装后如何验证 wrapper 可用（需要哪些前置条件）？
  - 若 `~/.codex/config.toml` 未配置 MCP server，wrapper 应如何提示用户？
  - 若 `codex` 命令不在 PATH 中，wrapper 应如何降级？

**建议补充**：
- 在"设计要点 11"中补充"安装验证步骤"：
  - 验证命令：`codex-auto --dry-run "ping"` 输出包含 `schema_version` 且不触发 codex
  - 前置条件检查：wrapper 启动时检查 `codex` 命令可用性与 MCP server 配置
  - 降级提示：若前置条件不满足，输出清晰的安装指引（含 MCP server 配置示例）

---

### M3. 缺少"结果融合冲突判定的最小样例"

**问题**：
- 提案在"设计要点 9"中定义了冲突判定规则（同一 `claim_key` 且 `polarity` 对立），但未给出可执行的最小样例：
  - 如何构造"同一去重键 + 对立 polarity"的输入？
  - 冲突输出的 JSON 结构是什么（需要哪些字段）？
  - 如何在 bats 中验证冲突标记生效？

**建议补充**：
- 在"设计要点 9"中补充"冲突判定最小样例"：
  ```json
  // 输入：两个工具返回对立结论
  {
    "tool_results": [
      {
        "tool": "ci_search",
        "data": {
          "claim_key": "repo_root",
          "polarity": "support",
          "summary": "repo-root=/path/to/repo"
        }
      },
      {
        "tool": "ci_complexity",
        "data": {
          "claim_key": "repo_root",
          "polarity": "oppose",
          "summary": "repo-root=/different/path"
        }
      }
    ]
  }
  
  // 输出：冲突标记
  {
    "fused_context": {
      "for_user": {
        "results_text": "[Conflict] repo_root: 2 tools disagree (ci_search vs ci_complexity)"
      }
    }
  }
  ```
- 补充 AC-011 的验证锚点：构造上述样例并验证输出包含 `conflict=true`

---

### M4. 缺少"编排内核不可用时的降级路径"

**问题**：
- 提案在"设计要点 7.1"中定义了"编排不可用时输出空注入 JSON + exit code 10"，但未定义：
  - 空注入 JSON 的具体格式（需要哪些必填字段）？
  - 入口层如何判断"编排不可用"（脚本不存在 vs 不可执行 vs 执行失败）？
  - 空注入是否仍包含"项目画像"（如 repo-root、语言、索引状态）？

**建议补充**：
- 在"设计要点 7.1"中补充"空注入 JSON 格式"：
  ```json
  {
    "schema_version": "1.0",
    "run_id": "fallback-<timestamp>",
    "degraded": {
      "is_degraded": true,
      "reason": "orchestrator unavailable",
      "degraded_to": "empty"
    },
    "fused_context": {
      "for_model": {
        "additional_context": "[DevBooks] Auto-tools unavailable; fallback to manual mode"
      },
      "for_user": {
        "limits_text": "[Limits] orchestrator unavailable"
      }
    }
  }
  ```
- 补充 AC-008 的验证锚点：模拟"编排脚本不存在"并验证输出符合上述格式

---

### M5. 缺少"Tier-0/1/2 的成本与延迟预估"

**问题**：
- 提案在"设计要点 0"中定义了 Tier 分层，但未给出各 Tier 的成本与延迟预估：
  - Tier-0/1 的总延迟上限是多少（5000ms 是否包含并发）？
  - Tier-2 的额外成本是多少（+5000ms 是否足够）？
  - 若用户网络较慢或 MCP server 响应慢，如何保证不超时？

**建议补充**：
- 在"设计要点 5"中补充"成本与延迟预估表"：
  | Tier | 工具 | 预估延迟 | 并发策略 | 超时处理 |
  |------|------|----------|----------|----------|
  | 0 | ci_index_status | 500ms | 串行 | 超时跳过 |
  | 1 | ci_search + ci_graph_rag | 2000ms + 3500ms | 并发 | 超时降级 |
  | 2 | ci_call_chain + ci_impact | 3000ms + 2000ms | 并发 | 超时降级 |
- 补充 AC-007 的验证锚点：模拟"工具响应慢"并验证总延迟不超过预算

---

## 4. 非阻断项（Non-blocking）

### N1. `CI_CODEX_SESSION_MODE` 的默认值可能不适合所有场景

**问题**：
- 提案默认 `CI_CODEX_SESSION_MODE=resume_last`，但在某些场景下（如 CI/CD 环境、无状态容器）可能不适用
- 建议补充"场景推荐"：
  - 本地开发 → `resume_last`（保持会话连续性）
  - CI/CD → `exec`（无状态，避免会话污染）
  - 容器环境 → `exec`（避免会话文件丢失）

---

### N2. 结果融合的"去重键"可能不够精确

**问题**：
- 提案定义去重键为 `tool + normalized_path + normalized_symbol + normalized_title`，但未定义"normalized"的规则：
  - 路径是否需要转换为绝对路径（避免 `./src/foo.ts` 与 `src/foo.ts` 重复）？
  - 符号名是否需要去除命名空间（避免 `foo.bar` 与 `bar` 重复）？
- 建议在"设计要点 9"中补充"normalized 规则"

---

### N3. [Limits] 文本的国际化支持缺失

**问题**：
- 提案定义的 [Limits] 文本均为英文，但用户可能使用中文提示
- 建议补充"语言检测 + 本地化"策略：
  - 检测用户 prompt 语言（中文 vs 英文）
  - 输出对应语言的 [Limits] 文本

---

## 5. 替代方案

### 方案 A：渐进式迁移（推荐）

**策略**：
1. **阶段 1（MVP）**：`auto-tool-orchestrator.sh` 作为薄层包装现有 `context-inject-global.sh` 的编排逻辑
   - 入口层调用编排内核，编排内核委托给现有函数
   - 优势：快速交付，行为一致性有保障
2. **阶段 2（重构）**：逐步将编排逻辑从现有脚本迁移到编排内核
   - 每次迁移一个模块（如意图分析、工具调用、结果融合）
   - 每次迁移后运行回归测试（对比迁移前后输出）
3. **阶段 3（清理）**：移除现有脚本中的编排逻辑，仅保留 I/O 适配

**优势**：
- 降低迁移风险（每次迁移一个模块，可快速回退）
- 保证行为一致性（通过回归测试验证）
- 符合"同包分阶段"约束（不拆包）

---

### 方案 B：保持现有脚本，仅添加配置层（最小改动）

**策略**：
- 不新增 `auto-tool-orchestrator.sh`，而是在现有 `context-inject-global.sh` 中添加配置层（`config/auto-tools.yaml`）
- 优势：改动最小，风险最低
- 劣势：无法解决"入口层与编排内核耦合"的问题

---

## 6. 风险与证据缺口

### R1. 迁移后性能回归风险

**风险**：
- 新脚本可能引入性能回归（如额外的 JSON 解析、进程启动开销）
- 缺少性能基准测试（对比迁移前后的延迟）

**建议**：
- 补充 AC-017：性能基准测试
  - 给定相同输入，对比迁移前后的总延迟（不超过 +10%）
  - 验证并发策略生效（Tier-1 工具并发执行）

---

### R2. Codex CLI 会话连续性的可靠性未验证

**风险**：
- `codex exec resume --last` 的可靠性依赖 Codex CLI 的实现，但提案未验证：
  - 若 Codex CLI 版本不支持 `--last`，降级逻辑是否生效？
  - 若会话文件损坏，是否会导致 wrapper 崩溃？

**建议**：
- 补充 AC-018：Codex CLI 版本兼容性验证
  - 在不同 Codex CLI 版本下测试 wrapper（含不支持 `--last` 的旧版本）
  - 验证降级逻辑生效且不阻塞执行

---

### R3. 安全边界的回归测试缺失

**风险**：
- 提案定义了安全边界（白名单、参数裁剪、路径过滤、脱敏），但未定义回归测试策略：
  - 若未来新增工具，如何保证白名单更新？
  - 若未来修改参数裁剪规则，如何保证不引入安全漏洞？

**建议**：
- 补充 AC-019：安全边界回归测试
  - 在 bats 中维护"安全样例集"（含敏感路径、超限参数、提示注入文本）
  - 每次修改编排逻辑后运行安全样例集，验证边界不被破坏

---

## 总结

提案在架构设计与可验证性上已达到较高完整度，但存在 3 个阻断性缺口（迁移路径不明确、Tier-2 触发条件不自洽、参数裁剪可验证性缺失）与 5 个遗漏项（迁移兼容性、安装验证、冲突判定样例、降级路径、成本预估）。

**核心建议**：采用"渐进式迁移"策略（方案 A），先用薄层包装现有逻辑快速交付 MVP，再逐步重构，降低迁移风险并保证行为一致性。

**必须修改后才能 Approve。**
