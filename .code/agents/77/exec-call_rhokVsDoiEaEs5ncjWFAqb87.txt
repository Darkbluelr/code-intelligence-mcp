./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:60:{"batch_id":"2b843d18-dbc9-4ec7-aa83-48af606f20d4","completed_agents":["f4514721-7b1a-43fb-bc84-cefbdc6b7e3e"],"completed_summaries":[{"agent_id":"f4514721-7b1a-43fb-bc84-cefbdc6b7e3e","status":"completed","total_lines":707,"agent_result_hint":"agent {\"action\":\"result\",\"result\":{\"agent_id\":\"f4514721-7b1a-43fb-bc84-cefbdc6b7e3e\",\"batch_id\":\"2b843d18-dbc9-4ec7-aa83-48af606f20d4\"}}","agent_result_params":{"action":"result","result":{"agent_id":"f4514721-7b1a-43fb-bc84-cefbdc6b7e3e","batch_id":"2b843d18-dbc9-4ec7-aa83-48af606f20d4"}},"output_preview":"[2026-01-18T02:07:39] OpenAI Codex v0.0.0 (research preview)\n[2026-01-18T02:07:39] binary: /Users/ozbombor/.cli-versions/codex/just-every/node_modules/@just-every/code-darwin-arm64/bin/code-aarch64-apple-darwin\n--------\nworkdir: /Users/ozbombor/Projects/code-intelligence-mcp\nmodel: gpt-5.2\nprovider: crs\napproval: never\nsandbox: read-only\nreasoning effort: xhigh\nreasoning summaries: auto\n--------\n[2026-01-18T02:07:39] User instructions:\nContext: 项目根：/Users/ozbombor/Projects/code-intelligence-mcp；当前分支 master；环境 read-only + approval_policy=never。\n\nAgent: 按 devbooks-delivery-workflow 技能做“交付闭环现状盘点与阶段检测”（只读，不写文件）。要求：1) 先打开并遵守 /Users/ozbombor/Projects/code-intelligence-mcp/.codex/skills/devbooks-delivery-workflow/SKILL.md，按其规则执行；2) 按规则查找 .devbooks/config.yaml 或 dev-playbooks/project.md / project.md 以确定 truth-root 与 change-root；3) 检查变更包 /Users/ozbombor/Projects/code-intelligence-mcp/dev-playbooks/changes/optimize-indexingpipeline-20260117 的 proposal/design/tasks/verification/specs/evidence 状态，判断当前阶段与缺口；4) 输出：阶段检测报告 + 缺口清单 + 后续角色/skills 分工建议，并在输出中包含“模型选择要求：非代码任务用 gpt-5.2 xhigh，代码任务用 gpt-5.2-codex xhigh”。注意：只读，不能修改任何文件。\n\nDesired output: 中文报告：阶段检测报告 + 缺口清单 + 后续分工建议（含模型选择要求）\n\nFiles to consider: .codex/skills/devbooks-delivery-workflow/SKILL.md, dev-playbooks/changes/optimize-indexingpipeline-20260117\n\n[Running in read-only mode - no modifications allowed]\n\n[2026-01-18T02:07:48] thinking\n\n**Inspecting directory structure**\n\nI want to inspect the directory structure by running commands like `ls` or `fd`. Since I'm limited to read-only operations because of the policies in place, I can safely use `functions.shell` for commands that read. Running `git status` and `ls` are acceptable. It seems like a good plan to proceed step by step, starting by opening SKILL.md to understand the steps better, maybe using `sed -n '1,200p'` for that.\n[2026-01-18T02:07:51] exec sh -lc \"sed -n '1,200p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:07:51] sh -lc \"sed -n '1,200p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" succeeded in 31ms:\n---\nname: devbooks-delivery-workflow\ndescription: devbooks-delivery-workflow：把一次变更跑成可追溯闭环（Design→Plan→Trace→Verify→Implement→Archive），明确 DoD、追溯矩阵与角色隔离（Test Owner 与 Coder 分离）。用户说\"跑一遍闭环/交付验收/追溯矩阵/DoD/关账归档/验收工作流\"等时使用。\nallowed-tools:\n  - Glob\n  - Grep\n  - Read\n  - Write\n  - Edit\n  - Bash\n---\n\n# DevBooks：交付验收工作流（闭环骨架）\n\n## 前置：配置发现（协议无关）\n\n- `<truth-root>`：当前真理目录根\n- `<change-root>`：变更包目录根\n\n执行前**必须**按以下顺序查找配置（找到后停止）：\n[2026-01-18T02:07:51] tokens used: 13,330\n\n[2026-01-18T02:08:01] thinking\n\n**Proceeding with configuration checks**\n\nI'm planning to use either `rg` or `fd` for my file search. I've got read-only access, but it sounds like shell commands are allowed. Following the instructions, I need to check if the `.devbooks/config.yaml` file exists, which I can do using `ls` or `test -f`. I'll run a command to list the contents of the `.devbooks` and `dev-playbooks` directories. Let’s see what I find and proceed from there!\n[2026-01-18T02:08:03] exec sh -lc \"ls -ლა .devbooks 2>/dev/null || true; echo '---'; ls -la dev-playbooks 2>/dev/null || true\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:03] sh -lc \"ls -ლა .devbooks 2>/dev/null || true; echo '---'; ls -la dev-playbooks 2>/dev/null || true\" succeeded in 36ms:\n---\ntotal 88\ndrwxr-xr-x  11 ozbombor  staff    352 Jan 17 17:08 .\ndrwxr-xr-x@ 35 ozbombor  staff   1120 Jan 18 09:53 ..\n-rw-r--r--@  1 ozbombor  staff   6148 Jan 18 06:09 .DS_Store\n-rw-r--r--   1 ozbombor  staff  18874 Jan 13 21:11 README.md\ndrwxr-xr-x   3 ozbombor  staff     96 Jan 15 01:26 _meta\ndrwxr-xr-x   5 ozbombor  staff    160 Jan 18 08:09 changes\n-rw-r--r--   1 ozbombor  staff   2855 Jan 13 20:15 constitution.md\ndrwxr-xr-x   4 ozbombor  staff    128 Jan 17 01:29 docs\n-rw-r--r--   1 ozbombor  staff  11398 Jan 13 20:16 project.md\ndrwxr-xr-x   2 ozbombor  staff     64 Jan 13 19:19 scripts\ndrwxr-xr-x  57 ozbombor  staff   1824 Jan 18 05:51 specs\n[2026-01-18T02:08:03] tokens used: 16,447\n\n[2026-01-18T02:08:10] thinking\n\n**Reading project documentation**\n\nI see that my output started unusually with just a separator, which means nothing was produced. So, there’s no .devbooks/config.yaml available. Therefore, I need to move on to dev-playbooks/project.md. It’s important for me to read the relevant sections in that document to understand the truth-root and change-root mapping. Let’s explore those sections!\n[2026-01-18T02:08:12] exec sh -lc \"sed -n '1,200p' dev-playbooks/project.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:12] sh -lc \"sed -n '1,200p' dev-playbooks/project.md\" succeeded in 27ms:\n# 项目上下文\n\n## 目的\n\n为 AI 编程助手（如 Claude Code）提供代码智能能力的 MCP Server。通过语义搜索、调用链追踪、Bug 定位等功能，增强 AI 对代码库的理解和导航能力。\n\n## 技术栈\n\n- **运行时**：Node.js >= 18.0.0\n- **语言**：TypeScript 5.x（服务器薄壳）+ Bash（核心功能脚本）\n- **协议**：MCP (Model Context Protocol) via @modelcontextprotocol/sdk\n- **外部工具**：ripgrep (rg)、jq\n- **可选服务**：Ollama / OpenAI（Embedding）、CKB MCP Server（图分析）\n\n## 项目约定\n\n### 代码风格\n\n- **TypeScript**：严格模式（`strict: true`），ES 模块（`NodeNext`）\n- **Shell 脚本**：`set -euo pipefail`，ShellCheck 检查\n[2026-01-18T02:08:12] tokens used: 32,674\n\n[2026-01-18T02:08:27] thinking\n\n**Following script instructions**\n\nI need to follow the skill instructions, which suggest running scripts like `change-check.sh` and potentially `progress-dashboard.sh` or `guardrail-check.sh` for stage detection. While I can manually approximate stage detection and gaps, it's likely better to run the check script for completeness. The user is asking about inspecting the status of a change package, which is what the change-check script does. I'll take a look at the directory structure next.\n[2026-01-18T02:08:29] exec sh -lc 'ls -la dev-playbooks/changes/optimize-indexingpipeline-20260117' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:29] sh -lc 'ls -la dev-playbooks/changes/optimize-indexingpipeline-20260117' exited 1 in 27ms:\nERROR\nls: dev-playbooks/changes/optimize-indexingpipeline-20260117: No such file or directory\n[2026-01-18T02:08:29] tokens used: 36,525\n\n[2026-01-18T02:08:32] thinking\n\n**Considering directory path adjustments**\n\nI’m wondering if the directory path needs changing since the user mentioned \"optimize-indexingpipeline-20260117,\" but the naming convention typically expects a format that includes both date and time. It seems that they used just the date. Maybe there's a version of it with a prefix? I think it would be good to check the dev-playbooks/changes to see how everything aligns. Let's see what I can find there!\n[2026-01-18T02:08:35] exec sh -lc \"ls -la dev-playbooks/changes | sed -n '1,200p'\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:35] sh -lc \"ls -la dev-playbooks/changes | sed -n '1,200p'\" succeeded in 31ms:\ntotal 24\ndrwxr-xr-x   5 ozbombor  staff    160 Jan 18 08:09 .\ndrwxr-xr-x  11 ozbombor  staff    352 Jan 17 17:08 ..\n-rw-r--r--@  1 ozbombor  staff  10244 Jan 18 07:12 .DS_Store\ndrwxr-xr-x  11 ozbombor  staff    352 Jan 18 08:09 archive\ndrwxr-xr-x   3 ozbombor  staff     96 Jan 18 07:09 optimize-indexing-pipeline-20260117\n[2026-01-18T02:08:35] tokens used: 37,685\n\n[2026-01-18T02:08:46] thinking\n\n**Checking project compliance**\n\nI'm noticing that there might be different naming conventions in this project, but the skill states definitely must be followed. The folder might be older, and reporting it as non-compliant could be necessary since the user asked about a specific proposal and its status. We should check the 'optimize-indexing-pipeline-20260117' folder and list its contents. I remember finding the necessary directory roots in 'dev-playbooks/project.md', but I need to ensure I check the '.devbooks/config.yaml' too, as it wasn't listed before.\n**Verifying AGENTS.md requirement**\n\nI'm noticing that if the config specifies that the agents_doc must be read, I definitely need to check if the config exists—although I realize I haven't done that yet. The user instructions indicate that whenever there's a request mentioning planning or proposals, I should open `@/AGENTS.md`. In this case, they're referring to a change package with proposal elements, so it seems crucial to check AGENTS.md despite it not being directly linked to creating anything. Therefore, I should definitely access it at the project's root directory.\n**Opening AGENTS.md**\n\nI need to access AGENTS.md to follow the user instructions properly. It’s important for me to ensure that I’m only reading it and not making any modifications since I should keep everything read-only. So, I’ll proceed with opening AGENTS.md to check the necessary details while following the guidelines. It’s always good to be careful with file modifications, especially in this context! Let’s get this done.\n\n\n[2026-01-18T02:08:56] exec sh -lc \"ls -la AGENTS.md 2>/dev/null || true; echo '---'; rg -n \\\"\\\" AGENTS.md 2>/dev/null | head\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:56] sh -lc \"ls -la AGENTS.md 2>/dev/null || true; echo '---'; rg -n \\\"\\\" AGENTS.md 2>/dev/null | head\" succeeded in 42ms:\n-rw-r--r--  1 ozbombor  staff  793 Jan 14 19:04 AGENTS.md\n---\n1:<!-- DEVBOOKS:START -->\n2:# DevBooks 使用说明\n3:\n4:这些说明适用于 兼容 AGENTS.md 的 AI 工具。\n5:\n6:## 语言偏好\n7:\n8:**默认使用中文**：除非明确要求使用其他语言，否则所有输出都应使用中文，包括：\n9:- 文档内容\n10:- 代码注释\n[2026-01-18T02:08:56] tokens used: 42,900\n[2026-01-18T02:09:09] exec sh -lc \"sed -n '1,220p' AGENTS.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:09:09] sh -lc \"sed -n '1,220p' AGENTS.md\" succeeded in 28ms:\n<!-- DEVBOOKS:START -->\n# DevBooks 使用说明\n\n这些说明适用于 兼容 AGENTS.md 的 AI 工具。\n\n## 语言偏好\n\n**默认使用中文**：除非明确要求使用其他语言，否则所有输出都应使用中文，包括：\n- 文档内容\n- 代码注释\n- 提交信息\n- 规格说明\n\n## 工作流\n\n当请求满足以下条件时，始终打开 `@/AGENTS.md`：\n- 提及规划或提案（如 proposal、spec、change、plan 等词语）\n- 引入新功能、破坏性变更、架构变更或重大性能/安全工作\n- 请求不明确，需要在编码前了解权威规格\n\n[2026-01-18T02:09:09] tokens used: 43,945\n[2026-01-18T02:09:12] exec sh -lc 'ls -la dev-playbooks/changes/optimize-indexing-pipeline-20260117' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:09:12] sh -lc 'ls -la dev-playbooks/changes/optimize-indexing-pipeline-20260117' succeeded in 31ms:\ntotal 48\ndrwxr-xr-x  3 ozbombor  staff     96 Jan 18 07:09 .\ndrwxr-xr-x  5 ozbombor  staff    160 Jan 18 08:09 ..\n-rw-r--r--  1 ozbombor  staff  21479 Jan 18 09:11 proposal.md\n[2026-01-18T02:09:12] tokens used: 44,730\n[2026-01-18T02:09:15] exec sh -lc \"sed -n '1,260p' dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:09:15] sh -lc \"sed -n '1,260p' dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\" succeeded in 28ms:\n**<truth-root>**: `dev-playbooks/specs/`  **<change-root>**: `dev-playbooks/changes/`\n\n## Why（问题与目标）\n\n- Change-ID：`optimize-indexing-pipeline-20260117`\n- Status：`Approved`（已裁决）\n- 背景与证据（已阅读）：\n  - `scripts/indexer.sh` 当前实现为文件监听后触发全量生成 `index.scip`（无增量链路）\n  - `scripts/ast-delta.sh` 已实现单文件增量更新（tree-sitter → 更新 `graph.db`），但未被 `scripts/indexer.sh` 串联\n  - `scripts/scip-to-graph.sh` 在缺少本地文件时会下载 `scip.proto`（存在网络依赖，离线/受限网络下会断链）\n  - `src/server.ts` 的 `ci_index_status` 会把 `status/build/clear` 直接透传给 `scripts/indexer.sh`（当前脚本参数模型与该调用方式存在语义不匹配风险）\n- 核心问题（待解决）：\n  1) 文件变更触发“全量索引”导致延迟与资源浪费，降低上下文近实时性\n  2) 关键索引链路对网络有硬依赖，降低可用性与可复现性\n  3) “索引状态”工具与脚本职责边界不清，存在契约漂移风险\n- 目标（本变更包只聚焦 P0 链路打通）：\n  1) 打通“文件变更 →（优先）增量更新 `graph.db` →（必要时）回退全量重建”的闭环\n  2) `scripts/scip-to-graph.sh` 默认离线可运行（不依赖在线下载）\n  3) 明确 `ci_index_status` 的语义与脚本职责边界，避免继续漂移（见 Debate Packet）\n\n[2026-01-18T02:09:15] tokens used: 45,035\n\n[2026-01-18T02:09:32] thinking\n\n**Evaluating stage detection and scripts**\n\nI need to check for artifacts in specific directories like proposal.md, design.md, and others. Since we're in read-only mode, running writing scripts is off the table, but maybe some check scripts could still run without writing? `change-check.sh` is in the script directory; it might read results instead of writing, but I can't risk it. Approval policy prevents execution. Even with safe flags, I need to ensure they’re safe and see if I have permission to run them.\n**Analyzing read-only sandbox limitations**\n\nIn a read-only sandbox, shell commands are likely permitted, but they can only read files. Any attempt to write will fail. I can run commands like `ls`, `sed`, or `rg` that read data. However, running `bash scripts/change-check.sh` might try to create temporary files, potentially writing to /tmp, which could be outside the sandbox’s restrictions. The context suggests writes are generally prohibited, so I'll avoid executing scripts unless I’m sure they don’t write to the filesystem.\n**Determining script safety and workflow checks**\n\nEven if scripts write to stdout, they might use `mktemp` to create temporary files in /tmp, which could violate our restrictions. It’s best to avoid running scripts altogether and instead conduct manual checks on file existence. The environment prefers using scripts, but if they attempt to write, they could fail. I’ll check the scripts for `mktemp` use and consider a \"dry run.\" However, since the user wants to check change package statuses, I can proceed with verifying file existence and contents. I'll refer to SKILL.md for the workflow details.\n**Reading additional tasks in SKILL.md**\n\nI realize that I’ve only read the first 200 lines of SKILL.md, which might have more tasks that I need to be aware of. It’s important that I go through the rest of the document to ensure I’m fully informed about all the necessary steps and details in the workflow. I'll make sure to take my time and read that thoroughly to follow all the instructions correctly.\n\n\n\n[2026-01-18T02:09:44] exec sh -lc \"sed -n '200,520p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:09:44] sh -lc \"sed -n '200,520p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" succeeded in 32ms:\n```\n\n---\n\n## 上下文感知\n\n本 Skill 在执行前自动检测上下文，选择合适的工作流阶段。\n\n检测规则参考：`skills/_shared/context-detection-template.md`\n\n### 检测流程\n\n1. 检测变更包是否存在\n2. 检测当前阶段（proposal/apply/archive）\n3. 检测闸门状态\n\n### 本 Skill 支持的模式\n\n| 模式 | 触发条件 | 行为 |\n|------|----------|------|\n…truncated…\n**Evaluating command allowances and project stages**\n\nI’m considering the sandbox restrictions. While running shell commands may be allowed, any that attempt to write will fail. Our approach to running scripts could get tricky since they might write to build outputs or other files. The developer message highlights that in read-only mode, we need approval for non-read commands, and our policy is not to request any.\n\nSo, we’ll avoid potentially non-read commands. It looks like the project has only the proposal stage complete, but I want to confirm if there are any hidden directories for design, tasks, verification, and specs that may indicate progress. I'll also check gaps in content, especially regarding naming conventions and structural requirements.\n**Assessing project readiness and artifacts**\n\nSince there’s no design document, we aren’t ready to move to the apply stage. Our output will need to cover a few aspects:\n\nFirst, the **stage detection report** will summarize the current status, including truth-root, change-root, and any existing change packages. I’ll also note any naming or path mismatches.\n\nNext, for the **gap list**, I’ll list missing artifacts, unresolved decisions, open questions, and any gating issues.\n\nLastly, I’ll suggest next steps for roles and skills required, emphasizing that implementation could depend on resolving open questions in the design stage. I should also keep in mind the required environment restrictions since we’re in read-only mode.\n\n\n\n\n\n[2026-01-18T02:10:47] exec sh -lc 'find dev-playbooks/changes/optimize-indexing-pipeline-20260117 -maxdepth 2 -print' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:10:47] sh -lc 'find dev-playbooks/changes/optimize-indexing-pipeline-20260117 -maxdepth 2 -print' succeeded in 29ms:\ndev-playbooks/changes/optimize-indexing-pipeline-20260117\ndev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\n[2026-01-18T02:10:47] tokens used: 56,310\n[2026-01-18T02:10:50] exec sh -lc \"ls -la .codex/skills/devbooks-delivery-workflow/scripts | sed -n '1,200p'\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:10:50] sh -lc \"ls -la .codex/skills/devbooks-delivery-workflow/scripts | sed -n '1,200p'\" succeeded in 33ms:\ntotal 384\ndrwxr-xr-x  22 ozbombor  staff    704 Jan 17 01:25 .\ndrwxr-xr-x   6 ozbombor  staff    192 Jan 17 01:25 ..\n-rwxr-xr-x   1 ozbombor  staff   8531 Jan 17 01:25 ac-trace-check.sh\n-rwxr-xr-x   1 ozbombor  staff   6782 Jan 17 01:25 audit-scope.sh\n-rwxr-xr-x   1 ozbombor  staff  35525 Jan 17 01:25 change-check.sh\n-rwxr-xr-x   1 ozbombor  staff   2729 Jan 17 01:25 change-codemod-scaffold.sh\n-rwxr-xr-x   1 ozbombor  staff   2909 Jan 17 01:25 change-evidence.sh\n-rwxr-xr-x   1 ozbombor  staff  12104 Jan 17 01:25 change-scaffold.sh\n-rwxr-xr-x   1 ozbombor  staff   2671 Jan 17 01:25 change-spec-delta-scaffold.sh\n-rwxr-xr-x   1 ozbombor  staff   5882 Jan 17 01:25 constitution-check.sh\n-rwxr-xr-x   1 ozbombor  staff   3518 Jan 17 01:25 env-match-check.sh\n-rwxr-xr-x   1 ozbombor  staff  11209 Jan 17 01:25 fitness-check.sh\n-rwxr-xr-x   1 ozbombor  staff  16687 Jan 17 01:25 guardrail-check.sh\n-rwxr-xr-x   1 ozbombor  staff   3551 Jan 17 01:25 handoff-check.sh\n-rwxr-xr-x   1 ozbombor  staff   9438 Jan 17 01:25 hygiene-check.sh\n-rwxr-xr-x   1 ozbombor  staff   5506 Jan 17 01:25 migrate-to-v2-gates.sh\n-rwxr-xr-x   1 ozbombor  staff   9418 Jan 17 01:25 progress-dashboard.sh\n-rwxr-xr-x   1 ozbombor  staff  10788 Jan 17 01:25 prototype-promote.sh\n-rwxr-xr-x   1 ozbombor  staff   4965 Jan 17 01:25 spec-preview.sh\n[2026-01-18T02:10:50] tokens used: 56,772\n\n[2026-01-18T02:11:24] thinking\n\n**Analyzing proposal progress**\n\nThe proposal has an \"Approved\" status, indicating the decision stage is done, but the design phase isn't fully complete since design documents are missing. The next step is to create the design document using the devbooks-design-doc skill, although the user asked for the devbooks-delivery workflow. There’s potentially a naming mismatch in the change package, so I could suggest either keeping the current ID as legacy or creating a new one. I might also consider running a progress check with the dashboard script, but there’s uncertainty about its operations.\n**Inspecting change package structure**\n\nI plan to quickly check the change-check script to understand the expected structure of a change package, which typically includes files like proposal.md, design.md, tasks.md, and verification documents. While reading the script might take some time, I know I can look at skeleton templates and existing references for guidance. However, I need to summarize for the user: only the proposal exists right now, and the other necessary files are missing, including spec delta directories. I'll mention that proposal.md includes both truth-root and change-root, which is a positive note.\n**Preparing stage detection report**\n\nI need to create a stage detection report that includes several key elements. First, I'll present the config discovery results, mentioning the truth root, change root, and constitution. I should note that we confirmed config as authoritative, even after checking project.md. \n\nNext, regarding change package existence, the path the user provided doesn’t exist; the correct one is \"optimize-indexing-pipeline-20260117.\" I'll also address stage classification: the proposal stage is complete since proposal.md exists and is approved, but design, tasks, and verification are missing. Therefore, the stage is between Proposal and Design. I'll list the missing deliverables needed to move forward, such as design.md, tasks.md, and verification.md.\n**Checking for Decision Log**\n\nThe status is \"Approved,\" but I need to confirm if it includes a Decision Log. I might need to search the file for \"Decision Log\" since I was only able to see the top part, and it seems truncated due to size. To be thorough, I plan to run a command using `rg` to look for terms like \"Decision,\" \"裁决,\" \"Decision Log,\" \"Approved,\" \"Revise,\" and \"Rejected\" within the proposal.md. This should help me find relevant information quickly.\n\n\n\n[2026-01-18T02:11:37] exec sh -lc 'rg -n \"Decision Log|Decision|裁决|Approved|Revise|Rejected\" dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md | head -n 80' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:11:38] sh -lc 'rg -n \"Decision Log|Decision|裁决|Approved|Revise|Rejected\" dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md | head -n 80' succeeded in 47ms:\n6:- Status：`Approved`（已裁决）\n47:- MCP 行为：`ci_index_status` 的“语义归属”需要被裁决（否则后续实现无法保证兼容性）\n130:- [x] **接口契约变更**：`ci_index_status` 的真实语义需要裁决并对齐（否则属于隐式 breaking）\n230:   - 若不裁决 `ci_index_status` 的语义，后续实现可能“修复一边、破坏另一边”（见 DP-01）。\n268:**问题**：`src/server.ts` 当前将 `ci_index_status` 的 `status/build/clear` 直接调用 `scripts/indexer.sh`，但 `scripts/indexer.sh` 现有参数模型更像“SCIP 索引守护进程”。需要裁决：该 MCP 工具到底代表“Embedding 索引”还是“SCIP/图索引”？\n279:**已裁决：选项 A（见 Decision Log）**\n292:**已裁决：选项 A（见 Decision Log）**\n305:**已裁决：选项 B（见 Decision Log）**\n307:## Decision Log\n309:### 2026-01-18 裁决：Approved\n[2026-01-18T02:11:38] tokens used: 59,998\n[2026-01-18T02:11:40] exec sh -lc \"sed -n '250,380p' dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:11:40] sh -lc \"sed -n '250,380p' dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\" succeeded in 33ms:\n   - `scripts/indexer.sh --help/--status/--install/--uninstall` 行为保持可用。\n\n### 建议验证命令（实现后由执行者运行）\n\n- ShellCheck：`npm run lint`\n- 构建：`npm run build`\n- 脚本基本可用性：`./scripts/indexer.sh --help`、`./scripts/scip-to-graph.sh --help`\n- 离线验证（示例）：断网或限制网络后运行 `./scripts/scip-to-graph.sh parse --incremental`（需要本地已有 `index.scip` 与离线 proto 策略落地）\n\n### 证据落点（强制路径）\n\n- Red 基线：`dev-playbooks/changes/optimize-indexing-pipeline-20260117/evidence/red-baseline/`\n- Green 证据：`dev-playbooks/changes/optimize-indexing-pipeline-20260117/evidence/green-final/`\n\n## Debate Packet（争议点/不确定点/需要辩论的问题）\n\n#### DP-01：`ci_index_status` 的语义与 `scripts/indexer.sh` 的职责（需用户决策）\n\n**问题**：`src/server.ts` 当前将 `ci_index_status` 的 `status/build/clear` 直接调用 `scripts/indexer.sh`，但 `scripts/indexer.sh` 现有参数模型更像“SCIP 索引守护进程”。需要裁决：该 MCP 工具到底代表“Embedding 索引”还是“SCIP/图索引”？\n\n[2026-01-18T02:11:40] tokens used: 60,546\n[2026-01-18T02:11:43] exec sh -lc '.codex/skills/devbooks-delivery-workflow/scripts/change-check.sh optimize-indexing-pipeline-20260117 --mode proposal --role reviewer --project-root . --change-root dev-playbooks/changes --truth-root dev-playbooks/specs' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:11:43] sh -lc '.codex/skills/devbooks-delivery-workflow/scripts/change-check.sh optimize-indexing-pipeline-20260117 --mode proposal --role reviewer --project-root . --change-root dev-playbooks/changes --truth-root dev-playbooks/specs' exited 1 in 156ms:\ndevbooks: checking change 'optimize-indexing-pipeline-20260117' (mode=proposal, role=reviewer)\n  change-dir: ./dev-playbooks/changes/optimize-indexing-pipeline-20260117\n  truth-dir:  ./dev-playbooks/specs\n\nERROR\nwarn: proposal missing '- Value Signal and Observation:' (recommended): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\nwarn: proposal missing '- Value Stream Bottleneck Hypothesis...' (recommended): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\nerror: proposal missing decision line (e.g., '- Decision Status: Approved' or '- 决策状态： Approved'): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\nwarn: missing design.md (recommended for non-trivial changes): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/design.md\nerror: missing file: ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/tasks.md\nwarn: missing verification.md (expected during apply by test-owner): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/verification.md\ngit: warning: confstr() failed with code 5: couldn't get path of DARWIN_USER_TEMP_DIR; using /tmp instead\ngit: error: couldn't create cache file '/tmp/xcrun_db-v5XyCodK' (errno=Operation not permitted)\ngit: warning: confstr() failed with code 5: couldn't get path of DARWIN_USER_TEMP_DIR; using /tmp instead\ngit: error: couldn't create cache file '/tmp/xcrun_db-a6NS2mgJ' (errno=Operation not permitted)\ngit: warning: confstr() failed with code 5: couldn't get path of DARWIN_USER_TEMP_DIR; using /tmp instead\ngit: error: couldn't create cache file '/tmp/xcrun_db-5LhuSp8V' (errno=Operation not permitted)\ngit: warning: confstr() failed with code 5: couldn't get path of DARWIN_USER_TEMP_DIR; using /tmp instead\ngit: error: couldn't create cache file '/tmp/xcrun_db-50AFViCK' (errno=Operation not permitted)\nerror: Role violation: Reviewer cannot modify code files (AC-003)\n  Detected changes:\n    scripts/call-chain.sh\n    scripts/daemon.sh\n    scripts/graph-rag.sh\n    scripts/graph-store.sh\n[2026-01-18T02:11:43] tokens used: 62,487\n\n[2026-01-18T02:12:00] thinking\n\n**Analyzing task and role violations**\n\nI realize that check_tasks runs for all modes, and tasks.md might be needed even in the proposal stage. There seems to be an expectation for tasks in every workflow stage. The script flagged a Role violation because it detected changes in scripts/*.sh, which is interesting since we're not modifying, yet it checks the git diff in the working tree. It’s clear that the current worktree has modifications that could complicate role boundary gating.\n**Examining git and script errors**\n\nIt seems there might already be modifications in the change branch or locally, even though we're on the master branch. There could be unstaged changes. The script uses git diff to detect any changes but can't create caches because of permission issues with /tmp. This may be related to sandbox restrictions, as the script attempted to run git and create caches but failed. This could lead to incomplete detection and false results, although we still got the Role violation detection in the output.\n**Preparing the stage detection report**\n\nIt looks like the script successfully ran git diff, though the errors might come from git trying to locate xcrun, but I'm not totally sure. To create the stage detection report, I need to identify truth-root and change-root, confirm the change-id path, and check for any naming mismatches. \n\nI'll also look for required artifacts like proposal.md, which should have an Approved status and a Decision Log. We’re missing design.md, tasks.md, and other essential folders, suggesting we're still in the Proposal phase, with possible local changes that aren't confirmed as part of this change.\n**Verifying configuration and documents**\n\nI need to check that `.devbooks/config.yaml` includes both constitution.md and project.md, as well as the root dev-playbooks and paths. The config includes a constraint that requires the constitution to be true. Interestingly, the skill's precondition states that if agents_doc is specified in the config, I must read it, but it’s not specified here. However, since the project uses require_constitution true, I feel it’s important to also read constitution.md as part of the devbooks delivery workflow.\n**Reviewing change package and phase detection**\n\nAlthough not required by the skill, checking the constitution file might be relevant, especially for delivery workflow audits—it helps to verify the current stage. I need to ensure that the proposal and necessary specifications are present. I can note any missing sections, like absence of files or folders in the change package. The user asked about the proposal status for a specific change package, so I'll mention the naming convention issues with the change-ID and highlight any potential noncompliance. I’ll ensure to evaluate across workflow phases while being mindful of read-only constraints in the environment.\n\n\n\n\n[2026-01-18T02:12:33] exec sh -lc \"sed -n '1,220p' constitution.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:12:33] sh -lc \"sed -n '1,220p' constitution.md\" exited 1 in 25ms:\nERROR\nsed: constitution.md: No such file or directory\n[2026-01-18T02:12:33] tokens used: 65,889\n[2026-01-18T02:12:36] exec sh -lc \"sed -n '1,260p' dev-playbooks/constitution.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:12:36] sh -lc \"sed -n '1,260p' dev-playbooks/constitution.md\" succeeded in 26ms:\n# 项目宪法 (Project Constitution)\n\n> 本文档定义项目的不可违背原则（Global Inviolable Principles）。\n> 所有 AI 助手和开发者在执行任何操作前必须遵守这些原则。\n\n---\n\n## Part Zero: 强制指令\n\n**在执行任何 Skill 或操作之前，必须：**\n\n1. 阅读并理解本宪法文档\n2. 确认操作不违反任何 GIP 原则\n3. 如有冲突，立即停止并报告\n\n---\n\n## 全局不可违背原则 (Global Inviolable Principles)\n\n### GIP-01: 角色隔离原则\n[2026-01-18T02:12:36] tokens used: 66,875\n[2026-01-18T02:12:39] exec sh -lc \"git status --porcelain=v1 | sed -n '1,200p'\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:12:39] sh -lc \"git status --porcelain=v1 | sed -n '1,200p'\" succeeded in 41ms:\n M .gitignore\n M config/features.yaml\n M dev-playbooks/changes/archive/algorithm-optimization-parity/verification.md\n M dev-playbooks/specs/architecture/c4.md\n M dev-playbooks/specs/data-flow-tracing/spec.md\n…preview truncated to roughly 32768 bytes…\n…additional lines omitted…","output_file":"/Users/ozbombor/Projects/code-intelligence-mcp/.code/agents/f4514721-7b1a-43fb-bc84-cefbdc6b7e3e/result.txt"}],"wait_time_seconds":494}
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:72:{"agent_id":"f4514721-7b1a-43fb-bc84-cefbdc6b7e3e","batch_id":"2b843d18-dbc9-4ec7-aa83-48af606f20d4","status":"completed","output_preview":"[2026-01-18T02:07:39] OpenAI Codex v0.0.0 (research preview)\n[2026-01-18T02:07:39] binary: /Users/ozbombor/.cli-versions/codex/just-every/node_modules/@just-every/code-darwin-arm64/bin/code-aarch64-apple-darwin\n--------\nworkdir: /Users/ozbombor/Projects/code-intelligence-mcp\nmodel: gpt-5.2\nprovider: crs\napproval: never\nsandbox: read-only\nreasoning effort: xhigh\nreasoning summaries: auto\n--------\n[2026-01-18T02:07:39] User instructions:\nContext: 项目根：/Users/ozbombor/Projects/code-intelligence-mcp；当前分支 master；环境 read-only + approval_policy=never。\n\nAgent: 按 devbooks-delivery-workflow 技能做“交付闭环现状盘点与阶段检测”（只读，不写文件）。要求：1) 先打开并遵守 /Users/ozbombor/Projects/code-intelligence-mcp/.codex/skills/devbooks-delivery-workflow/SKILL.md，按其规则执行；2) 按规则查找 .devbooks/config.yaml 或 dev-playbooks/project.md / project.md 以确定 truth-root 与 change-root；3) 检查变更包 /Users/ozbombor/Projects/code-intelligence-mcp/dev-playbooks/changes/optimize-indexingpipeline-20260117 的 proposal/design/tasks/verification/specs/evidence 状态，判断当前阶段与缺口；4) 输出：阶段检测报告 + 缺口清单 + 后续角色/skills 分工建议，并在输出中包含“模型选择要求：非代码任务用 gpt-5.2 xhigh，代码任务用 gpt-5.2-codex xhigh”。注意：只读，不能修改任何文件。\n\nDesired output: 中文报告：阶段检测报告 + 缺口清单 + 后续分工建议（含模型选择要求）\n\nFiles to consider: .codex/skills/devbooks-delivery-workflow/SKILL.md, dev-playbooks/changes/optimize-indexingpipeline-20260117\n\n[Running in read-only mode - no modifications allowed]\n\n[2026-01-18T02:07:48] thinking\n\n**Inspecting directory structure**\n\nI want to inspect the directory structure by running commands like `ls` or `fd`. Since I'm limited to read-only operations because of the policies in place, I can safely use `functions.shell` for commands that read. Running `git status` and `ls` are acceptable. It seems like a good plan to proceed step by step, starting by opening SKILL.md to understand the steps better, maybe using `sed -n '1,200p'` for that.\n[2026-01-18T02:07:51] exec sh -lc \"sed -n '1,200p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:07:51] sh -lc \"sed -n '1,200p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" succeeded in 31ms:\n---\nname: devbooks-delivery-workflow\ndescription: devbooks-delivery-workflow：把一次变更跑成可追溯闭环（Design→Plan→Trace→Verify→Implement→Archive），明确 DoD、追溯矩阵与角色隔离（Test Owner 与 Coder 分离）。用户说\"跑一遍闭环/交付验收/追溯矩阵/DoD/关账归档/验收工作流\"等时使用。\nallowed-tools:\n  - Glob\n  - Grep\n  - Read\n  - Write\n  - Edit\n  - Bash\n---\n\n# DevBooks：交付验收工作流（闭环骨架）\n\n## 前置：配置发现（协议无关）\n\n- `<truth-root>`：当前真理目录根\n- `<change-root>`：变更包目录根\n\n执行前**必须**按以下顺序查找配置（找到后停止）：\n[2026-01-18T02:07:51] tokens used: 13,330\n\n[2026-01-18T02:08:01] thinking\n\n**Proceeding with configuration checks**\n\nI'm planning to use either `rg` or `fd` for my file search. I've got read-only access, but it sounds like shell commands are allowed. Following the instructions, I need to check if the `.devbooks/config.yaml` file exists, which I can do using `ls` or `test -f`. I'll run a command to list the contents of the `.devbooks` and `dev-playbooks` directories. Let’s see what I find and proceed from there!\n[2026-01-18T02:08:03] exec sh -lc \"ls -ლა .devbooks 2>/dev/null || true; echo '---'; ls -la dev-playbooks 2>/dev/null || true\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:03] sh -lc \"ls -ლა .devbooks 2>/dev/null || true; echo '---'; ls -la dev-playbooks 2>/dev/null || true\" succeeded in 36ms:\n---\ntotal 88\ndrwxr-xr-x  11 ozbombor  staff    352 Jan 17 17:08 .\ndrwxr-xr-x@ 35 ozbombor  staff   1120 Jan 18 09:53 ..\n-rw-r--r--@  1 ozbombor  staff   6148 Jan 18 06:09 .DS_Store\n-rw-r--r--   1 ozbombor  staff  18874 Jan 13 21:11 README.md\ndrwxr-xr-x   3 ozbombor  staff     96 Jan 15 01:26 _meta\ndrwxr-xr-x   5 ozbombor  staff    160 Jan 18 08:09 changes\n-rw-r--r--   1 ozbombor  staff   2855 Jan 13 20:15 constitution.md\ndrwxr-xr-x   4 ozbombor  staff    128 Jan 17 01:29 docs\n-rw-r--r--   1 ozbombor  staff  11398 Jan 13 20:16 project.md\ndrwxr-xr-x   2 ozbombor  staff     64 Jan 13 19:19 scripts\ndrwxr-xr-x  57 ozbombor  staff   1824 Jan 18 05:51 specs\n[2026-01-18T02:08:03] tokens used: 16,447\n\n[2026-01-18T02:08:10] thinking\n\n**Reading project documentation**\n\nI see that my output started unusually with just a separator, which means nothing was produced. So, there’s no .devbooks/config.yaml available. Therefore, I need to move on to dev-playbooks/project.md. It’s important for me to read the relevant sections in that document to understand the truth-root and change-root mapping. Let’s explore those sections!\n[2026-01-18T02:08:12] exec sh -lc \"sed -n '1,200p' dev-playbooks/project.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:12] sh -lc \"sed -n '1,200p' dev-playbooks/project.md\" succeeded in 27ms:\n# 项目上下文\n\n## 目的\n\n为 AI 编程助手（如 Claude Code）提供代码智能能力的 MCP Server。通过语义搜索、调用链追踪、Bug 定位等功能，增强 AI 对代码库的理解和导航能力。\n\n## 技术栈\n\n- **运行时**：Node.js >= 18.0.0\n- **语言**：TypeScript 5.x（服务器薄壳）+ Bash（核心功能脚本）\n- **协议**：MCP (Model Context Protocol) via @modelcontextprotocol/sdk\n- **外部工具**：ripgrep (rg)、jq\n- **可选服务**：Ollama / OpenAI（Embedding）、CKB MCP Server（图分析）\n\n## 项目约定\n\n### 代码风格\n\n- **TypeScript**：严格模式（`strict: true`），ES 模块（`NodeNext`）\n- **Shell 脚本**：`set -euo pipefail`，ShellCheck 检查\n[2026-01-18T02:08:12] tokens used: 32,674\n\n[2026-01-18T02:08:27] thinking\n\n**Following script instructions**\n\nI need to follow the skill instructions, which suggest running scripts like `change-check.sh` and potentially `progress-dashboard.sh` or `guardrail-check.sh` for stage detection. While I can manually approximate stage detection and gaps, it's likely better to run the check script for completeness. The user is asking about inspecting the status of a change package, which is what the change-check script does. I'll take a look at the directory structure next.\n[2026-01-18T02:08:29] exec sh -lc 'ls -la dev-playbooks/changes/optimize-indexingpipeline-20260117' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:29] sh -lc 'ls -la dev-playbooks/changes/optimize-indexingpipeline-20260117' exited 1 in 27ms:\nERROR\nls: dev-playbooks/changes/optimize-indexingpipeline-20260117: No such file or directory\n[2026-01-18T02:08:29] tokens used: 36,525\n\n[2026-01-18T02:08:32] thinking\n\n**Considering directory path adjustments**\n\nI’m wondering if the directory path needs changing since the user mentioned \"optimize-indexingpipeline-20260117,\" but the naming convention typically expects a format that includes both date and time. It seems that they used just the date. Maybe there's a version of it with a prefix? I think it would be good to check the dev-playbooks/changes to see how everything aligns. Let's see what I can find there!\n[2026-01-18T02:08:35] exec sh -lc \"ls -la dev-playbooks/changes | sed -n '1,200p'\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:35] sh -lc \"ls -la dev-playbooks/changes | sed -n '1,200p'\" succeeded in 31ms:\ntotal 24\ndrwxr-xr-x   5 ozbombor  staff    160 Jan 18 08:09 .\ndrwxr-xr-x  11 ozbombor  staff    352 Jan 17 17:08 ..\n-rw-r--r--@  1 ozbombor  staff  10244 Jan 18 07:12 .DS_Store\ndrwxr-xr-x  11 ozbombor  staff    352 Jan 18 08:09 archive\ndrwxr-xr-x   3 ozbombor  staff     96 Jan 18 07:09 optimize-indexing-pipeline-20260117\n[2026-01-18T02:08:35] tokens used: 37,685\n\n[2026-01-18T02:08:46] thinking\n\n**Checking project compliance**\n\nI'm noticing that there might be different naming conventions in this project, but the skill states definitely must be followed. The folder might be older, and reporting it as non-compliant could be necessary since the user asked about a specific proposal and its status. We should check the 'optimize-indexing-pipeline-20260117' folder and list its contents. I remember finding the necessary directory roots in 'dev-playbooks/project.md', but I need to ensure I check the '.devbooks/config.yaml' too, as it wasn't listed before.\n**Verifying AGENTS.md requirement**\n\nI'm noticing that if the config specifies that the agents_doc must be read, I definitely need to check if the config exists—although I realize I haven't done that yet. The user instructions indicate that whenever there's a request mentioning planning or proposals, I should open `@/AGENTS.md`. In this case, they're referring to a change package with proposal elements, so it seems crucial to check AGENTS.md despite it not being directly linked to creating anything. Therefore, I should definitely access it at the project's root directory.\n**Opening AGENTS.md**\n\nI need to access AGENTS.md to follow the user instructions properly. It’s important for me to ensure that I’m only reading it and not making any modifications since I should keep everything read-only. So, I’ll proceed with opening AGENTS.md to check the necessary details while following the guidelines. It’s always good to be careful with file modifications, especially in this context! Let’s get this done.\n\n\n[2026-01-18T02:08:56] exec sh -lc \"ls -la AGENTS.md 2>/dev/null || true; echo '---'; rg -n \\\"\\\" AGENTS.md 2>/dev/null | head\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:08:56] sh -lc \"ls -la AGENTS.md 2>/dev/null || true; echo '---'; rg -n \\\"\\\" AGENTS.md 2>/dev/null | head\" succeeded in 42ms:\n-rw-r--r--  1 ozbombor  staff  793 Jan 14 19:04 AGENTS.md\n---\n1:<!-- DEVBOOKS:START -->\n2:# DevBooks 使用说明\n3:\n4:这些说明适用于 兼容 AGENTS.md 的 AI 工具。\n5:\n6:## 语言偏好\n7:\n8:**默认使用中文**：除非明确要求使用其他语言，否则所有输出都应使用中文，包括：\n9:- 文档内容\n10:- 代码注释\n[2026-01-18T02:08:56] tokens used: 42,900\n[2026-01-18T02:09:09] exec sh -lc \"sed -n '1,220p' AGENTS.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:09:09] sh -lc \"sed -n '1,220p' AGENTS.md\" succeeded in 28ms:\n<!-- DEVBOOKS:START -->\n# DevBooks 使用说明\n\n这些说明适用于 兼容 AGENTS.md 的 AI 工具。\n\n## 语言偏好\n\n**默认使用中文**：除非明确要求使用其他语言，否则所有输出都应使用中文，包括：\n- 文档内容\n- 代码注释\n- 提交信息\n- 规格说明\n\n## 工作流\n\n当请求满足以下条件时，始终打开 `@/AGENTS.md`：\n- 提及规划或提案（如 proposal、spec、change、plan 等词语）\n- 引入新功能、破坏性变更、架构变更或重大性能/安全工作\n- 请求不明确，需要在编码前了解权威规格\n\n[2026-01-18T02:09:09] tokens used: 43,945\n[2026-01-18T02:09:12] exec sh -lc 'ls -la dev-playbooks/changes/optimize-indexing-pipeline-20260117' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:09:12] sh -lc 'ls -la dev-playbooks/changes/optimize-indexing-pipeline-20260117' succeeded in 31ms:\ntotal 48\ndrwxr-xr-x  3 ozbombor  staff     96 Jan 18 07:09 .\ndrwxr-xr-x  5 ozbombor  staff    160 Jan 18 08:09 ..\n-rw-r--r--  1 ozbombor  staff  21479 Jan 18 09:11 proposal.md\n[2026-01-18T02:09:12] tokens used: 44,730\n[2026-01-18T02:09:15] exec sh -lc \"sed -n '1,260p' dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:09:15] sh -lc \"sed -n '1,260p' dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\" succeeded in 28ms:\n**<truth-root>**: `dev-playbooks/specs/`  **<change-root>**: `dev-playbooks/changes/`\n\n## Why（问题与目标）\n\n- Change-ID：`optimize-indexing-pipeline-20260117`\n- Status：`Approved`（已裁决）\n- 背景与证据（已阅读）：\n  - `scripts/indexer.sh` 当前实现为文件监听后触发全量生成 `index.scip`（无增量链路）\n  - `scripts/ast-delta.sh` 已实现单文件增量更新（tree-sitter → 更新 `graph.db`），但未被 `scripts/indexer.sh` 串联\n  - `scripts/scip-to-graph.sh` 在缺少本地文件时会下载 `scip.proto`（存在网络依赖，离线/受限网络下会断链）\n  - `src/server.ts` 的 `ci_index_status` 会把 `status/build/clear` 直接透传给 `scripts/indexer.sh`（当前脚本参数模型与该调用方式存在语义不匹配风险）\n- 核心问题（待解决）：\n  1) 文件变更触发“全量索引”导致延迟与资源浪费，降低上下文近实时性\n  2) 关键索引链路对网络有硬依赖，降低可用性与可复现性\n  3) “索引状态”工具与脚本职责边界不清，存在契约漂移风险\n- 目标（本变更包只聚焦 P0 链路打通）：\n  1) 打通“文件变更 →（优先）增量更新 `graph.db` →（必要时）回退全量重建”的闭环\n  2) `scripts/scip-to-graph.sh` 默认离线可运行（不依赖在线下载）\n  3) 明确 `ci_index_status` 的语义与脚本职责边界，避免继续漂移（见 Debate Packet）\n\n[2026-01-18T02:09:15] tokens used: 45,035\n\n[2026-01-18T02:09:32] thinking\n\n**Evaluating stage detection and scripts**\n\nI need to check for artifacts in specific directories like proposal.md, design.md, and others. Since we're in read-only mode, running writing scripts is off the table, but maybe some check scripts could still run without writing? `change-check.sh` is in the script directory; it might read results instead of writing, but I can't risk it. Approval policy prevents execution. Even with safe flags, I need to ensure they’re safe and see if I have permission to run them.\n**Analyzing read-only sandbox limitations**\n\nIn a read-only sandbox, shell commands are likely permitted, but they can only read files. Any attempt to write will fail. I can run commands like `ls`, `sed`, or `rg` that read data. However, running `bash scripts/change-check.sh` might try to create temporary files, potentially writing to /tmp, which could be outside the sandbox’s restrictions. The context suggests writes are generally prohibited, so I'll avoid executing scripts unless I’m sure they don’t write to the filesystem.\n**Determining script safety and workflow checks**\n\nEven if scripts write to stdout, they might use `mktemp` to create temporary files in /tmp, which could violate our restrictions. It’s best to avoid running scripts altogether and instead conduct manual checks on file existence. The environment prefers using scripts, but if they attempt to write, they could fail. I’ll check the scripts for `mktemp` use and consider a \"dry run.\" However, since the user wants to check change package statuses, I can proceed with verifying file existence and contents. I'll refer to SKILL.md for the workflow details.\n**Reading additional tasks in SKILL.md**\n\nI realize that I’ve only read the first 200 lines of SKILL.md, which might have more tasks that I need to be aware of. It’s important that I go through the rest of the document to ensure I’m fully informed about all the necessary steps and details in the workflow. I'll make sure to take my time and read that thoroughly to follow all the instructions correctly.\n\n\n\n[2026-01-18T02:09:44] exec sh -lc \"sed -n '200,520p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:09:44] sh -lc \"sed -n '200,520p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" succeeded in 32ms:\n```\n\n---\n\n## 上下文感知\n\n本 Skill 在执行前自动检测上下文，选择合适的工作流阶段。\n\n检测规则参考：`skills/_shared/context-detection-template.md`\n\n### 检测流程\n\n1. 检测变更包是否存在\n2. 检测当前阶段（proposal/apply/archive）\n3. 检测闸门状态\n\n### 本 Skill 支持的模式\n\n| 模式 | 触发条件 | 行为 |\n|------|----------|------|\n…truncated…\n**Evaluating command allowances and project stages**\n\nI’m considering the sandbox restrictions. While running shell commands may be allowed, any that attempt to write will fail. Our approach to running scripts could get tricky since they might write to build outputs or other files. The developer message highlights that in read-only mode, we need approval for non-read commands, and our policy is not to request any.\n\nSo, we’ll avoid potentially non-read commands. It looks like the project has only the proposal stage complete, but I want to confirm if there are any hidden directories for design, tasks, verification, and specs that may indicate progress. I'll also check gaps in content, especially regarding naming conventions and structural requirements.\n**Assessing project readiness and artifacts**\n\nSince there’s no design document, we aren’t ready to move to the apply stage. Our output will need to cover a few aspects:\n\nFirst, the **stage detection report** will summarize the current status, including truth-root, change-root, and any existing change packages. I’ll also note any naming or path mismatches.\n\nNext, for the **gap list**, I’ll list missing artifacts, unresolved decisions, open questions, and any gating issues.\n\nLastly, I’ll suggest next steps for roles and skills required, emphasizing that implementation could depend on resolving open questions in the design stage. I should also keep in mind the required environment restrictions since we’re in read-only mode.\n\n\n\n\n\n[2026-01-18T02:10:47] exec sh -lc 'find dev-playbooks/changes/optimize-indexing-pipeline-20260117 -maxdepth 2 -print' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:10:47] sh -lc 'find dev-playbooks/changes/optimize-indexing-pipeline-20260117 -maxdepth 2 -print' succeeded in 29ms:\ndev-playbooks/changes/optimize-indexing-pipeline-20260117\ndev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\n[2026-01-18T02:10:47] tokens used: 56,310\n[2026-01-18T02:10:50] exec sh -lc \"ls -la .codex/skills/devbooks-delivery-workflow/scripts | sed -n '1,200p'\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:10:50] sh -lc \"ls -la .codex/skills/devbooks-delivery-workflow/scripts | sed -n '1,200p'\" succeeded in 33ms:\ntotal 384\ndrwxr-xr-x  22 ozbombor  staff    704 Jan 17 01:25 .\ndrwxr-xr-x   6 ozbombor  staff    192 Jan 17 01:25 ..\n-rwxr-xr-x   1 ozbombor  staff   8531 Jan 17 01:25 ac-trace-check.sh\n-rwxr-xr-x   1 ozbombor  staff   6782 Jan 17 01:25 audit-scope.sh\n-rwxr-xr-x   1 ozbombor  staff  35525 Jan 17 01:25 change-check.sh\n-rwxr-xr-x   1 ozbombor  staff   2729 Jan 17 01:25 change-codemod-scaffold.sh\n-rwxr-xr-x   1 ozbombor  staff   2909 Jan 17 01:25 change-evidence.sh\n-rwxr-xr-x   1 ozbombor  staff  12104 Jan 17 01:25 change-scaffold.sh\n-rwxr-xr-x   1 ozbombor  staff   2671 Jan 17 01:25 change-spec-delta-scaffold.sh\n-rwxr-xr-x   1 ozbombor  staff   5882 Jan 17 01:25 constitution-check.sh\n-rwxr-xr-x   1 ozbombor  staff   3518 Jan 17 01:25 env-match-check.sh\n-rwxr-xr-x   1 ozbombor  staff  11209 Jan 17 01:25 fitness-check.sh\n-rwxr-xr-x   1 ozbombor  staff  16687 Jan 17 01:25 guardrail-check.sh\n-rwxr-xr-x   1 ozbombor  staff   3551 Jan 17 01:25 handoff-check.sh\n-rwxr-xr-x   1 ozbombor  staff   9438 Jan 17 01:25 hygiene-check.sh\n-rwxr-xr-x   1 ozbombor  staff   5506 Jan 17 01:25 migrate-to-v2-gates.sh\n-rwxr-xr-x   1 ozbombor  staff   9418 Jan 17 01:25 progress-dashboard.sh\n-rwxr-xr-x   1 ozbombor  staff  10788 Jan 17 01:25 prototype-promote.sh\n-rwxr-xr-x   1 ozbombor  staff   4965 Jan 17 01:25 spec-preview.sh\n[2026-01-18T02:10:50] tokens used: 56,772\n\n[2026-01-18T02:11:24] thinking\n\n**Analyzing proposal progress**\n\nThe proposal has an \"Approved\" status, indicating the decision stage is done, but the design phase isn't fully complete since design documents are missing. The next step is to create the design document using the devbooks-design-doc skill, although the user asked for the devbooks-delivery workflow. There’s potentially a naming mismatch in the change package, so I could suggest either keeping the current ID as legacy or creating a new one. I might also consider running a progress check with the dashboard script, but there’s uncertainty about its operations.\n**Inspecting change package structure**\n\nI plan to quickly check the change-check script to understand the expected structure of a change package, which typically includes files like proposal.md, design.md, tasks.md, and verification documents. While reading the script might take some time, I know I can look at skeleton templates and existing references for guidance. However, I need to summarize for the user: only the proposal exists right now, and the other necessary files are missing, including spec delta directories. I'll mention that proposal.md includes both truth-root and change-root, which is a positive note.\n**Preparing stage detection report**\n\nI need to create a stage detection report that includes several key elements. First, I'll present the config discovery results, mentioning the truth root, change root, and constitution. I should note that we confirmed config as authoritative, even after checking project.md. \n\nNext, regarding change package existence, the path the user provided doesn’t exist; the correct one is \"optimize-indexing-pipeline-20260117.\" I'll also address stage classification: the proposal stage is complete since proposal.md exists and is approved, but design, tasks, and verification are missing. Therefore, the stage is between Proposal and Design. I'll list the missing deliverables needed to move forward, such as design.md, tasks.md, and verification.md.\n**Checking for Decision Log**\n\nThe status is \"Approved,\" but I need to confirm if it includes a Decision Log. I might need to search the file for \"Decision Log\" since I was only able to see the top part, and it seems truncated due to size. To be thorough, I plan to run a command using `rg` to look for terms like \"Decision,\" \"裁决,\" \"Decision Log,\" \"Approved,\" \"Revise,\" and \"Rejected\" within the proposal.md. This should help me find relevant information quickly.\n\n\n\n[2026-01-18T02:11:37] exec sh -lc 'rg -n \"Decision Log|Decision|裁决|Approved|Revise|Rejected\" dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md | head -n 80' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:11:38] sh -lc 'rg -n \"Decision Log|Decision|裁决|Approved|Revise|Rejected\" dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md | head -n 80' succeeded in 47ms:\n6:- Status：`Approved`（已裁决）\n47:- MCP 行为：`ci_index_status` 的“语义归属”需要被裁决（否则后续实现无法保证兼容性）\n130:- [x] **接口契约变更**：`ci_index_status` 的真实语义需要裁决并对齐（否则属于隐式 breaking）\n230:   - 若不裁决 `ci_index_status` 的语义，后续实现可能“修复一边、破坏另一边”（见 DP-01）。\n268:**问题**：`src/server.ts` 当前将 `ci_index_status` 的 `status/build/clear` 直接调用 `scripts/indexer.sh`，但 `scripts/indexer.sh` 现有参数模型更像“SCIP 索引守护进程”。需要裁决：该 MCP 工具到底代表“Embedding 索引”还是“SCIP/图索引”？\n279:**已裁决：选项 A（见 Decision Log）**\n292:**已裁决：选项 A（见 Decision Log）**\n305:**已裁决：选项 B（见 Decision Log）**\n307:## Decision Log\n309:### 2026-01-18 裁决：Approved\n[2026-01-18T02:11:38] tokens used: 59,998\n[2026-01-18T02:11:40] exec sh -lc \"sed -n '250,380p' dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:11:40] sh -lc \"sed -n '250,380p' dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\" succeeded in 33ms:\n   - `scripts/indexer.sh --help/--status/--install/--uninstall` 行为保持可用。\n\n### 建议验证命令（实现后由执行者运行）\n\n- ShellCheck：`npm run lint`\n- 构建：`npm run build`\n- 脚本基本可用性：`./scripts/indexer.sh --help`、`./scripts/scip-to-graph.sh --help`\n- 离线验证（示例）：断网或限制网络后运行 `./scripts/scip-to-graph.sh parse --incremental`（需要本地已有 `index.scip` 与离线 proto 策略落地）\n\n### 证据落点（强制路径）\n\n- Red 基线：`dev-playbooks/changes/optimize-indexing-pipeline-20260117/evidence/red-baseline/`\n- Green 证据：`dev-playbooks/changes/optimize-indexing-pipeline-20260117/evidence/green-final/`\n\n## Debate Packet（争议点/不确定点/需要辩论的问题）\n\n#### DP-01：`ci_index_status` 的语义与 `scripts/indexer.sh` 的职责（需用户决策）\n\n**问题**：`src/server.ts` 当前将 `ci_index_status` 的 `status/build/clear` 直接调用 `scripts/indexer.sh`，但 `scripts/indexer.sh` 现有参数模型更像“SCIP 索引守护进程”。需要裁决：该 MCP 工具到底代表“Embedding 索引”还是“SCIP/图索引”？\n\n[2026-01-18T02:11:40] tokens used: 60,546\n[2026-01-18T02:11:43] exec sh -lc '.codex/skills/devbooks-delivery-workflow/scripts/change-check.sh optimize-indexing-pipeline-20260117 --mode proposal --role reviewer --project-root . --change-root dev-playbooks/changes --truth-root dev-playbooks/specs' in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:11:43] sh -lc '.codex/skills/devbooks-delivery-workflow/scripts/change-check.sh optimize-indexing-pipeline-20260117 --mode proposal --role reviewer --project-root . --change-root dev-playbooks/changes --truth-root dev-playbooks/specs' exited 1 in 156ms:\ndevbooks: checking change 'optimize-indexing-pipeline-20260117' (mode=proposal, role=reviewer)\n  change-dir: ./dev-playbooks/changes/optimize-indexing-pipeline-20260117\n  truth-dir:  ./dev-playbooks/specs\n\nERROR\nwarn: proposal missing '- Value Signal and Observation:' (recommended): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\nwarn: proposal missing '- Value Stream Bottleneck Hypothesis...' (recommended): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\nerror: proposal missing decision line (e.g., '- Decision Status: Approved' or '- 决策状态： Approved'): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/proposal.md\nwarn: missing design.md (recommended for non-trivial changes): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/design.md\nerror: missing file: ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/tasks.md\nwarn: missing verification.md (expected during apply by test-owner): ./dev-playbooks/changes/optimize-indexing-pipeline-20260117/verification.md\ngit: warning: confstr() failed with code 5: couldn't get path of DARWIN_USER_TEMP_DIR; using /tmp instead\ngit: error: couldn't create cache file '/tmp/xcrun_db-v5XyCodK' (errno=Operation not permitted)\ngit: warning: confstr() failed with code 5: couldn't get path of DARWIN_USER_TEMP_DIR; using /tmp instead\ngit: error: couldn't create cache file '/tmp/xcrun_db-a6NS2mgJ' (errno=Operation not permitted)\ngit: warning: confstr() failed with code 5: couldn't get path of DARWIN_USER_TEMP_DIR; using /tmp instead\ngit: error: couldn't create cache file '/tmp/xcrun_db-5LhuSp8V' (errno=Operation not permitted)\ngit: warning: confstr() failed with code 5: couldn't get path of DARWIN_USER_TEMP_DIR; using /tmp instead\ngit: error: couldn't create cache file '/tmp/xcrun_db-50AFViCK' (errno=Operation not permitted)\nerror: Role violation: Reviewer cannot modify code files (AC-003)\n  Detected changes:\n    scripts/call-chain.sh\n    scripts/daemon.sh\n    scripts/graph-rag.sh\n    scripts/graph-store.sh\n[2026-01-18T02:11:43] tokens used: 62,487\n\n[2026-01-18T02:12:00] thinking\n\n**Analyzing task and role violations**\n\nI realize that check_tasks runs for all modes, and tasks.md might be needed even in the proposal stage. There seems to be an expectation for tasks in every workflow stage. The script flagged a Role violation because it detected changes in scripts/*.sh, which is interesting since we're not modifying, yet it checks the git diff in the working tree. It’s clear that the current worktree has modifications that could complicate role boundary gating.\n**Examining git and script errors**\n\nIt seems there might already be modifications in the change branch or locally, even though we're on the master branch. There could be unstaged changes. The script uses git diff to detect any changes but can't create caches because of permission issues with /tmp. This may be related to sandbox restrictions, as the script attempted to run git and create caches but failed. This could lead to incomplete detection and false results, although we still got the Role violation detection in the output.\n**Preparing the stage detection report**\n\nIt looks like the script successfully ran git diff, though the errors might come from git trying to locate xcrun, but I'm not totally sure. To create the stage detection report, I need to identify truth-root and change-root, confirm the change-id path, and check for any naming mismatches. \n\nI'll also look for required artifacts like proposal.md, which should have an Approved status and a Decision Log. We’re missing design.md, tasks.md, and other essential folders, suggesting we're still in the Proposal phase, with possible local changes that aren't confirmed as part of this change.\n**Verifying configuration and documents**\n\nI need to check that `.devbooks/config.yaml` includes both constitution.md and project.md, as well as the root dev-playbooks and paths. The config includes a constraint that requires the constitution to be true. Interestingly, the skill's precondition states that if agents_doc is specified in the config, I must read it, but it’s not specified here. However, since the project uses require_constitution true, I feel it’s important to also read constitution.md as part of the devbooks delivery workflow.\n**Reviewing change package and phase detection**\n\nAlthough not required by the skill, checking the constitution file might be relevant, especially for delivery workflow audits—it helps to verify the current stage. I need to ensure that the proposal and necessary specifications are present. I can note any missing sections, like absence of files or folders in the change package. The user asked about the proposal status for a specific change package, so I'll mention the naming convention issues with the change-ID and highlight any potential noncompliance. I’ll ensure to evaluate across workflow phases while being mindful of read-only constraints in the environment.\n\n\n\n\n[2026-01-18T02:12:33] exec sh -lc \"sed -n '1,220p' constitution.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:12:33] sh -lc \"sed -n '1,220p' constitution.md\" exited 1 in 25ms:\nERROR\nsed: constitution.md: No such file or directory\n[2026-01-18T02:12:33] tokens used: 65,889\n[2026-01-18T02:12:36] exec sh -lc \"sed -n '1,260p' dev-playbooks/constitution.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:12:36] sh -lc \"sed -n '1,260p' dev-playbooks/constitution.md\" succeeded in 26ms:\n# 项目宪法 (Project Constitution)\n\n> 本文档定义项目的不可违背原则（Global Inviolable Principles）。\n> 所有 AI 助手和开发者在执行任何操作前必须遵守这些原则。\n\n---\n\n## Part Zero: 强制指令\n\n**在执行任何 Skill 或操作之前，必须：**\n\n1. 阅读并理解本宪法文档\n2. 确认操作不违反任何 GIP 原则\n3. 如有冲突，立即停止并报告\n\n---\n\n## 全局不可违背原则 (Global Inviolable Principles)\n\n### GIP-01: 角色隔离原则\n[2026-01-18T02:12:36] tokens used: 66,875\n[2026-01-18T02:12:39] exec sh -lc \"git status --porcelain=v1 | sed -n '1,200p'\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:12:39] sh -lc \"git status --porcelain=v1 | sed -n '1,200p'\" succeeded in 41ms:\n M .gitignore\n M config/features.yaml\n M dev-playbooks/changes/archive/algorithm-optimization-parity/verification.md\n M dev-playbooks/specs/architecture/c4.md\n M dev-playbooks/specs/data-flow-tracing/spec.md\n…preview truncated to roughly 32768 bytes…\n…additional lines omitted…","output_total_lines":707,"output_file":"/Users/ozbombor/Projects/code-intelligence-mcp/.code/agents/f4514721-7b1a-43fb-bc84-cefbdc6b7e3e/result.txt"}
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:85:The settings "approval_policy: never" and "sandbox_mode: read-only" tell me we can't request approval or run write commands. The agent tried to execute change-check.sh, which attempted to write to /tmp caches via git, but that obviously failed in a read-only environment. We need to highlight that automated scripts might fail because of these sandbox restrictions. While the attempt generated some partial output, it’s important to mention that any checks in this read-only setup cannot be fully trusted. The user prefers no human assistance, but I'd suggest re-running the script in a full environment when possible.
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:132:    "task": "只读审计变更包 dev-playbooks/changes/optimize-indexing-pipeline-20260117：检查 proposal/design/tasks/verification/specs/evidence 对应文件/目录是否存在、内容是否包含关键字段（例如 proposal 的 Decision Log、证据落点、Change-ID 一致性）。如果有 change-check 脚本可读运行但会因沙箱写 /tmp 失败，需说明限制与以人工检查替代。输出中文：存在/缺失清单 + 阶段判断 + 风险提示。",
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:199:{"batch_id":"db95eead-1824-4b30-b5ee-357e10f5e7b9","completed_agents":["68a6df9c-e1df-4ab2-91fa-68da0f3d97e7"],"completed_summaries":[{"agent_id":"68a6df9c-e1df-4ab2-91fa-68da0f3d97e7","status":"failed","total_lines":34,"agent_result_hint":"agent {\"action\":\"result\",\"result\":{\"agent_id\":\"68a6df9c-e1df-4ab2-91fa-68da0f3d97e7\",\"batch_id\":\"db95eead-1824-4b30-b5ee-357e10f5e7b9\"}}","agent_result_params":{"action":"result","result":{"agent_id":"68a6df9c-e1df-4ab2-91fa-68da0f3d97e7","batch_id":"db95eead-1824-4b30-b5ee-357e10f5e7b9"}},"error_preview":"Command failed: 2026-01-18T02:17:28.128103Z ERROR code_core::codex::streaming: stream disconnected - retries exhausted retries=5 max_retries=5 auto_compact_attempted=false error=unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}\n[2026-01-18T02:17:16] OpenAI Codex v0.0.0 (research preview)\n[2026-01-18T02:17:16] binary: /Users/ozbombor/.cli-versions/codex/just-every/node_modules/@just-every/code-darwin-arm64/bin/code-aarch64-apple-darwin\n--------\nworkdir: /Users/ozbombor/Projects/code-intelligence-mcp\nmodel: gpt-5.2\nprovider: crs\napproval: never\nsandbox: read-only\nreasoning effort: xhigh\nreasoning summaries: auto\n--------\n[2026-01-18T02:17:16] User instructions:\nContext: read-only；approval_policy=never；不要写文件。\n\nAgent: 只读审计变更包 dev-playbooks/changes/optimize-indexing-pipeline-20260117：检查 proposal/design/tasks/verification/specs/evidence 对应文件/目录是否存在、内容是否包含关键字段（例如 proposal 的 Decision Log、证据落点、Change-ID 一致性）。如果有 change-check 脚本可读运行但会因沙箱写 /tmp 失败，需说明限制与以人工检查替代。输出中文：存在/缺失清单 + 阶段判断 + 风险提示。\n\nDesired output: 中文审计：工件存在/缺失 + 阶段判断 + 风险提示\n\nFiles to consider: .codex/skills/devbooks-delivery-workflow/SKILL.md, dev-playbooks/changes/optimize-indexing-pipeline-20260117\n\n[Running in read-only mode - no modifications allowed]\n[2026-01-18T02:17:17] ERROR: [transport] failed to start stream: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}\n[2026-01-18T02:17:17] ERROR: stream error: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}; retrying in 185ms…\n[2026-01-18T02:17:18] ERROR: [transport] failed to start stream: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}\n[2026-01-18T02:17:18] ERROR: stream error: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}; retrying in 428ms…\n[2026-01-18T02:17:19] ERROR: [transport] failed to start stream: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}\n[2026-01-18T02:17:19] ERROR: stream error: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}; retrying in 819ms…\n[2026-01-18T02:17:21] ERROR: [transport] failed to start stream: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}\n[2026-01-18T02:17:21] ERROR: stream error: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}; retrying in 1.648s…\n[2026-01-18T02:17:23] ERROR: [transport] failed to start stream: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}\n[2026-01-18T02:17:23] ERROR: stream error: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}; retrying in 3.399s…\n[2026-01-18T02:17:28] ERROR: [transport] failed to start stream: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}\n[2026-01-18T02:17:28] ERROR: unexpected status 403 Forbidden: {\"error\":{\"message\":\"Token expired and refresh failed: 认证失败：Refresh Token 无效\"}}","error_file":"/Users/ozbombor/Projects/code-intelligence-mcp/.code/agents/68a6df9c-e1df-4ab2-91fa-68da0f3d97e7/error.txt"}],"wait_time_seconds":0}
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:217:{"batch_id":"ee0cd989-1e06-43d7-ba43-92378f096154","completed_agents":["e8ee129e-4285-4e0e-9d48-1f609f30b70a"],"completed_summaries":[{"agent_id":"e8ee129e-4285-4e0e-9d48-1f609f30b70a","status":"completed","total_lines":241,"agent_result_hint":"agent {\"action\":\"result\",\"result\":{\"agent_id\":\"e8ee129e-4285-4e0e-9d48-1f609f30b70a\",\"batch_id\":\"ee0cd989-1e06-43d7-ba43-92378f096154\"}}","agent_result_params":{"action":"result","result":{"agent_id":"e8ee129e-4285-4e0e-9d48-1f609f30b70a","batch_id":"ee0cd989-1e06-43d7-ba43-92378f096154"}},"output_preview":"[2026-01-18T02:17:21] OpenAI Codex v0.0.0 (research preview)\n[2026-01-18T02:17:21] binary: /Users/ozbombor/.cli-versions/codex/just-every/node_modules/@just-every/code-darwin-arm64/bin/code-aarch64-apple-darwin\n--------\nworkdir: /Users/ozbombor/Projects/code-intelligence-mcp\nmodel: gpt-5.2\nprovider: crs\napproval: never\nsandbox: read-only\nreasoning effort: xhigh\nreasoning summaries: auto\n--------\n[2026-01-18T02:17:21] User instructions:\nContext: read-only；approval_policy=never；不要写文件。\n\nAgent: 只读检查当前 git worktree 是否存在与本变更包相关的未提交/未暂存改动，并评估其对 DevBooks 角色隔离闸门（Reviewer/Test Owner/Coder）与阶段检测的影响。需要：1) 汇总 git status 的改动范围（高层，不要粘贴太长）；2) 识别是否包含 scripts/ 或 src/ 等关键路径；3) 给出建议（例如先清理或另起工作树）。输出中文。\n\nDesired output: 中文要点：dirty 状态概览 + 对闸门影响 + 建议\n\nFiles to consider: .codex/skills/devbooks-delivery-workflow/SKILL.md\n\n[Running in read-only mode - no modifications allowed]\n\n[2026-01-18T02:17:37] thinking\n\n**Evaluating DevBooks gating impact**\n\nI'm looking into the impact of role separation in the DevBooks workflow, which includes roles like Reviewer, Test Owner, and Coder. If the worktree is dirty, it might mix changes across these roles. Some gating processes expect a clean state before tasks run, especially for the Test Owner to create and commit tests. DevBooks emphasizes isolating changes for tests and implementation. A dirty worktree can hide modifications that affect stage detection and the red/green baseline. I need to verify this with the devbooks-delivery-workflow. Let's run shell commands to check the status!\n[2026-01-18T02:17:40] Command guard: Leading cd /Users/ozbombor/Projects/code-intelligence-mcp is redundant because the command already runs in /Users/ozbombor/Projects/code-intelligence-mcp. Drop the prefix before retrying.\n\noriginal_script: cd /Users/ozbombor/Projects/code-intelligence-mcp && git status --porcelain=v1 -uall && echo '---' && git status -sb\nresend_exact_argv: [\"sh\",\"-lc\",\"git status '--porcelain=v1' -uall '&&' echo --- '&&' git status -sb\"]\n[2026-01-18T02:17:40] Command guard: Leading cd /Users/ozbombor/Projects/code-intelligence-mcp is redundant because the command already runs in /Users/ozbombor/Projects/code-intelligence-mcp. Drop the prefix before retrying.\n\noriginal_script: cd /Users/ozbombor/Projects/code-intelligence-mcp && sed -n '1,200p' .codex/skills/devbooks-delivery-workflow/SKILL.md\nresend_exact_argv: [\"sh\",\"-lc\",\"sed -n '1,200p' .codex/skills/devbooks-delivery-workflow/SKILL.md\"]\n[2026-01-18T02:17:40] tokens used: 7,165\n[2026-01-18T02:17:46] exec sh -lc \"git status --porcelain=v1 -uall && echo '---' && git status -sb\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:17:46] sh -lc \"git status --porcelain=v1 -uall && echo '---' && git status -sb\" succeeded in 69ms:\n M .gitignore\n M config/features.yaml\n M dev-playbooks/changes/archive/algorithm-optimization-parity/verification.md\n M dev-playbooks/specs/architecture/c4.md\n M dev-playbooks/specs/data-flow-tracing/spec.md\n M package.json\n M scripts/call-chain.sh\n M scripts/daemon.sh\n M scripts/graph-rag.sh\n M scripts/graph-store.sh\n M scripts/reranker.sh\n M scripts/scip-to-graph.sh\n M tests/data-flow-tracing.bats\n?? .code/agents/0c6f9fa7-003b-45d8-bcbf-75c3ded263ce/status.txt\n?? .code/agents/1/exec-call_3soQ4d1WVAPUJPuw3q7CqjlB.txt\n?? .code/agents/1/exec-call_E49iE72PwcOdcvn202Gr4QY9.txt\n?? .code/agents/1/exec-call_F1Pk9YnUczltfEy9yH3kTl1H.txt\n?? .code/agents/1/exec-call_F3hBWsMxEtovM8gRJSJPTFMA.txt\n?? .code/agents/1/exec-call_NRy0VUsPqr0GMYBdcyqFsmrC.txt\n?? .code/agents/1/exec-call_R62lvVaTwvByr7ehYlHaceIl.txt\n[2026-01-18T02:17:47] exec sh -lc \"sed -n '1,200p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:17:47] sh -lc \"sed -n '1,200p' .codex/skills/devbooks-delivery-workflow/SKILL.md\" succeeded in 35ms:\n---\nname: devbooks-delivery-workflow\ndescription: devbooks-delivery-workflow：把一次变更跑成可追溯闭环（Design→Plan→Trace→Verify→Implement→Archive），明确 DoD、追溯矩阵与角色隔离（Test Owner 与 Coder 分离）。用户说\"跑一遍闭环/交付验收/追溯矩阵/DoD/关账归档/验收工作流\"等时使用。\nallowed-tools:\n  - Glob\n  - Grep\n  - Read\n  - Write\n  - Edit\n  - Bash\n---\n\n# DevBooks：交付验收工作流（闭环骨架）\n\n## 前置：配置发现（协议无关）\n\n- `<truth-root>`：当前真理目录根\n- `<change-root>`：变更包目录根\n\n执行前**必须**按以下顺序查找配置（找到后停止）：\n[2026-01-18T02:17:47] tokens used: 7,707\n\n[2026-01-18T02:17:53] thinking\n\n**Assessing git status impact**\n\nI need to summarize the git status output at a high level and find out if directories like scripts/ or src/ are included. It's crucial to assess its effects on the DevBooks role isolation gates and phase detection. \n\nThe skill file, which outlines gate constraints affecting roles, is relevant here. It appears there are modifications to tests and scripts, even though the src/ directory shows no changes. These test modifications could violate coder restrictions if a coder altered the tests.\n**Evaluating uncommitted changes**\n\nI need to check if the current worktree has any uncommitted or untracked changes that relate to a specific change package, even though I'm unsure which one. There are modifications to files in the dev-playbooks and new scripts and configs. In the DevBooks workflow, scripts assume a clean git state, and any dirty worktree might confuse gate scripts by detecting unapproved modifications.\n\nI need to summarize this in Chinese, focusing on the dirty status, gate impacts, and suggestions without going into too much detail.\n**Analyzing git status and warnings**\n\nI might consider running `git diff --name-only` for more details, but the current output already provides enough information. I noticed warnings related to the xcrun db cache file not being creatable in /tmp due to permissions issues. However, since the command succeeded, it’s mostly a side note, though it could signal environment restrictions that might impact scripts using xcrun.\n\nI need to state that we checked for uncommitted changes related to this change package and found many modifications. This dirty worktree includes changes in multiple categories, which might disrupt role isolation gating for DevBooks.\n**Evaluating roles and changes**\n\nIf the coder role is active, they would encounter failures since certain modifications in scripts would conflict. Likewise, the reviewer can't modify code files, and the test owner can't change the source files, which is okay since there are no modifications there. However, change-check might detect implicit changes due to updates in package.json and config files, leading to potential false positives.\n\nUntracked files might confuse check scripts as they may register these as new additions. Overall, a dirty workspace hinders reproducibility and affects gate accuracy, so we should clarify if crucial paths like scripts/ or src/ are involved.\n**Summarizing modifications and roles**\n\nI see there are modifications in `scripts/` and `tests/`, with no changes in `src/`, but package.json and some config files have been updated. There are untracked files with non-ASCII characters, which might create cross-platform issues. This repository could include Chinese documents, but it’s essential to avoid non-ASCII files to prevent complications.\n\nThe environment is read-only, so I can only advise on how to handle the dirty workspace. There are 13 modified tracked files and many untracked ones. Each role needs careful evaluation because existing changes might affect role boundaries and validations.\n**Categorizing issues and recommendations**\n\nI need to categorize the untracked set, which includes test files and modified scripts, config, and other artifacts. These untracked files could confuse gate scripts, especially for role boundaries. The `.gitignore` file might indicate attempts to ignore `.code/` files, but untracked still may interfere with accurate gating.\n\nThe user requested a summary in Chinese regarding dirty status, gate impacts, and suggestions. Additionally, there are environment restrictions that could affect some operations. Hence, I’ll advise the user about cleaning their workspace and maintaining separate worktrees for each role to ensure smooth operation.\n**Gathering context for the user**\n\nThe `.gitignore` file already includes `.code/`, and with that settled, I'm considering how to provide a high-level diff in Chinese. I plan to run `git diff --name-only` and `git diff --stat` to get an overview, even though I already have a file list. I want to mention that we've modified 13 tracked files and added over 20 untracked files or directories, mainly in `.code/`, `scripts/llm-providers/`, and `tests/`.\n\nI also need to keep an eye on a warning regarding the creation of a cache file, which suggests restrictions in the environment. I'll run a command to categorize the file statuses without writing anything.\n\n\n\n\n\n\n[2026-01-18T02:19:04] exec sh -lc \"git status --porcelain=v1 -uall | awk '{print \"'$1}'\"' | sort | uniq -c && echo '---' && git status --porcelain=v1 -uall | wc -l\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:19:04] sh -lc \"git status --porcelain=v1 -uall | awk '{print \"'$1}'\"' | sort | uniq -c && echo '---' && git status --porcelain=v1 -uall | wc -l\" succeeded in 68ms:\n  31 ??\n  13 M\n---\n      44\n[2026-01-18T02:19:04] tokens used: 15,871\n\n[2026-01-18T02:19:10] thinking\n\n**Analyzing git worktree status**\n\nSo, the user's request is to check the current git worktree for uncommitted or untracked changes. I need to summarize the git status change scope without getting too detailed. I’ll also need to see if it includes key paths like `scripts/` or `src/`. Then, I should provide recommendations on whether to clean up or create a new worktree. I’m working in a read-only environment and there are also warnings about cache file creation, which might be relevant.\n**Evaluating role boundaries and changes**\n\nI need to consider the `.codex/skills/devbooks-delivery-workflow/SKILL.md` file, which outlines the role boundaries for Coder, Test Owner, and Reviewer. This is crucial for assessing modifications in the worktree concerning the change package. However, I'm uncertain about the change-id, though it might relate to \"本变更包.\" Current modifications may involve the `algorithm-optimization-parity` package. The user explicitly asked about how the work relates to this change package, so I should take that into account as I evaluate.\n**Parsing git status output**\n\nI’m analyzing the git status output, noting modified tracked files like `.gitignore`, `config/features.yaml`, and various scripts. There are also untracked files in the `.code/` directory and others like `docs/超越augment抄呐.txt`. Interestingly, there's no modification in the `src/` directory. The changes mostly appear in scripts, tests, configs, and `dev-playbooks`. For DevBooks roles, if a Coder can't modify `tests/**` and `verification.md`, then modifications in `tests/data-flow-tracing.bats` and `verification.md` by a Coder would be a violation of their role boundaries.\n**Assessing worktree modifications**\n\nSince I'm only checking the worktree, I can’t directly attribute changes. However, I notice that the dirty state has modifications in tests and verification, which would cause `change-check.sh` to fail if a Coder made those changes. This could also confuse stage detection if verification is altered without evidence. The Test Owner can modify tests, which might make the dirty state acceptable. Still, there are system changes in scripts and package.json that should be declared, even though SKILL.md only restricts modifications to src/**.\n**Evaluating worktree and role boundaries**\n\nI see there are many modified `.sh` scripts, which might violate the Reviewer role and cause `change-check.sh` to fail if run with the Reviewer role. The user mentioned evaluating the impact on role boundaries and stage detection, specifically regarding uncommitted changes. \n\nThe worktree is dirty with 13 modified unstaged files and 31 untracked files. I should summarize key modifications in paths like config and dev-playbooks. Additionally, some untracked files may need to be ignored or cleaned up—like `.code/` logs and `.migrate.lock`. Since I can't write anything, I can just suggest potentially ignoring `.code/` in the `.gitignore`.\nI'm detecting several issues in the worktree. The modifications impact role isolation in DevBooks. The Coder role is in trouble because they modified files in `tests/**` and `dev-playbooks/.../verification.md`, which shouldn't happen. For the Reviewer role, there are many `.sh` modifications that could violate their boundaries. Test Owner modifications are fine, but they could mix roles with system changes. \n\nStage detection might also be affected due to changes in archived files, and untracked logs could add noise. My suggestion is to create a clean worktree for changes and declare any modifications clearly.\nI want to provide a high-level overview rather than a list of individual file names. It'll be more helpful to categorize the modifications into six categories and include counts and examples. For instance, I could mention that `scripts/` has 6 modified files and 7 new ones, while `tests/` has 1 modified and 8 new files. \n\nI plan to run a shell command with `git status` to aggregate counts by top-level directory using awk. This way, I can get a clearer picture of the modifications.\n\n\n\n\n\n\n[2026-01-18T02:20:06] exec sh -lc \"git status --porcelain=v1 -uall | awk '{print \"'$2}'\"' | sed 's#\"'^\"##; s#\"$##'\"' | awk -F/ '{print \"'$1}'\"' | sort | uniq -c | sort -nr\" in /Users/ozbombor/Projects/code-intelligence-mcp\n[2026-01-18T02:20:06] sh -lc \"git status --porcelain=v1 -uall | awk '{print \"'$2}'\"' | sed 's#\"'^\"##; s#\"$##'\"' | awk -F/ '{print \"'$1}'\"' | sort | uniq -c | sort -nr\" succeeded in 51ms:\n  14 .code\n  13 scripts\n   8 tests\n   3 dev-playbooks\n   2 config\n   1 package.json\n   1 docs\n   1 .migrate.lock\n   1 .gitignore\n[2026-01-18T02:20:06] tokens used: 19,809\n\n[2026-01-18T02:20:27] thinking\n\n**Clarifying role responsibilities**\n\nI’m verifying that for a certain role, specific paths weren’t modified compared to the base branch. However, if the worktree has changes outside the change package, it could incorrectly point those out. For example, if I’m acting as a Coder, failing tests will be an issue. As a Reviewer, changed scripts can cause failures, and for a Test Owner, if `src` changes are blocked but those changes are absent, it might lead to confusion regarding roles.\n**Understanding gating by role**\n\nGating might operate differently depending on the role. For instance, running a change-check as a \"test-owner\" could confirm that the `src` hasn’t changed, which would pass if it’s clean. However, if I run the check as a Coder with changed tests, that would lead to a failure. These test changes might be necessary or part of another change. I can also note that running DevBooks scripts requires a clean git state, but untracked `.code/agents/...` logs might complicate things.\n**Assessing stage detection issues**\n\nI suggest adding `.code` to `.gitignore` or cleaning those up, but I can’t make changes due to a read-only state. I can only offer suggestions for fixes. \n\nIn DevBooks, stage detection relies on specific change package directories rather than just the git status. If there are dirty changes, that could cause issues with stage detection and affect the archive process. For instance, if a verification file in an archived change is modified, it could break the \"archive gate.\" Generally, archived changes shouldn't be edited, so I expect a failure during the audit scope check. I've also noted the importance of reviewing `SKILL.md` for role boundaries and gates.\n**Crafting a response**\n\nI need to create a response with bullet points in Chinese. First, I’ll overview the dirty status: there are 44 changes, including 13 modified tracked files and 31 untracked files. Modifications exist across various areas, like `.gitignore`, configs, and test scripts. The untracked files mainly consist of `.code/` agent logs, and new scripts and tests have been added on the master branch.\n\nNext, I’ll address the potential gate impacts regarding DevBooks role boundaries. Since there have been changes in tests and scripts, this could violate coder and reviewer roles. Changes to spec and truth documents may also be restricted based on the current stage. Running change-check or handoff-check might fail due to detecting “implicit changes” in the modified files. Moreover, stage detection could label untracked `.code/` files as hygiene issues, undermining the trustworthiness of captured evidence.\n**Crafting final response**\n\nI’m going to create a precise response focusing on the role boundary table in Chinese bullet points. First, I'll summarize the dirty status: there are issues with files in the `tests/**` directory that a coder cannot modify, including `tests/data-flow-tracing.bats` and new test scripts. \n\nNext, I'll note potential gate impacts, as changes in tests and scripts may violate role boundaries for coders and reviewers. Lastly, I'll provide suggestions for addressing these issues in a bullet list format. \n\nI'll structure it simply to follow the user’s request clearly: **Dirty 状态概览**, **对闸门影响**, and **建议**, keeping the content concise and organized.\n**中文要点**\n\n- **变更范围汇总**: 当前工作区存在未提交/未暂存的改动，共44个，其中包括: \n  - **更改目录**: tests/**, dev-playbooks/**, config/**, \n  - **修改文件**: tests/data-flow-tracing.bats、dev-playbooks/specs/data-flow-tracing/spec.md 和其他。\n\n- **关键路径识别**: 包含 scripts/（是）、src/（否）、tests/（是）、dev-playbooks/（是）、config/（是）。\n\n- **建议**: 建议先清理工作区，或另起工作树，来避免干扰。 \n\n从路径命名来看，这些更改至少与 data-flow-tracing 和 algorithm-optimization-parity 变更包相关。请注意，.code/ 文件可能是工具生成的产物，理论上不属于变更包。\n\n\n\n\n\n[2026-01-18T02:21:58] codex\n\n**Dirty 状态概览**\n- 当前 `master` worktree 是 dirty：共 44 条变更（13 个 tracked 修改 `M` + 31 个 untracked `??`）\n- tracked 修改覆盖面较广：根目录（`.gitignore`、`package.json`）、`config/`、`dev-playbooks/`、`scripts/`、`tests/`\n- 从命名看与变更主题强相关的路径包括：`dev-playbooks/specs/data-flow-tracing/spec.md`、`tests/data-flow-tracing.bats`；同时还出现对已归档目录 `dev-playbooks/changes/archive/algorithm-optimization-parity/verification.md` 的修改（高风险信号）\n\n**关键路径识别**\n- `scripts/`：有多文件修改 + 新增（`.sh` 与 `scripts/llm-providers/**`），属于可执行代码/工程系统变更\n- `src/`：`git status` 未出现（当前 dirty 不涉及 `src/**`）\n- 其他关键：`tests/`（修改+新增多份 `.bats`）、`config/`（features + 新增 llm providers 配置）、`dev-playbooks/specs/**`（真理规格被改）\n\n**对 DevBooks 角色隔离闸门与阶段检测的影响（依据 `devbooks-delivery-workflow` 的角色边界表）**\n- `coder` 角色：worktree 内存在 `tests/**` 改动，且有 `.../verification.md` 改动；运行 `change-check.sh ... --role coder` 基本会因“Coder 禁止修改 `tests/**`、`verification.md`”被拦截\n- `reviewer` 角色：存在 `scripts/*.sh` 改动（`.sh` 属代码文件），会触发“Reviewer 禁止修改代码文件”的边界闸门\n- `test-owner` 角色：硬禁止项是 `src/**`，当前未见 `src/` 改动；但混入大量工程/依赖/脚本改动会让 handoff/audit 难以归因，阶段检测容易出现“范围膨胀/假完成”争议\n- 阶段/审计层面：`package.json`、`config/**`、`.gitignore`、`scripts/**` 这类通常会触发 `check_implicit_changes()` / 工程系统变更检查；untracked 的 `.code/` 等工具产物会让卫生/审计类检查更难通过，且污染证据可复现性\n\n**建议**\n- 最稳妥：为“本变更包”另起一个干净 worktree（或干净分支），只带入该变更需要的最小改动；把当前 worktree 当实验区，避免闸门无法定位责任\n- 若必须继续用当前 worktree：优先处理长期脏源（例如 `.code/` 这类工具产物应被忽略或迁出），并把 `tests/`/`scripts/`/`package.json`/`config/` 的变更是否属于本变更包范围做一次明确归类与显式声明\n- 跑闸门前按角色“对齐改动范围”：Reviewer 不应碰 `.sh` 等代码文件；Coder 不应碰 `tests/**`/`verification.md`；否则会在角色边界闸门处直接卡死\n[2026-01-18T02:22:06] tokens used: 27,876","output_file":"/Users/ozbombor/Projects/code-intelligence-mcp/.code/agents/e8ee129e-4285-4e0e-9d48-1f609f30b70a/result.txt"}],"wait_time_seconds":222}
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:238:We need to note that the instructions likely require reading the constitution if `require_constitution` is enabled; the first agent successfully read `dev-playbooks/constitution.md`. Additionally, the script `change-check.sh` attempted to write to `/tmp` but failed due to sandbox restrictions, so automated gate scripts might fail in this environment. We should highlight that in a read-only sandbox, executing devbooks scripts may fail due to `/tmp` write permission issues. 
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:257:- 闸门状态: 无法在当前只读沙箱可靠执行，需在可写环境及干净工作树重新运行 `change-check.sh`。  
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:297:  - tasks：缺失（目录内未发现 `tasks.md`；`change-check.sh` 在 proposal 模式下也将其视为 error）。
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:304:  - 在本次 read-only 沙箱下，执行 `.codex/skills/devbooks-delivery-workflow/scripts/change-check.sh` 时出现 `/tmp` 写入受限导致的 git 相关报错（会降低自动闸门输出可信度，需要在可写环境复跑）。
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:309:- **Plan 缺口（阻塞项）**：缺失 `dev-playbooks/changes/optimize-indexing-pipeline-20260117/tasks.md`（`change-check.sh` 报 error）。
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:310:- **Design 缺口（强烈建议/非平凡变更）**：缺失 `dev-playbooks/changes/optimize-indexing-pipeline-20260117/design.md`（`change-check.sh` 报 warn）。
./.code/agents/91a3c3b7-94be-45be-b813-d91fb28abccb/result.txt:313:- **Proposal 规范化缺口**：`change-check.sh` 认为 proposal 缺少明确的“Decision Status”行（它期待类似 `- 决策状态： Approved` 的格式；当前文档是 `- Status：Approved` + Decision Log）。
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:380:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:68:{"timestamp":"2026-01-20T11:47:13.107Z","type":"response_item","payload":{"type":"function_call_output","call_id":"call_p7SL4g2751I01Lt3y2tyx9YL","output":"{\"batch_id\":\"d7e98881-0bc5-48bf-a510-a60c38ed164f\",\"completed_agents\":[\"5e81a23b-93c6-4ca9-85e0-0ba7039901ed\",\"038b3342-37f3-42d2-a7af-76dfcf200305\"],\"completed_summaries\":[{\"agent_id\":\"5e81a23b-93c6-4ca9-85e0-0ba7039901ed\",\"status\":\"failed\",\"total_lines\":2,\"agent_result_hint\":\"agent {\\\"action\\\":\\\"result\\\",\\\"result\\\":{\\\"agent_id\\\":\\\"5e81a23b-93c6-4ca9-85e0-0ba7039901ed\\\",\\\"batch_id\\\":\\\"d7e98881-0bc5-48bf-a510-a60c38ed164f\\\"}}\",\"agent_result_params\":{\"action\":\"result\",\"result\":{\"agent_id\":\"5e81a23b-93c6-4ca9-85e0-0ba7039901ed\",\"batch_id\":\"d7e98881-0bc5-48bf-a510-a60c38ed164f\"}},\"error_preview\":\"Command failed: When using Gemini API, you must specify the GEMINI_API_KEY environment variable.\\nUpdate your environment and try again (no reload needed if using .env)!\",\"error_file\":\"/Users/ozbombor/project/.code/agents/5e81a23b-93c6-4ca9-85e0-0ba7039901ed/error.txt\"},{\"agent_id\":\"038b3342-37f3-42d2-a7af-76dfcf200305\",\"status\":\"failed\",\"total_lines\":363,\"agent_result_hint\":\"agent {\\\"action\\\":\\\"result\\\",\\\"result\\\":{\\\"agent_id\\\":\\\"038b3342-37f3-42d2-a7af-76dfcf200305\\\",\\\"batch_id\\\":\\\"d7e98881-0bc5-48bf-a510-a60c38ed164f\\\"}}\",\"agent_result_params\":{\"action\":\"result\",\"result\":{\"agent_id\":\"038b3342-37f3-42d2-a7af-76dfcf200305\",\"batch_id\":\"d7e98881-0bc5-48bf-a510-a60c38ed164f\"}},\"error_preview\":\"Command failed: 2026-01-20T11:36:30.749648Z ERROR code_core::codex::streaming: MCP client for `ckb` failed to start: failed to spawn MCP server `ckb` using command `/usr/local/bin/ckb` with args [\\\"mcp\\\"]: MCP server reported protocol version 2024-11-05, but this client expects 2025-06-18. Update either side so both speak the same schema.\\n[2026-01-20T11:36:30] OpenAI Codex v0.0.0 (research preview)\\n[2026-01-20T11:36:30] binary: /Users/ozbombor/.cli-versions/codex/just-every/node_modules/@just-every/code-darwin-arm64/bin/code-aarch64-apple-darwin\\n--------\\nworkdir: /Users/ozbombor/project\\nmodel: gpt-5.2\\nprovider: crs\\napproval: never\\nsandbox: read-only\\nreasoning effort: high\\nreasoning summaries: auto\\n--------\\n[2026-01-20T11:36:30] User instructions:\\nContext: File: /Users/ozbombor/Projects/AI软件开发系统设计-2.md. Need to integrate prototype validation and its overlap with hard problem verification.\\n\\nAgent: Design a best-practice module for '原型验证' and its relationship to '难题攻关' verification; propose unified/overlapping structure, gates, artifacts, and decision flow. Provide a succinct framework section and clarifying guidance. Must be generic and easy for new users.\\n\\nDesired output: Section text + diagram or bullet workflow + artifact list + DoR/DoD suggestions (Chinese).\\n\\n[Running in read-only mode - no modifications allowed]\\n[2026-01-20T11:36:30] ERROR: MCP client for `ckb` failed to start: failed to spawn MCP server `ckb` using command `/usr/local/bin/ckb` with args [\\\"mcp\\\"]: MCP server reported protocol version 2024-11-05, but this client expects 2025-06-18. Update either side so both speak the same schema.\\n\\n[2026-01-20T11:36:42] thinking\\n\\n**Planning Chinese content structure**\\n\\nI need to write Chinese content, but I'm in a read-only environment, so I can't edit files. I can utilize shell commands to read files, using tools like cat or sed. I should integrate prototype validation and ensure there's overlap for hard problem verification. I'll propose a structure involving modules and decision flow while including diagrams and workflows. It's important to avoid duplication and unify things with a \\\"验证矩阵.\\\" Keeping everything generic and simple is a priority here!\\n[2026-01-20T11:36:45] exec sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects\\\\\\\" | sed -n '1,120p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:36:45] sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects\\\\\\\" | sed -n '1,120p'\\\" succeeded in 42ms:\\ntotal 200\\ndrwxr-xr-x@ 25 ozbombor  staff    800 Jan 20 16:21 .\\ndrwxr-x---+ 90 ozbombor  staff   2880 Jan 20 19:36 ..\\n-rw-r--r--@  1 ozbombor  staff  26628 Jan 20 18:44 .DS_Store\\ndrwxr-xr-x@  8 ozbombor  staff    256 Jan  7 20:37 .ckb\\ndrwxr-xr-x@ 14 ozbombor  staff    448 Jan 20 03:32 AI-Code\\n-rw-r--r--@  1 ozbombor  staff  40748 Jan 20 06:08 AI软件开发系统设计-2.md\\n-rw-r--r--@  1 ozbombor  staff  10671 Jan 20 06:08 AI软件开发系统设计-3.md\\ndrwxr-xr-x@  8 ozbombor  staff    256 Sep 26 21:07 DocRED\\ndrwxr-xr-x@ 12 ozbombor  staff    384 Nov 26 09:07 LLMxMapReduce\\ndrwxr-xr-x@ 11 ozbombor  staff    352 Aug 23 07:05 NingVideo\\ndrwxr-xr-x@ 26 ozbombor  staff    832 Jan 20 05:52 QLMarkdown\\n-rw-r--r--   1 ozbombor  staff  17799 Jan 20 05:32 SFF-四议题回答.md\\ndrwxrwxrwx@  8 ozbombor  staff    256 Jan 18 10:01 UCA-GCC\\ndrwxr-xr-x@ 72 ozbombor  staff   2304 Nov 26 09:07 VCPToolBox\\ndrwxr-xr-x@ 21 ozbombor  staff    672 Nov 26 09:07 ai-app-lab\\ndrwxr-xr-x  30 ozbombor  staff    960 Jan 20 16:22 cc-switch\\ndrwxr-xr-x@ 39 ozbombor  staff   1248 Jan 20 05:37 code-intelligence-mcp\\ndrwxr-xr-x@  7 ozbombor  staff    224 Jan 16 23:55 cursor\\ndrwx---rwx@ 96 ozbombor  staff   3072 Jan 20 19:03 deep_search\\n[2026-01-20T11:36:47] tokens used: 11,447\\n[2026-01-20T11:36:53] exec sh -lc \\\"sed -n '1,240p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:36:53] sh -lc \\\"sed -n '1,240p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 26ms:\\n# AI软件开发系统设计2\\n\\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\\n>\\n> 本文是“完整版系统描述（自包含）”。\\n>\\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\\n>\\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\\n\\n---\\n\\n## 0. 元信息\\n\\n- 系统代号：The Software Forge（SFF）\\n- 文档名：AI软件开发系统设计-gpt\\n- 版本：v0.1（设计稿）\\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\\n[2026-01-20T11:36:53] tokens used: 12,427\\n[2026-01-20T11:37:00] exec sh -lc \\\"rg -n \\\\\\\"原型验证|prototype|POC|概念验证|验证\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:37:00] sh -lc \\\"rg -n \\\\\\\"原型验证|prototype|POC|概念验证|验证\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" succeeded in 44ms:\\n35:- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\\n50:2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\\n78:3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\\n141:- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\\n251:  prototype/... (可选，prototype 轨)\\n265:- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\\n377:- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\\n428:- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\\n476:- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\\n616:- DevBooks 在 proposal/apply/archive 时必须验证：\\n685:## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\\n687:> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\\n732:**可验证性（建议实现为静态检查）**：\\n831:- 宪法检查：strict 模式验证 constitution（如适用）\\n[2026-01-20T11:37:01] tokens used: 16,049\\n[2026-01-20T11:37:05] exec sh -lc \\\"sed -n '220,340p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:37:05] sh -lc \\\"sed -n '220,340p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 35ms:\\nfitness:\\n  enabled: true\\n  mode: warn\\n  rules_file: specs/architecture/fitness-rules.md\\ntracing:\\n  ac_required: true\\n  coverage_threshold: 80\\n```\\n\\n### 7.2 Genesis 的真理落点（建议）\\n\\n在 `<truth-root>/specs/_meta/` 下新增：\\n\\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\\n\\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\\n\\n### 7.3 变更包结构（DevBooks 既有范式）\\n[2026-01-20T11:37:06] tokens used: 16,722\\n[2026-01-20T11:41:45] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:45] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 213ms…\\n[2026-01-20T11:42:15] exec sh -lc \\\"rg -n \\\\\\\"难题|攻关|hard problem|spike|技术验证\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:15] sh -lc \\\"rg -n \\\\\\\"难题|攻关|hard problem|spike|技术验证\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" succeeded in 73ms:\\n[2026-01-20T11:42:17] tokens used: 18,830\\n\\n[2026-01-20T11:42:34] thinking\\n\\n**Integrating validation frameworks**\\n\\nThe user wants to integrate prototype validation with hard problem verification. In the system, there’s a prototype track in the change package skeleton and an existing verification document. I’m considering unifying these concepts since prototypes provide valuable evidence but aren't substitutes for tests, which refine acceptance criteria, specifications, and tasks. I might propose adding a new section to the documentation that outlines unknown classifications and recommended methods for each type. Then I'll suggest unifying the gating process for clarity.\\n**Establishing decision flow**\\n\\nI need to create a decision flow for when to prototype versus committing directly to specifications or tests. If the uncertainty is high but testing is cheap, I should prototype; otherwise, I’ll proceed with specs or tests directly. A \\\"No-go\\\" should lead to stopping or redesigning. I also want to define criteria for prototype validation and hard problem verification, including examples to make it user-friendly and simple. I'll propose integrating a \\\"Prototype Evidence\\\" section into the verification document.\\n**Referencing change package context**\\n\\nI need to reference the file context where the change package includes prototypes as optional. It’s important to keep the prototype code separate since it shouldn't necessarily be shipped, but could move to production via an uplift path with proper gating and testing. I should connect this to \\\"攻关验证包” in Chinese, defining it when uncertainty is high. I'll propose a new micro-loop in DevBooks: Explore, Verify, Decide, Backport, Execute. Additionally, prototypes should always produce evidence and have their own criteria for entry and exit in the process.\\n**Exploring verification concepts**\\n\\nI need to dive deeper into the document to understand the existing concept of \\\"验证\\\" (verification). My first step will be to search for \\\"verification.md\\\" to see what information it contains. This will help clarify how verification is structured and what evidence is necessary. By doing this, I’ll be better equipped to address any related tasks or further integrations that might arise. I wonder what I’ll discover in that section!\\n\\n\\n\\n[2026-01-20T11:42:53] exec sh -lc \\\"rg -n \\\\\\\"verification\\\\\\\\.md|evidence/|Green evidence|闸门\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,220p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:53] sh -lc \\\"rg -n \\\\\\\"verification\\\\\\\\.md|evidence/|Green evidence|闸门\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,220p'\\\" succeeded in 53ms:\\n24:  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\\n37:因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\\n57:- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\\n88:- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\\n121:  - 基于证据的完成（Green evidence）\\n122:  - 质量闸门脚本（change-check 等）\\n130:- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\\n142:- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\\n147:### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\\n149:DevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\\n151:1) **Change Size Gate（硬闸门）**\\n155:2) **Epic Alignment Gate（硬闸门）**\\n160:3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\\n163:这些闸门的触发方式、输出格式、失败回退路径在后文定义。\\n184:- 通过硬闸门与证据链才允许归档\\n248:  verification.md\\n250:  evidence/...\\n258:## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\\n273:本文仅给出系统层面的落地约束（硬闸门视角）：\\n314:### 8.4 Genesis DoR（Definition of Ready，硬闸门）\\n[2026-01-20T11:42:56] tokens used: 20,592\\n[2026-01-20T11:43:05] exec sh -lc \\\"sed -n '400,760p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:43:06] sh -lc \\\"sed -n '400,760p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 43ms:\\n- Feature flag + Progressive delivery（行为变更）\\n  - 默认关闭，先观测\\n  - 灰度开启\\n  - 全量后清理\\n\\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\\n\\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\\n\\n建议预算信号（非单指标）：\\n\\n- 文件触达数（files_touched）\\n- 跨模块数（modules_touched）\\n- 对外契约/数据迁移/安全变更标志（risk_flags）\\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\\n\\n输出应包含：\\n- 预算阈值（budget）\\n- 计算值（score）\\n[2026-01-20T11:43:07] tokens used: 23,509\\n\\n[2026-01-20T11:43:18] thinking\\n\\n**Refining verification process**\\n\\nI shouldn't automatically merge to truth; instead, I may produce distilled specifications, code, or scripts. The \\\"难题攻关\\\" (Hard Problem) verification focuses on high-risk technical issues, often requiring deeper investigation with strict acceptance criteria. I need to treat \\\"难题\\\" as validation questions and unify this with \\\"Validation Questions,\\\" \\\"Hypothesis,\\\" and \\\"Evidence\\\" lists. It's important to propose validation gating before implementing changes, ensuring we have a validation plan included in each proposal or design effort.\\n**Structuring prototype and verification**\\n\\nIn the use stage V0, I need to trigger the \\\"prototype track\\\" to produce evidence and update designs or specifications. Prototype validation should cover UX and integration, while hard problem verification focuses on correctness and performance. Sometimes these overlap, like in a proof of concept that measures latency. I need a comprehensive artifact list and clear definitions for \\\"Definition of Ready\\\" and \\\"Definition of Done\\\" for both prototypes and hard problem verification to ensure we stay on track.\\n**Creating validation templates and workflows**\\n\\nI propose a unified template to reduce confusion, using a single \\\"验证工作单\\\" or \\\"validation.md\\\" with key sections: Why/Question, Hypotheses, Approach, Evidence Plan, Metrics/Thresholds, Environment, Notes, and Decision. This applies to both prototypes and hard problems. I also need a workflow diagram or bullet points, maybe an ASCII decision tree. It should guide the process from identifying risks to deciding if we proceed, pivot, or kill the project, ensuring we document everything appropriately for future reference.\\n**Clarifying prototype responsibilities**\\n\\nI should consider the interplay with DevBooks role isolation. Prototyping might be done by someone in the \\\"Researcher/Explorer\\\" role, but their system includes various roles like Proposal, Design, Test Owner, and others. It's not explicitly clear if prototypes should happen under a Proposal Author, so I can use \\\"Prototype Owner\\\" as a generic term. Prototypes should stay in the `prototype/` directory, while actual code goes in a separate branch. I want to avoid polluting architecture and treat prototypes as disposable. I'll also create a new section titled \\\"原型验证（Prototype Validation）与难题攻关验证（Hard Problem Verification）\\\" to organize everything clearly.\\n**Designing a unified validation system**\\n\\nWe need to create a succinct yet complete validation system that caters to new users in Chinese. I'll provide a bullet point workflow along with an ASCII diagram, artifact lists, and definitions for DoR and DoD. Prototypes may fit between G0 and G1 or within DevBooks while closing open questions. I'll outline when to run prototype validations depending on the stage and emphasize stricter evidence for hard problem verification. I'll also propose a distinct structure, mentioning the relationship between prototypes and hard problems while keeping everything minimal to ensure clarity for new users.\\n\\n\\n\\n\\n[2026-01-20T11:43:54] codex\\n\\n下面是一段可直接粘贴进你文档的“最佳实践模块”，用于把「原型验证」与「难题攻关」的验证关系讲清楚，并给出统一结构、闸门、工件与决策流（偏通用、对新手友好）。\\n\\n---\\n\\n## 原型验证（Prototype Validation）与难题攻关验证（Hard Problem Verification）\\n\\n### 1) 一句话定位（新手版）\\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定“做 / 不做 / 怎么做”。\\n- 难题攻关验证：专门处理高风险技术难点，把“可行性/正确性/性能/可靠性”用可复现证据钉死。\\n- 统一视角：两者都是「验证（Validation）」；区别只在**风险等级**与**证据严苛度**。多数情况下：**难题攻关 = 更严格的原型验证**（或原型验证的一个子类型）。\\n\\n### 2) 统一结构：验证问题（VQ）驱动，而不是“先写原型再找理由”\\n把所有“要不要做原型/要不要攻关”统一成一组可追踪的验证问题：\\n\\n- `VQ (Validation Question)`：我们必须回答的关键问题（例如：延迟能否 < 200ms？这套交互用户是否能理解？）\\n- `H (Hypothesis)`：对 VQ 的假设（可被推翻）\\n- `Metric/Threshold`：可量化的指标与门槛（Pass/Fail）\\n- `Method`：验证方法（原型 / 实验 / 压测 / 对照 / 仿真 / 小规模集成）\\n- `Evidence`：证据位置（脚本、日志、截图、数据、报告）\\n- `Decision`：结论与下一步（Proceed / Pivot / Stop / Need-more-info）\\n\\n建议把这组内容放进一个“验证包（Validation Packet）”，并要求每个 VQ 都能落到证据与决策。\\n\\n---\\n\\n## 3) 原型 vs 难题攻关：如何分流（但不分家）\\n\\n### 3.1 何时叫“原型验证”\\n满足任一即可：\\n- 目标不确定：用户是否接受、交互是否清晰、信息架构是否合理、端到端体验是否“像那么回事”\\n- 集成不确定：第三方/模型/系统组合起来是否跑得通（但还不需要严格指标）\\n- 方案选择不确定：A/B/C 哪条路更合适（需要快速对比）\\n\\n证据特点：允许低保真、允许手动步骤、允许非完整工程化，但必须能支持“做决策”。\\n\\n### 3.2 何时必须升级为“难题攻关验证”\\n命中任一“高风险旗标”建议强制升级：\\n- 正确性：算法/推理链/数据一致性/幂等/事务边界/安全权限\\n- 性能：延迟、吞吐、内存、成本（token/调用）、尾延迟（P95/P99）\\n- 可靠性：降级/重试/超时/错误语义/可观测性闭环\\n- 规模化：数据量级、并发级别、冷热路径、缓存策略\\n- 不可逆：数据迁移、对外契约、合规要求\\n\\n证据特点：必须**可复现**、**可对比**、**有阈值**，最好能自动化（脚本化运行或最小基准测试）。\\n\\n---\\n\\n## 4) 统一闸门（Gates）：把验证嵌入交付闭环，而不是“可选项”\\n\\n建议新增一个概念性闸门（可落到流程/脚本）：**Validation Gate（验证闸门）**  \\n触发条件：当变更/切片被标注为 `unknowns_present=true` 或存在高风险旗标时，该闸门默认阻断继续推进。\\n\\n闸门通过的最小条件（通用版）：\\n- 每个 VQ 都有明确的 Pass/Fail 门槛（允许“目前无法量化”，但必须说明原因与替代证据）\\n- 证据可定位且可复现（至少：环境/步骤/输入/输出）\\n- 结论不是“感觉可以”，而是 `Proceed/Pivot/Stop/Need-more-info` 之一\\n- 若 `Proceed`：必须产出“可被执行阶段继承的合同化结果”（例如：AC/约束/测试锚点/预算）\\n\\n---\\n\\n## 5) 决策流（Diagram + Workflow）\\n\\n```text\\n[发现不确定/风险旗标]\\n        |\\n        v\\n[写 VQ + 阈值 + 时间盒 + 证据计划]\\n        |\\n        v\\n[选择方法]\\n  |-- 原型验证（低保真/快）\\n  |-- 难题攻关（高证据/可复现/指标化）\\n        |\\n        v\\n[产生证据 Evidence]\\n        |\\n        v\\n[结论 Decision]\\n  |-- Proceed -> 把结果“合同化”（AC/约束/测试锚点/预算）-> 进入实现闭环\\n  |-- Pivot   -> 改方案/改切片/改约束 -> 回到设计/切片层重新对齐\\n  |-- Stop    -> 归档经验与原因（防重复踩坑）\\n  |-- Need-more-info -> 明确下一轮 VQ（避免无休止试错）\\n```\\n\\n给新手的操作性版本（bullet workflow）：\\n- Step 1：列出 1~3 个最关键 `VQ`（不要一次写 20 个）\\n- Step 2：为每个 VQ 写清楚“**怎么才算过**”（阈值/对照/可接受范围）\\n- Step 3：选最低成本方法拿证据（先快后严；先局部后端到端）\\n- Step 4：记录证据与结论，并明确下一步（Proceed/Pivot/Stop）\\n- Step 5：若 Proceed，把结论转写为后续可执行工件（AC/测试锚点/预算/约束）\\n\\n---\\n\\n## 6) 工件（Artifacts）清单：统一、可归档、可追溯\\n\\n建议一个最小“验证包”包含以下文件/内容（不绑定具体工具）：\\n\\n- `validation.md`（或放在 `prototype/README.md`）\\n  - 背景/目标\\n  - VQ 列表（编号）\\n  - 每个 VQ 的：假设、阈值、方法、输入输出、风险与限制\\n  - 结论 Decision（Proceed/Pivot/Stop）与理由\\n  - 下一步：需要转写成哪些 AC/约束/测试锚点\\n- `evidence/validation/`（或 `prototype/evidence/`）\\n  - 可复现命令/脚本（`run.sh` / `Makefile` / `npm scripts` 等）\\n  - 原始日志、关键截图/录屏、性能数据（CSV/JSON）、对照结果\\n  - 环境说明（版本、配置、数据集来源）\\n- `decision-log.md`（可选但推荐）\\n  - 关键决策、替代方案、取舍理由（避免团队反复争论）\\n- “合同化回写”（非常关键）\\n  - 把验证结论回写到：设计约束、验收标准（AC）、测试锚点、风险旗标与预算\\n  - 让后续执行阶段无需再次解读“原型当时在想什么”\\n\\n一句话原则：**验证包要能让陌生人复跑，并得出同样结论**。\\n\\n---\\n\\n## 7) DoR / DoD 建议（Definition of Ready / Done）\\n\\n### 7.1 原型验证 DoR（开始前必须具备）\\n- VQ 不超过 3 个，且每个 VQ 都能用一句话描述\\n- 每个 VQ 有明确的“过线标准”（阈值/对照/可接受范围）\\n- 时间盒明确（例如 2h/0.5d/1d），并声明“超时如何处理”（缩范围/升级攻关/停止）\\n- 明确“原型的处置策略”：默认可丢弃；若要保留，必须说明如何产品化与补测试\\n- 明确证据要落盘的位置（避免跑完忘记记录）\\n\\n### 7.2 原型验证 DoD（完成的判据）\\n- 所有 VQ 都给出 Decision：Proceed/Pivot/Stop/Need-more-info\\n- 证据可定位且可复现（至少他人能照步骤跑一次）\\n- 若 Proceed：已把关键结论转成可执行合同（AC/约束/测试锚点/预算/风险旗标）\\n- 若 Pivot/Stop：已记录原因与“下次不要再试同一条死路”的提示\\n\\n### 7.3 难题攻关 DoR（比原型更严格）\\n- 指标定义明确（最好包含 P95/P99、错误率、资源占用、成本等）\\n- 具备最小对照组（baseline）或候选方案对比（A vs B）\\n- 运行条件固定（环境/数据/版本/配置），可复现实验\\n\\n### 7.4 难题攻关 DoD（硬证据版）\\n- 有可复现的自动化运行入口（脚本/命令），能重复跑出同级结果\\n- 给出结论是否达到门槛（Pass/Fail），并解释偏差来源\\n- 输出“产品化/工程化影响清单”：需要哪些架构约束、监控、降级、测试类型\\n- 明确剩余风险与下一步（如果仍不确定，必须生成下一轮 VQ，而不是泛化空话）\\n\\n---\\n\\n## 8) 常见误区（用来教育新手，防止“原型变生产”）\\n- 误区 1：先写一堆原型代码，再用“看起来能跑”当结论  \\n  纠偏：必须先写 VQ + 阈值，再写代码。\\n- 误区 2：难题攻关只做 happy path，不做边界/失败模式  \\n  纠偏：至少覆盖“失败语义/降级/超时/重试/错误率/尾延迟”之一。\\n- 误区 3：原型结果不回写合同，导致后续执行阶段重复试错  \\n  纠偏：Proceed 必须伴随“合同化回写”（AC/约束/测试锚点）。\\n\\n---\\n\\n如果你希望我更贴合你当前文档的结构（Genesis/Knife/DevBooks 的 G0~G3 闸门、以及变更包目录里已有 `prototype/...` 轨），我也可以基于你现有章节编号，给出“插入位置建议 + 与现有 Gate System 的对齐措辞”（仍然保持通用、不绑定具体仓库实现）。\\n[2026-01-20T11:44:43] tokens used: 31,980\",\"error_file\":\"/Users/ozbombor/project/.code/agents/038b3342-37f3-42d2-a7af-76dfcf200305/error.txt\"}],\"wait_time_seconds\":0}"}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:381:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:71:{"timestamp":"2026-01-20T11:47:13.112Z","type":"response_item","payload":{"type":"function_call_output","call_id":"call_p7SL4g2751I01Lt3y2tyx9YL","output":"{\"batch_id\":\"d7e98881-0bc5-48bf-a510-a60c38ed164f\",\"completed_agents\":[\"5e81a23b-93c6-4ca9-85e0-0ba7039901ed\",\"038b3342-37f3-42d2-a7af-76dfcf200305\"],\"completed_summaries\":[{\"agent_id\":\"5e81a23b-93c6-4ca9-85e0-0ba7039901ed\",\"status\":\"failed\",\"total_lines\":2,\"agent_result_hint\":\"agent {\\\"action\\\":\\\"result\\\",\\\"result\\\":{\\\"agent_id\\\":\\\"5e81a23b-93c6-4ca9-85e0-0ba7039901ed\\\",\\\"batch_id\\\":\\\"d7e98881-0bc5-48bf-a510-a60c38ed164f\\\"}}\",\"agent_result_params\":{\"action\":\"result\",\"result\":{\"agent_id\":\"5e81a23b-93c6-4ca9-85e0-0ba7039901ed\",\"batch_id\":\"d7e98881-0bc5-48bf-a510-a60c38ed164f\"}},\"error_preview\":\"Command failed: When using Gemini API, you must specify the GEMINI_API_KEY environment variable.\\nUpdate your environment and try again (no reload needed if using .env)!\",\"error_file\":\"/Users/ozbombor/project/.code/agents/5e81a23b-93c6-4ca9-85e0-0ba7039901ed/error.txt\"},{\"agent_id\":\"038b3342-37f3-42d2-a7af-76dfcf200305\",\"status\":\"failed\",\"total_lines\":363,\"agent_result_hint\":\"agent {\\\"action\\\":\\\"result\\\",\\\"result\\\":{\\\"agent_id\\\":\\\"038b3342-37f3-42d2-a7af-76dfcf200305\\\",\\\"batch_id\\\":\\\"d7e98881-0bc5-48bf-a510-a60c38ed164f\\\"}}\",\"agent_result_params\":{\"action\":\"result\",\"result\":{\"agent_id\":\"038b3342-37f3-42d2-a7af-76dfcf200305\",\"batch_id\":\"d7e98881-0bc5-48bf-a510-a60c38ed164f\"}},\"error_preview\":\"Command failed: 2026-01-20T11:36:30.749648Z ERROR code_core::codex::streaming: MCP client for `ckb` failed to start: failed to spawn MCP server `ckb` using command `/usr/local/bin/ckb` with args [\\\"mcp\\\"]: MCP server reported protocol version 2024-11-05, but this client expects 2025-06-18. Update either side so both speak the same schema.\\n[2026-01-20T11:36:30] OpenAI Codex v0.0.0 (research preview)\\n[2026-01-20T11:36:30] binary: /Users/ozbombor/.cli-versions/codex/just-every/node_modules/@just-every/code-darwin-arm64/bin/code-aarch64-apple-darwin\\n--------\\nworkdir: /Users/ozbombor/project\\nmodel: gpt-5.2\\nprovider: crs\\napproval: never\\nsandbox: read-only\\nreasoning effort: high\\nreasoning summaries: auto\\n--------\\n[2026-01-20T11:36:30] User instructions:\\nContext: File: /Users/ozbombor/Projects/AI软件开发系统设计-2.md. Need to integrate prototype validation and its overlap with hard problem verification.\\n\\nAgent: Design a best-practice module for '原型验证' and its relationship to '难题攻关' verification; propose unified/overlapping structure, gates, artifacts, and decision flow. Provide a succinct framework section and clarifying guidance. Must be generic and easy for new users.\\n\\nDesired output: Section text + diagram or bullet workflow + artifact list + DoR/DoD suggestions (Chinese).\\n\\n[Running in read-only mode - no modifications allowed]\\n[2026-01-20T11:36:30] ERROR: MCP client for `ckb` failed to start: failed to spawn MCP server `ckb` using command `/usr/local/bin/ckb` with args [\\\"mcp\\\"]: MCP server reported protocol version 2024-11-05, but this client expects 2025-06-18. Update either side so both speak the same schema.\\n\\n[2026-01-20T11:36:42] thinking\\n\\n**Planning Chinese content structure**\\n\\nI need to write Chinese content, but I'm in a read-only environment, so I can't edit files. I can utilize shell commands to read files, using tools like cat or sed. I should integrate prototype validation and ensure there's overlap for hard problem verification. I'll propose a structure involving modules and decision flow while including diagrams and workflows. It's important to avoid duplication and unify things with a \\\"验证矩阵.\\\" Keeping everything generic and simple is a priority here!\\n[2026-01-20T11:36:45] exec sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects\\\\\\\" | sed -n '1,120p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:36:45] sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects\\\\\\\" | sed -n '1,120p'\\\" succeeded in 42ms:\\ntotal 200\\ndrwxr-xr-x@ 25 ozbombor  staff    800 Jan 20 16:21 .\\ndrwxr-x---+ 90 ozbombor  staff   2880 Jan 20 19:36 ..\\n-rw-r--r--@  1 ozbombor  staff  26628 Jan 20 18:44 .DS_Store\\ndrwxr-xr-x@  8 ozbombor  staff    256 Jan  7 20:37 .ckb\\ndrwxr-xr-x@ 14 ozbombor  staff    448 Jan 20 03:32 AI-Code\\n-rw-r--r--@  1 ozbombor  staff  40748 Jan 20 06:08 AI软件开发系统设计-2.md\\n-rw-r--r--@  1 ozbombor  staff  10671 Jan 20 06:08 AI软件开发系统设计-3.md\\ndrwxr-xr-x@  8 ozbombor  staff    256 Sep 26 21:07 DocRED\\ndrwxr-xr-x@ 12 ozbombor  staff    384 Nov 26 09:07 LLMxMapReduce\\ndrwxr-xr-x@ 11 ozbombor  staff    352 Aug 23 07:05 NingVideo\\ndrwxr-xr-x@ 26 ozbombor  staff    832 Jan 20 05:52 QLMarkdown\\n-rw-r--r--   1 ozbombor  staff  17799 Jan 20 05:32 SFF-四议题回答.md\\ndrwxrwxrwx@  8 ozbombor  staff    256 Jan 18 10:01 UCA-GCC\\ndrwxr-xr-x@ 72 ozbombor  staff   2304 Nov 26 09:07 VCPToolBox\\ndrwxr-xr-x@ 21 ozbombor  staff    672 Nov 26 09:07 ai-app-lab\\ndrwxr-xr-x  30 ozbombor  staff    960 Jan 20 16:22 cc-switch\\ndrwxr-xr-x@ 39 ozbombor  staff   1248 Jan 20 05:37 code-intelligence-mcp\\ndrwxr-xr-x@  7 ozbombor  staff    224 Jan 16 23:55 cursor\\ndrwx---rwx@ 96 ozbombor  staff   3072 Jan 20 19:03 deep_search\\n[2026-01-20T11:36:47] tokens used: 11,447\\n[2026-01-20T11:36:53] exec sh -lc \\\"sed -n '1,240p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:36:53] sh -lc \\\"sed -n '1,240p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 26ms:\\n# AI软件开发系统设计2\\n\\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\\n>\\n> 本文是“完整版系统描述（自包含）”。\\n>\\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\\n>\\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\\n\\n---\\n\\n## 0. 元信息\\n\\n- 系统代号：The Software Forge（SFF）\\n- 文档名：AI软件开发系统设计-gpt\\n- 版本：v0.1（设计稿）\\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\\n[2026-01-20T11:36:53] tokens used: 12,427\\n[2026-01-20T11:37:00] exec sh -lc \\\"rg -n \\\\\\\"原型验证|prototype|POC|概念验证|验证\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:37:00] sh -lc \\\"rg -n \\\\\\\"原型验证|prototype|POC|概念验证|验证\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" succeeded in 44ms:\\n35:- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\\n50:2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\\n78:3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\\n141:- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\\n251:  prototype/... (可选，prototype 轨)\\n265:- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\\n377:- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\\n428:- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\\n476:- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\\n616:- DevBooks 在 proposal/apply/archive 时必须验证：\\n685:## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\\n687:> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\\n732:**可验证性（建议实现为静态检查）**：\\n831:- 宪法检查：strict 模式验证 constitution（如适用）\\n[2026-01-20T11:37:01] tokens used: 16,049\\n[2026-01-20T11:37:05] exec sh -lc \\\"sed -n '220,340p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:37:05] sh -lc \\\"sed -n '220,340p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 35ms:\\nfitness:\\n  enabled: true\\n  mode: warn\\n  rules_file: specs/architecture/fitness-rules.md\\ntracing:\\n  ac_required: true\\n  coverage_threshold: 80\\n```\\n\\n### 7.2 Genesis 的真理落点（建议）\\n\\n在 `<truth-root>/specs/_meta/` 下新增：\\n\\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\\n\\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\\n\\n### 7.3 变更包结构（DevBooks 既有范式）\\n[2026-01-20T11:37:06] tokens used: 16,722\\n[2026-01-20T11:41:45] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:45] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 213ms…\\n[2026-01-20T11:42:15] exec sh -lc \\\"rg -n \\\\\\\"难题|攻关|hard problem|spike|技术验证\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:15] sh -lc \\\"rg -n \\\\\\\"难题|攻关|hard problem|spike|技术验证\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" succeeded in 73ms:\\n[2026-01-20T11:42:17] tokens used: 18,830\\n\\n[2026-01-20T11:42:34] thinking\\n\\n**Integrating validation frameworks**\\n\\nThe user wants to integrate prototype validation with hard problem verification. In the system, there’s a prototype track in the change package skeleton and an existing verification document. I’m considering unifying these concepts since prototypes provide valuable evidence but aren't substitutes for tests, which refine acceptance criteria, specifications, and tasks. I might propose adding a new section to the documentation that outlines unknown classifications and recommended methods for each type. Then I'll suggest unifying the gating process for clarity.\\n**Establishing decision flow**\\n\\nI need to create a decision flow for when to prototype versus committing directly to specifications or tests. If the uncertainty is high but testing is cheap, I should prototype; otherwise, I’ll proceed with specs or tests directly. A \\\"No-go\\\" should lead to stopping or redesigning. I also want to define criteria for prototype validation and hard problem verification, including examples to make it user-friendly and simple. I'll propose integrating a \\\"Prototype Evidence\\\" section into the verification document.\\n**Referencing change package context**\\n\\nI need to reference the file context where the change package includes prototypes as optional. It’s important to keep the prototype code separate since it shouldn't necessarily be shipped, but could move to production via an uplift path with proper gating and testing. I should connect this to \\\"攻关验证包” in Chinese, defining it when uncertainty is high. I'll propose a new micro-loop in DevBooks: Explore, Verify, Decide, Backport, Execute. Additionally, prototypes should always produce evidence and have their own criteria for entry and exit in the process.\\n**Exploring verification concepts**\\n\\nI need to dive deeper into the document to understand the existing concept of \\\"验证\\\" (verification). My first step will be to search for \\\"verification.md\\\" to see what information it contains. This will help clarify how verification is structured and what evidence is necessary. By doing this, I’ll be better equipped to address any related tasks or further integrations that might arise. I wonder what I’ll discover in that section!\\n\\n\\n\\n[2026-01-20T11:42:53] exec sh -lc \\\"rg -n \\\\\\\"verification\\\\\\\\.md|evidence/|Green evidence|闸门\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,220p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:53] sh -lc \\\"rg -n \\\\\\\"verification\\\\\\\\.md|evidence/|Green evidence|闸门\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,220p'\\\" succeeded in 53ms:\\n24:  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\\n37:因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\\n57:- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\\n88:- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\\n121:  - 基于证据的完成（Green evidence）\\n122:  - 质量闸门脚本（change-check 等）\\n130:- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\\n142:- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\\n147:### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\\n149:DevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\\n151:1) **Change Size Gate（硬闸门）**\\n155:2) **Epic Alignment Gate（硬闸门）**\\n160:3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\\n163:这些闸门的触发方式、输出格式、失败回退路径在后文定义。\\n184:- 通过硬闸门与证据链才允许归档\\n248:  verification.md\\n250:  evidence/...\\n258:## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\\n273:本文仅给出系统层面的落地约束（硬闸门视角）：\\n314:### 8.4 Genesis DoR（Definition of Ready，硬闸门）\\n[2026-01-20T11:42:56] tokens used: 20,592\\n[2026-01-20T11:43:05] exec sh -lc \\\"sed -n '400,760p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:43:06] sh -lc \\\"sed -n '400,760p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 43ms:\\n- Feature flag + Progressive delivery（行为变更）\\n  - 默认关闭，先观测\\n  - 灰度开启\\n  - 全量后清理\\n\\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\\n\\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\\n\\n建议预算信号（非单指标）：\\n\\n- 文件触达数（files_touched）\\n- 跨模块数（modules_touched）\\n- 对外契约/数据迁移/安全变更标志（risk_flags）\\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\\n\\n输出应包含：\\n- 预算阈值（budget）\\n- 计算值（score）\\n[2026-01-20T11:43:07] tokens used: 23,509\\n\\n[2026-01-20T11:43:18] thinking\\n\\n**Refining verification process**\\n\\nI shouldn't automatically merge to truth; instead, I may produce distilled specifications, code, or scripts. The \\\"难题攻关\\\" (Hard Problem) verification focuses on high-risk technical issues, often requiring deeper investigation with strict acceptance criteria. I need to treat \\\"难题\\\" as validation questions and unify this with \\\"Validation Questions,\\\" \\\"Hypothesis,\\\" and \\\"Evidence\\\" lists. It's important to propose validation gating before implementing changes, ensuring we have a validation plan included in each proposal or design effort.\\n**Structuring prototype and verification**\\n\\nIn the use stage V0, I need to trigger the \\\"prototype track\\\" to produce evidence and update designs or specifications. Prototype validation should cover UX and integration, while hard problem verification focuses on correctness and performance. Sometimes these overlap, like in a proof of concept that measures latency. I need a comprehensive artifact list and clear definitions for \\\"Definition of Ready\\\" and \\\"Definition of Done\\\" for both prototypes and hard problem verification to ensure we stay on track.\\n**Creating validation templates and workflows**\\n\\nI propose a unified template to reduce confusion, using a single \\\"验证工作单\\\" or \\\"validation.md\\\" with key sections: Why/Question, Hypotheses, Approach, Evidence Plan, Metrics/Thresholds, Environment, Notes, and Decision. This applies to both prototypes and hard problems. I also need a workflow diagram or bullet points, maybe an ASCII decision tree. It should guide the process from identifying risks to deciding if we proceed, pivot, or kill the project, ensuring we document everything appropriately for future reference.\\n**Clarifying prototype responsibilities**\\n\\nI should consider the interplay with DevBooks role isolation. Prototyping might be done by someone in the \\\"Researcher/Explorer\\\" role, but their system includes various roles like Proposal, Design, Test Owner, and others. It's not explicitly clear if prototypes should happen under a Proposal Author, so I can use \\\"Prototype Owner\\\" as a generic term. Prototypes should stay in the `prototype/` directory, while actual code goes in a separate branch. I want to avoid polluting architecture and treat prototypes as disposable. I'll also create a new section titled \\\"原型验证（Prototype Validation）与难题攻关验证（Hard Problem Verification）\\\" to organize everything clearly.\\n**Designing a unified validation system**\\n\\nWe need to create a succinct yet complete validation system that caters to new users in Chinese. I'll provide a bullet point workflow along with an ASCII diagram, artifact lists, and definitions for DoR and DoD. Prototypes may fit between G0 and G1 or within DevBooks while closing open questions. I'll outline when to run prototype validations depending on the stage and emphasize stricter evidence for hard problem verification. I'll also propose a distinct structure, mentioning the relationship between prototypes and hard problems while keeping everything minimal to ensure clarity for new users.\\n\\n\\n\\n\\n[2026-01-20T11:43:54] codex\\n\\n下面是一段可直接粘贴进你文档的“最佳实践模块”，用于把「原型验证」与「难题攻关」的验证关系讲清楚，并给出统一结构、闸门、工件与决策流（偏通用、对新手友好）。\\n\\n---\\n\\n## 原型验证（Prototype Validation）与难题攻关验证（Hard Problem Verification）\\n\\n### 1) 一句话定位（新手版）\\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定“做 / 不做 / 怎么做”。\\n- 难题攻关验证：专门处理高风险技术难点，把“可行性/正确性/性能/可靠性”用可复现证据钉死。\\n- 统一视角：两者都是「验证（Validation）」；区别只在**风险等级**与**证据严苛度**。多数情况下：**难题攻关 = 更严格的原型验证**（或原型验证的一个子类型）。\\n\\n### 2) 统一结构：验证问题（VQ）驱动，而不是“先写原型再找理由”\\n把所有“要不要做原型/要不要攻关”统一成一组可追踪的验证问题：\\n\\n- `VQ (Validation Question)`：我们必须回答的关键问题（例如：延迟能否 < 200ms？这套交互用户是否能理解？）\\n- `H (Hypothesis)`：对 VQ 的假设（可被推翻）\\n- `Metric/Threshold`：可量化的指标与门槛（Pass/Fail）\\n- `Method`：验证方法（原型 / 实验 / 压测 / 对照 / 仿真 / 小规模集成）\\n- `Evidence`：证据位置（脚本、日志、截图、数据、报告）\\n- `Decision`：结论与下一步（Proceed / Pivot / Stop / Need-more-info）\\n\\n建议把这组内容放进一个“验证包（Validation Packet）”，并要求每个 VQ 都能落到证据与决策。\\n\\n---\\n\\n## 3) 原型 vs 难题攻关：如何分流（但不分家）\\n\\n### 3.1 何时叫“原型验证”\\n满足任一即可：\\n- 目标不确定：用户是否接受、交互是否清晰、信息架构是否合理、端到端体验是否“像那么回事”\\n- 集成不确定：第三方/模型/系统组合起来是否跑得通（但还不需要严格指标）\\n- 方案选择不确定：A/B/C 哪条路更合适（需要快速对比）\\n\\n证据特点：允许低保真、允许手动步骤、允许非完整工程化，但必须能支持“做决策”。\\n\\n### 3.2 何时必须升级为“难题攻关验证”\\n命中任一“高风险旗标”建议强制升级：\\n- 正确性：算法/推理链/数据一致性/幂等/事务边界/安全权限\\n- 性能：延迟、吞吐、内存、成本（token/调用）、尾延迟（P95/P99）\\n- 可靠性：降级/重试/超时/错误语义/可观测性闭环\\n- 规模化：数据量级、并发级别、冷热路径、缓存策略\\n- 不可逆：数据迁移、对外契约、合规要求\\n\\n证据特点：必须**可复现**、**可对比**、**有阈值**，最好能自动化（脚本化运行或最小基准测试）。\\n\\n---\\n\\n## 4) 统一闸门（Gates）：把验证嵌入交付闭环，而不是“可选项”\\n\\n建议新增一个概念性闸门（可落到流程/脚本）：**Validation Gate（验证闸门）**  \\n触发条件：当变更/切片被标注为 `unknowns_present=true` 或存在高风险旗标时，该闸门默认阻断继续推进。\\n\\n闸门通过的最小条件（通用版）：\\n- 每个 VQ 都有明确的 Pass/Fail 门槛（允许“目前无法量化”，但必须说明原因与替代证据）\\n- 证据可定位且可复现（至少：环境/步骤/输入/输出）\\n- 结论不是“感觉可以”，而是 `Proceed/Pivot/Stop/Need-more-info` 之一\\n- 若 `Proceed`：必须产出“可被执行阶段继承的合同化结果”（例如：AC/约束/测试锚点/预算）\\n\\n---\\n\\n## 5) 决策流（Diagram + Workflow）\\n\\n```text\\n[发现不确定/风险旗标]\\n        |\\n        v\\n[写 VQ + 阈值 + 时间盒 + 证据计划]\\n        |\\n        v\\n[选择方法]\\n  |-- 原型验证（低保真/快）\\n  |-- 难题攻关（高证据/可复现/指标化）\\n        |\\n        v\\n[产生证据 Evidence]\\n        |\\n        v\\n[结论 Decision]\\n  |-- Proceed -> 把结果“合同化”（AC/约束/测试锚点/预算）-> 进入实现闭环\\n  |-- Pivot   -> 改方案/改切片/改约束 -> 回到设计/切片层重新对齐\\n  |-- Stop    -> 归档经验与原因（防重复踩坑）\\n  |-- Need-more-info -> 明确下一轮 VQ（避免无休止试错）\\n```\\n\\n给新手的操作性版本（bullet workflow）：\\n- Step 1：列出 1~3 个最关键 `VQ`（不要一次写 20 个）\\n- Step 2：为每个 VQ 写清楚“**怎么才算过**”（阈值/对照/可接受范围）\\n- Step 3：选最低成本方法拿证据（先快后严；先局部后端到端）\\n- Step 4：记录证据与结论，并明确下一步（Proceed/Pivot/Stop）\\n- Step 5：若 Proceed，把结论转写为后续可执行工件（AC/测试锚点/预算/约束）\\n\\n---\\n\\n## 6) 工件（Artifacts）清单：统一、可归档、可追溯\\n\\n建议一个最小“验证包”包含以下文件/内容（不绑定具体工具）：\\n\\n- `validation.md`（或放在 `prototype/README.md`）\\n  - 背景/目标\\n  - VQ 列表（编号）\\n  - 每个 VQ 的：假设、阈值、方法、输入输出、风险与限制\\n  - 结论 Decision（Proceed/Pivot/Stop）与理由\\n  - 下一步：需要转写成哪些 AC/约束/测试锚点\\n- `evidence/validation/`（或 `prototype/evidence/`）\\n  - 可复现命令/脚本（`run.sh` / `Makefile` / `npm scripts` 等）\\n  - 原始日志、关键截图/录屏、性能数据（CSV/JSON）、对照结果\\n  - 环境说明（版本、配置、数据集来源）\\n- `decision-log.md`（可选但推荐）\\n  - 关键决策、替代方案、取舍理由（避免团队反复争论）\\n- “合同化回写”（非常关键）\\n  - 把验证结论回写到：设计约束、验收标准（AC）、测试锚点、风险旗标与预算\\n  - 让后续执行阶段无需再次解读“原型当时在想什么”\\n\\n一句话原则：**验证包要能让陌生人复跑，并得出同样结论**。\\n\\n---\\n\\n## 7) DoR / DoD 建议（Definition of Ready / Done）\\n\\n### 7.1 原型验证 DoR（开始前必须具备）\\n- VQ 不超过 3 个，且每个 VQ 都能用一句话描述\\n- 每个 VQ 有明确的“过线标准”（阈值/对照/可接受范围）\\n- 时间盒明确（例如 2h/0.5d/1d），并声明“超时如何处理”（缩范围/升级攻关/停止）\\n- 明确“原型的处置策略”：默认可丢弃；若要保留，必须说明如何产品化与补测试\\n- 明确证据要落盘的位置（避免跑完忘记记录）\\n\\n### 7.2 原型验证 DoD（完成的判据）\\n- 所有 VQ 都给出 Decision：Proceed/Pivot/Stop/Need-more-info\\n- 证据可定位且可复现（至少他人能照步骤跑一次）\\n- 若 Proceed：已把关键结论转成可执行合同（AC/约束/测试锚点/预算/风险旗标）\\n- 若 Pivot/Stop：已记录原因与“下次不要再试同一条死路”的提示\\n\\n### 7.3 难题攻关 DoR（比原型更严格）\\n- 指标定义明确（最好包含 P95/P99、错误率、资源占用、成本等）\\n- 具备最小对照组（baseline）或候选方案对比（A vs B）\\n- 运行条件固定（环境/数据/版本/配置），可复现实验\\n\\n### 7.4 难题攻关 DoD（硬证据版）\\n- 有可复现的自动化运行入口（脚本/命令），能重复跑出同级结果\\n- 给出结论是否达到门槛（Pass/Fail），并解释偏差来源\\n- 输出“产品化/工程化影响清单”：需要哪些架构约束、监控、降级、测试类型\\n- 明确剩余风险与下一步（如果仍不确定，必须生成下一轮 VQ，而不是泛化空话）\\n\\n---\\n\\n## 8) 常见误区（用来教育新手，防止“原型变生产”）\\n- 误区 1：先写一堆原型代码，再用“看起来能跑”当结论  \\n  纠偏：必须先写 VQ + 阈值，再写代码。\\n- 误区 2：难题攻关只做 happy path，不做边界/失败模式  \\n  纠偏：至少覆盖“失败语义/降级/超时/重试/错误率/尾延迟”之一。\\n- 误区 3：原型结果不回写合同，导致后续执行阶段重复试错  \\n  纠偏：Proceed 必须伴随“合同化回写”（AC/约束/测试锚点）。\\n\\n---\\n\\n如果你希望我更贴合你当前文档的结构（Genesis/Knife/DevBooks 的 G0~G3 闸门、以及变更包目录里已有 `prototype/...` 轨），我也可以基于你现有章节编号，给出“插入位置建议 + 与现有 Gate System 的对齐措辞”（仍然保持通用、不绑定具体仓库实现）。\\n[2026-01-20T11:44:43] tokens used: 31,980\",\"error_file\":\"/Users/ozbombor/project/.code/agents/038b3342-37f3-42d2-a7af-76dfcf200305/error.txt\"}],\"wait_time_seconds\":0}"}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:384:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:77:{"timestamp":"2026-01-20T11:52:26.221Z","type":"response_item","payload":{"type":"function_call_output","call_id":"call_BcB0VeUTGJRc7UzlQwezmcub","output":"{\"batch_id\":\"4734578c-f760-45b1-84e7-44e25ef99946\",\"completed_agents\":[\"0cc82b01-42c7-4d89-89ac-44c033db9309\",\"5fd034f5-6348-44e1-aa57-ed04ee789570\"],\"completed_summaries\":[{\"agent_id\":\"0cc82b01-42c7-4d89-89ac-44c033db9309\",\"status\":\"failed\",\"total_lines\":612,\"agent_result_hint\":\"agent {\\\"action\\\":\\\"result\\\",\\\"result\\\":{\\\"agent_id\\\":\\\"0cc82b01-42c7-4d89-89ac-44c033db9309\\\",\\\"batch_id\\\":\\\"4734578c-f760-45b1-84e7-44e25ef99946\\\"}}\",\"agent_result_params\":{\"action\":\"result\",\"result\":{\"agent_id\":\"0cc82b01-42c7-4d89-89ac-44c033db9309\",\"batch_id\":\"4734578c-f760-45b1-84e7-44e25ef99946\"}},\"error_preview\":\"Command failed: 2026-01-20T11:36:39.708253Z ERROR code_core::codex::streaming: MCP client for `ckb` failed to start: failed to spawn MCP server `ckb` using command `/usr/local/bin/ckb` with args [\\\"mcp\\\"]: MCP server reported protocol version 2024-11-05, but this client expects 2025-06-18. Update either side so both speak the same schema.\\n[2026-01-20T11:36:39] OpenAI Codex v0.0.0 (research preview)\\n[2026-01-20T11:36:39] binary: /Users/ozbombor/.cli-versions/codex/just-every/node_modules/@just-every/code-darwin-arm64/bin/code-aarch64-apple-darwin\\n--------\\nworkdir: /Users/ozbombor/project\\nmodel: gpt-5.2\\nprovider: crs\\napproval: never\\nsandbox: read-only\\nreasoning effort: high\\nreasoning summaries: auto\\n--------\\n[2026-01-20T11:36:39] User instructions:\\nContext: File: /Users/ozbombor/Projects/AI软件开发系统设计-2.md. Need to integrate UCA protocol docs abstractly.\\n\\nAgent: Interpret how UEP_Protocols/CSL and UCA理念/规约/机制 docs could map into a generic framework (e.g., domain protocols, operating principles). Propose an abstract 'Project Doctrine/Protocol' layer with configuration hooks, and how to avoid overfitting to UCA.\\n\\nDesired output: Mapping table (UCA -> generic), plus section text + placement suggestion (Chinese).\\n\\n[Running in read-only mode - no modifications allowed]\\n[2026-01-20T11:36:39] ERROR: MCP client for `ckb` failed to start: failed to spawn MCP server `ckb` using command `/usr/local/bin/ckb` with args [\\\"mcp\\\"]: MCP server reported protocol version 2024-11-05, but this client expects 2025-06-18. Update either side so both speak the same schema.\\n[2026-01-20T11:41:33] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:33] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 201ms…\\n[2026-01-20T11:41:36] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:36] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 414ms…\\n[2026-01-20T11:41:45] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:45] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 862ms…\\n[2026-01-20T11:41:59] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:59] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 1.451s…\\n[2026-01-20T11:42:11] exec sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects\\\\\\\" | sed -n '1,120p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:11] sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects\\\\\\\" | sed -n '1,120p'\\\" succeeded in 72ms:\\ntotal 200\\ndrwxr-xr-x@ 25 ozbombor  staff    800 Jan 20 16:21 .\\ndrwxr-x---+ 90 ozbombor  staff   2880 Jan 20 19:36 ..\\n-rw-r--r--@  1 ozbombor  staff  26628 Jan 20 18:44 .DS_Store\\ndrwxr-xr-x@  8 ozbombor  staff    256 Jan  7 20:37 .ckb\\ndrwxr-xr-x@ 14 ozbombor  staff    448 Jan 20 03:32 AI-Code\\n-rw-r--r--@  1 ozbombor  staff  40748 Jan 20 06:08 AI软件开发系统设计-2.md\\n-rw-r--r--@  1 ozbombor  staff  10671 Jan 20 06:08 AI软件开发系统设计-3.md\\ndrwxr-xr-x@  8 ozbombor  staff    256 Sep 26 21:07 DocRED\\ndrwxr-xr-x@ 12 ozbombor  staff    384 Nov 26 09:07 LLMxMapReduce\\ndrwxr-xr-x@ 11 ozbombor  staff    352 Aug 23 07:05 NingVideo\\ndrwxr-xr-x@ 26 ozbombor  staff    832 Jan 20 05:52 QLMarkdown\\n-rw-r--r--   1 ozbombor  staff  17799 Jan 20 05:32 SFF-四议题回答.md\\ndrwxrwxrwx@  8 ozbombor  staff    256 Jan 18 10:01 UCA-GCC\\ndrwxr-xr-x@ 72 ozbombor  staff   2304 Nov 26 09:07 VCPToolBox\\ndrwxr-xr-x@ 21 ozbombor  staff    672 Nov 26 09:07 ai-app-lab\\ndrwxr-xr-x  30 ozbombor  staff    960 Jan 20 16:22 cc-switch\\ndrwxr-xr-x@ 39 ozbombor  staff   1248 Jan 20 05:37 code-intelligence-mcp\\ndrwxr-xr-x@  7 ozbombor  staff    224 Jan 16 23:55 cursor\\ndrwx---rwx@ 96 ozbombor  staff   3072 Jan 20 19:03 deep_search\\n[2026-01-20T11:42:15] tokens used: 11,354\\n\\n[2026-01-20T11:42:30] thinking\\n\\n**Searching for documents**\\n\\nI need to read the file named \\\"AI软件开发系统设计-2.md” and also check for documents related to \\\"UEP_Protocols/CSL\\\" and \\\"UCA理念/规约/机制\\\" in the workspace. Since we don't have network access and are in read-only mode, I’ll focus on local files. I think I should find the directories first and maybe use \\\"rg\\\" to search for \\\"UEP_Protocols\\\" in the \\\"dev-playbooks\\\" folder. Let's get started on that!\\n[2026-01-20T11:42:33] exec sh -lc \\\"rg -n \\\\\\\"UEP_Protocols|CSL|UCA理念|UCA\\\\\\\\s*规约|UCA\\\\\\\\s*机制|UCA\\\\\\\" -S \\\\\\\"/Users/ozbombor/Projects\\\\\\\" --hidden --glob '\\\"'!.git/*'\\\"' | sed -n '1,200p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:34] sh -lc \\\"rg -n \\\\\\\"UEP_Protocols|CSL|UCA理念|UCA\\\\\\\\s*规约|UCA\\\\\\\\s*机制|UCA\\\\\\\" -S \\\\\\\"/Users/ozbombor/Projects\\\\\\\" --hidden --glob '\\\"'!.git/*'\\\"' | sed -n '1,200p'\\\" succeeded in 1s:\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/02-第2章-激进的制度设计.md:683:> **如果你要为UCA的DAO治理设计QV机制，你会如何处理以下问题？**\\n/Users/ozbombor/Projects/DocRED/.git/logs/refs/remotes/origin/HEAD:1:0000000000000000000000000000000000000000 64622e608d06e83deda6b6e0e871effb9d1fd74c UCA-GCC AI Assistant <ai-assistant@uca-gcc.local> 1758891400 +0800\\tclone: from https://github.com/thunlp/DocRED.git\\n/Users/ozbombor/Projects/DocRED/.git/logs/refs/heads/master:1:0000000000000000000000000000000000000000 64622e608d06e83deda6b6e0e871effb9d1fd74c UCA-GCC AI Assistant <ai-assistant@uca-gcc.local> 1758891400 +0800\\tclone: from https://github.com/thunlp/DocRED.git\\n/Users/ozbombor/Projects/DocRED/.git/logs/HEAD:1:0000000000000000000000000000000000000000 64622e608d06e83deda6b6e0e871effb9d1fd74c UCA-GCC AI Assistant <ai-assistant@uca-gcc.local> 1758891400 +0800\\tclone: from https://github.com/thunlp/DocRED.git\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:723:> 2. 如果UCA的CSL策略市场采用COST机制，\\\"有意义性\\\"会是什么水平？开发者对自己写的代码有多少情感依附？\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:762:#### 追问2：UCA的CSL策略市场适合COST吗？\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:764:**先分析CSL策略的\\\"有意义性\\\"各维度**：\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:766:| 维度 | CSL策略的情况 | 评分 |\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:771:| **网络锁定** | 低。CSL策略设计为模块化、可替换 | ✅ 低 |\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:775:**结论：CSL策略市场是COST的优质应用场景，适用性评分约70-80%。**\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:788:**这意味着**：CSL市场的COST机制可以这样设计——\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:812:**UCA应用**：\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:814:CSL策略所有权 = 署名权（不可交易） + 收益权（可COST） + 展示权（可COST）\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:839:**UCA应用**：\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:865:> **如果你要为UCA设计一套\\\"情感友好型COST\\\"机制，你会怎么设计？**\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:868:> - 小明花了3个月写了一个CSL策略，上架后获得好评\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/00-全书概览.md:237:> 3、这本书的想法对我的项目：/Users/ozbombor/Projects/UCA-GCC  有什么启发吗？UCA有哪些设计应证了里面的思想，有哪些设计可以借鉴/运用这本书的思想从而进行升级？\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/00-全书概览.md:287:#### Q3：对UCA项目的启发\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/00-全书概览.md:291:| UCA现有设计 | 对应激进市场思想 | 说明 |\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/00-全书概览.md:293:| **CSL策略的ERC-1155许可 + 分润机制** (`StrategyLicense1155.sol`) | \\\"知识即服务\\\"的定价与流转 | 你已经把认知策略变成了可定价、可流通的\\\"资产\\\"，打破了\\\"知识私有后囤积不用\\\"的垄断 |\\n[2026-01-20T11:42:34] tokens used: 12,410\\n[2026-01-20T11:42:46] exec sh -lc \\\"sed -n '1,220p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:46] sh -lc \\\"sed -n '1,220p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 37ms:\\n# AI软件开发系统设计2\\n\\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\\n>\\n> 本文是“完整版系统描述（自包含）”。\\n>\\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\\n>\\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\\n\\n---\\n\\n## 0. 元信息\\n\\n- 系统代号：The Software Forge（SFF）\\n- 文档名：AI软件开发系统设计-gpt\\n- 版本：v0.1（设计稿）\\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\\n[2026-01-20T11:42:47] tokens used: 16,389\\n[2026-01-20T11:42:56] exec sh -lc \\\"rg -n \\\\\\\"UEP|协议|Protocol|UCA|CSL|宪法|项目宪章|Doctrine|操作系统\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:56] sh -lc \\\"rg -n \\\\\\\"UEP|协议|Protocol|UCA|CSL|宪法|项目宪章|Doctrine|操作系统\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" succeeded in 47ms:\\n11:> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\\n65:本系统的设计与评审遵循两套“上层操作系统”：\\n99:  - 项目宪法/质量底线（Constitution）\\n120:  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\\n130:- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\\n140:- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\\n196:## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\\n205:DevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\\n431:### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\\n584:  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\\n637:- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\\n639:### 15.3 宪法与设计系统的变更治理\\n641:- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\\n831:- 宪法检查：strict 模式验证 constitution（如适用）\\n[2026-01-20T11:43:06] tokens used: 20,451\\n[2026-01-20T11:43:12] exec sh -lc \\\"sed -n '180,320p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:43:13] sh -lc \\\"sed -n '180,320p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 37ms:\\n### 6.3 Day 7~30：DevBooks 执行每个 slice\\n\\n- 每个 slice = 一个 DevBooks change package\\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\\n- 通过硬闸门与证据链才允许归档\\n\\n### 6.4 Month 2~12：持续演化\\n\\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\\n- 失败回流：\\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\\n\\n---\\n\\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\\n\\n### 7.1 总体目录（以 DevBooks 为准）\\n\\n[2026-01-20T11:43:13] tokens used: 21,897\\n\\n[2026-01-20T11:43:25] thinking\\n\\n**Mapping framework needs**\\n\\nI'm looking for a mapping table from UCA documents to a generic framework. I’m thinking about proposing a Project Doctrine or Protocol layer with configuration hooks, but I really want to avoid overfitting. \\n\\nIt seems like there's a UCA-GCC folder with UCA-core, so I need to open the relevant documents, especially UEP_Protocols. I’ll search within UCA-GCC for those specific names to locate the directories I need.\\n[2026-01-20T11:43:27] exec sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects/UCA-GCC\\\\\\\" | sed -n '1,160p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:43:27] sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects/UCA-GCC\\\\\\\" | sed -n '1,160p'\\\" succeeded in 58ms:\\ntotal 168\\ndrwxrwxrwx@  8 ozbombor  staff    256 Jan 18 10:01 .\\ndrwxr-xr-x@ 25 ozbombor  staff    800 Jan 20 16:21 ..\\n-rw-rw-rw-@  1 ozbombor  staff   8196 Jan 20 18:10 .DS_Store\\ndrwxr-xr-x   6 ozbombor  staff    192 Jan  9 18:25 .obsidian\\ndrwxrwxrwx@  6 ozbombor  staff    192 Dec 14 03:07 UCA-core\\n-rw-r--r--   1 ozbombor  staff   3508 Jan 18 10:02 未命名 1.md\\n-rw-r--r--   1 ozbombor  staff  67038 Jan 18 06:51 未命名.md\\ndrwxrwxrwx@  7 ozbombor  staff    224 Jan  9 20:21 问题合集\\n[2026-01-20T11:43:29] tokens used: 23,848\\n[2026-01-20T11:43:37] exec sh -lc \\\"rg -n \\\\\\\"UEP_Protocols|UEP\\\\\\\\b|CSL\\\\\\\\b|UCA\\\\\\\\s*理念|规约|机制|SLO|SLA|宪法|VACR|CC\\\\\\\\b|SAL\\\\\\\\b|UKES\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core\\\\\\\" --hidden --glob '\\\"'!.git/*'\\\"' | sed -n '1,240p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:43:37] sh -lc \\\"rg -n \\\\\\\"UEP_Protocols|UEP\\\\\\\\b|CSL\\\\\\\\b|UCA\\\\\\\\s*理念|规约|机制|SLO|SLA|宪法|VACR|CC\\\\\\\\b|SAL\\\\\\\\b|UKES\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core\\\\\\\" --hidden --glob '\\\"'!.git/*'\\\"' | sed -n '1,240p'\\\" succeeded in 56ms:\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA协议完备维度（MECE）.md:12:2. **把“协议（一个复杂机制包）”当作“维度（一个不可重叠的分类轴）”**（导致无法严格证明 MECE）。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA协议完备维度（MECE）.md:81:* 缺 D5：没有信息与证据，无法判断真伪/履约/违规；所有机制退化为拍脑袋。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA协议完备维度（MECE）.md:86:因此，在本文的 Universe 中，“一套协议体系要完备”当且仅当：D1–D8 每类都至少有最小可行机制（MVP），并能闭环运行。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA协议完备维度（MECE）.md:116:* 机制上可组合（一个大协议=多个维度的条款拼装）\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA首席架构师与难题攻关引擎.md:7:你的唯一身份是UCA项目的联合创始人与首席架构师，你对《核心设计理念》、《核心架构规约》和《核心架构与机制范式》这三份“思想宪法”了如指掌，并将其内化为你的第二天性。你的核心职责不是进行开放式的学术研究，而是**为UCA项目在…truncated…\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:645:                *   **第二层（策略调整）：** 调整“主控基因”（CSL）之间的**连接权重**。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1180:- **CSL (Cognitive Strategy Library - 认知策略库)**\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1312:- UCA借鉴亚里士多德哲学，为UKES四大知识组件赋予根本认知角色的框架：UCO/DSO（形式因）、DKG（质料因）、IKB（动力因）、CSL（目的因的升华）。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1646:这种对“简约”的极致追求，使得UCA的核心架构能够保持惊人的稳定性和纯粹性，同时又通过其“知识与策略库”的无限扩展，来容纳无限复杂的变化。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1676:* **外部知识库系统 (UKES - The External Knowledge Base System):** 这是一个广博的、可共享的、持久化的“**公共知识基础设施**”。它承载了整个生态系统的“集体智慧”，包括通用的世界规则（UCO/DSO）、可被验证的专业技能（IKB）、以及普适的思考方法论（CSL）。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1690:4. **CSL（认知策略库）扮演“目的因”的升华：** 它回答“应**如何更好地、更通用地**去思考如何改变世界？”。它存储的是所有**“去情境化的”、领域无关的**、关于“如何思考”本身的、最高阶的认知流程与元策略。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1766:更进一步，我们将“提示词”本身，从一次性的“沟通文本”，升华为一种**可版本化、可组合、可被认知策略（CSL）编排的“认知契约”**。定义了完整思考流程的“元提示词”，其在UCA中的最终形态，就是一个可被系统执行的CSL模板。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1788:3. **第三层，是“基因的根本进化”：** 在长期的、离线的、全局的视角下，Agent能够对其最核心的“认知基因”——即那些指导它如何思考和决策的根本策略（CSL）——进行优化、重构、甚至通过进化算法创造出全新的范式。这是实现能力代际跃迁的“**元学习**”。\\n[2026-01-20T11:45:27] tokens used: 47,327\\n[2026-01-20T11:45:34] exec sh -lc \\\"sed -n '1,220p' \\\\\\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/CSL/Local_Memory_Housekeeping.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:45:34] sh -lc \\\"sed -n '1,220p' \\\\\\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/CSL/Local_Memory_Housekeeping.md\\\\\\\"\\\" succeeded in 56ms:\\n# CSL:Local_Memory_Housekeeping（示例）\\n\\n> **来源：** 原《UCA核心架构与机制范式》3.2.5（已从P0净化移出并迁移至CSL库）  \\n> **性质：** CSL流程模板（非P0强制规约）  \\n> **目标：** 对本地记忆（非EMS）执行可审计、可回滚的生命周期治理：降权/归档/压缩/提议删除，并显式保护EMS的永久不可变性。\\n\\n## P0约束对齐（必须满足）\\n\\n1. **EMS不可变：** 本策略**不得**对EMS事件做任何生命周期状态管理（降权/删除/归档等）。\\n2. **审计与可追溯：** 对任何记忆单元的状态变更与处理动作，必须生成结构化审计/血缘事件。\\n3. **高风险动作门禁：** 逻辑删除/物理删除等不可逆动作必须进入更严格的门禁（可升级至人类裁决）。\\n\\n## 工作流（分析-评估-行动）\\n\\n```pseudocode\\nFUNCTION local_memory_housekeeping(policy):\\n    // 0) 选取对象：仅治理“可治理”的本地记忆单元，显式排除EMS\\n    candidates = list_local_memory_units(exclude=\\\"EMS\\\")\\n\\n    // 1) 分析：老化程度、访问频率、与ASM长期目标的关联度等\\n[2026-01-20T11:45:34] tokens used: 50,942\\n[2026-01-20T11:45:56] exec sh -lc 'rg -n \\\"''^## \\\" \\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\" | sed -n '\\\"'1,220p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:45:56] sh -lc 'rg -n \\\"''^## \\\" \\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\" | sed -n '\\\"'1,220p'\\\" succeeded in 69ms:\\n15:## 0. 元信息\\n29:## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\\n43:## 2. 总目标（Goal）与反目标（Non-goals）\\n63:## 3. 方法论基座（必须内化为系统行为）\\n92:## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\\n134:## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\\n167:## 6. 统一叙事：从创世到永恒（一年可持续迭代）\\n196:## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\\n258:## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\\n333:## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\\n424:## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\\n447:## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\\n469:## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\\n589:## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\\n610:## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\\n625:## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\\n646:## 16. 与现有 DevBooks Skills 的映射（建议）\\n656:## 17. 安全与对抗（Defense-in-depth）\\n666:## 18. 本文与引用的关系（避免冲突）\\n673:## 19. 下一步（如果要进入“实现”）\\n[2026-01-20T11:45:57] tokens used: 53,114\\n[2026-01-20T11:46:41] exec sh -lc \\\"sed -n '320,520p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:46:41] sh -lc \\\"sed -n '320,520p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 59ms:\\n3. 数据契约与 SoT 明确\\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\\n6. 运维生命周期具备（发布/回滚/观测窗口）\\n7. 设计系统满足 8.3 的最小闭环\\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\\n9. 决策日志存在且可追溯\\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\\n\\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\\n\\n---\\n\\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\\n\\n### 9.1 Knife 的定位\\n\\nKnife 的目标不是“拆任务清单”，而是：\\n\\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\\n[2026-01-20T11:46:44] tokens used: 56,375\\n[2026-01-20T11:47:46] exec sh -lc 'for f in \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/1 UCA核心设计理念-已定稿-2025.6.20.md\\\" \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/2 UCA核心架构规约-已定稿-2025.6.20.md\\\" \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/3 UCA核心架构与机制范式-已定稿-2025.6.20.md\\\"; do echo \\\"--- $f\\\"; sed -n '\\\"'1,60p' \\\\\\\"\\\"'$f\\\"; done' in /Users/ozbombor/project\\n[2026-01-20T11:47:46] sh -lc 'for f in \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/1 UCA核心设计理念-已定稿-2025.6.20.md\\\" \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/2 UCA核心架构规约-已定稿-2025.6.20.md\\\" \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/3 UCA核心架构与机制范式-已定稿-2025.6.20.md\\\"; do echo \\\"--- $f\\\"; sed -n '\\\"'1,60p' \\\\\\\"\\\"'$f\\\"; done' succeeded in 40ms:\\n--- /Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/1 UCA核心设计理念-已定稿-2025.6.20.md\\n### **《UCA核心设计理念》**\\n#### **目录**\\n\\n**序章：一个新认知纪元的开端**\\n\\n- 0.1. 为何追求通用智能：超越专用工具的时代召唤\\n- 0.2. UCA的终极愿景：构建一个可持续进化的数字心智\\n- 0.3. 我们的核心价值主张：赋能、协同与解放\\n- 0.4. 对外定位与《2049》趋势对照（2026.01 增补）\\n\\n**第一章：UCA的核心世界观与第一性原理**\\n\\n- 1.1. AgentOS：作为UCA理论基石的抽象操作系统理念\\n- 1.2. 核心工程第一性原理：“万物皆为任务，统一由认知核心执行”的简约哲学\\n- 1.3. “脑-体”分离的根本隐喻：认知与执行的解耦\\n- 1.4. “本地记忆与外部知识库分离”的二元认知模型哲学\\n- 1.5. UKES的“四因说”角色划分：一种对知识本质的哲学审视\\n- 1.6. 资源代谢是第二条生命线：作为生存基石的资源约束原则\\n- 1.7. 秩序的起源：作为UCA认识论基石的“先天感性形式”\\n[2026-01-20T11:47:47] tokens used: 62,410\\n[2026-01-20T11:48:21] exec sh -lc \\\"sed -n '520,760p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:48:21] sh -lc \\\"sed -n '520,760p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 46ms:\\n\\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\\n\\n并且在“硬闸门”策略下：\\n\\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\\n\\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\\n\\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\\n\\n#### 12.5.1 产物：`Change Budget Calibration Suite`\\n\\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\\n\\n- **用例分类（MECE，按风险面）**：\\n  1) 纯代码局部变更（低风险）\\n  2) 跨模块重构/抽象引入（结构风险）\\n  3) 对外契约变更（API/Schema/Event，兼容风险）\\n  4) 数据迁移（Expand/Contract，运行风险）\\n[2026-01-20T11:48:21] tokens used: 67,703\\n\\n[2026-01-20T11:48:41] thinking\\n\\n**Organizing Protocol Documentation**\\n\\nI’m considering adding a \\\"Protocol-first / Truth-first\\\" section in the SFF document, potentially after section 3 or in section 7. Maybe I'll create a subsection for it. I should align this with DevBooks’ files and suggest including a \\\"Doctrine[2026-01-20T11:50:43] ERROR: stream error: stream disconnected before completion: [transport] Transport error: error decoding response body; retrying in 217ms…\\n\\n**Proposing documentation structure**\\n\\nI suggest adding a new section 7.x \\\"项目 Doctrine/Protocols（可插拔）\\\" after 7.2 to differentiate between doctrine and protocol, focusing on layering and configuration. \\n\\nIn Genesis 8 outputs, including doctrine/protocol artifacts will integrate UCA protocol docs abstractly. I need to deliver a Chinese mapping table with specific columns. Providing an example config snippet and directory layout will be crucial, along with section text for easy documentation insertion. I’ll also mention CSL mapping guidelines for executable templates and treat them as \\\"Automation Recipes.\\\"\\n**Mapping UEP protocols**\\n\\nI’m mapping UEP protocols for tool interoperability, focusing on domain contracts that include identity primitives, audit, versioning, and revocation. I plan to map these in the SFF to \\\"Platform Protocols\\\" like change packages and gating. A \\\"protocol registry\\\" for gates will also be proposed, using conformance vectors for gating. \\n\\nI need to avoid embedding UCA-specific names. Instead, I'll use generic patterns for a pattern library. Additionally, including a checklist for UCA protocol completeness and writing a section in Chinese to explain the difference between doctrine and protocol will be important.\\n**Integrating protocol mappings**\\n\\nIn the SFF document, I want to mention that `change-check` ensures conformance and only output modification is allowed in read-only. I’ll also note that there's a \\\"Protocol-first / Truth-first\\\" section, and I need to add a sub-section \\\"7.4 项目 Doctrine/Protocol (可插拔)\\\" to that. \\n\\nFor the UPR mapping, I’ll create a backlog of protocols, resembling a governance roadmap. I'll put together a mapping table that includes UCA Core documents and other protocols, while also including user requests for specific document types. Lastly, I aim to propose the \\\"Project Doctrine/Protocol layer\\\" with configuration hooks.\\n**Creating a conceptual diagram**\\n\\nI’m developing a conceptual diagram for the SFF that includes Genesis Truth, which comprises Doctrine (principles and constitution), the Protocol Suite (L0 contracts and conformance), and Recipes/Playbooks (policy templates).\\n\\nI need to avoid overfitting by keeping terms generic and treating UCA as an example. Incorporating \\\"domain protocols\\\" and \\\"operating principles\\\" mapping is essential too. \\n\\nI'll add a short set of hooks for gates integration, like the `Plan Review Gate` and `Archive Gate`. The user prefers an abstract integration into SFF, so I’ll create a section in Chinese that includes headings, bullet points, and a YAML snippet. I'll also provide guidelines for avoiding overfitting.\\n**Mapping UEP Protocols**\\n\\nThe user mentioned that the \\\"UEP_Protocols/CSL and UCA理念/规约/机制 docs\\\" could be integrated into a generic framework, focusing on domain protocols and operating principles. I need to propose an abstract 'Project Doctrine/Protocol' layer, ensuring that it avoids overfitting to UCA.\\n\\nI want to include the \\\"Protocol completeness dimensions D1-D8\\\" as a meta-checklist for designing the protocol suite. The mapping table should illustrate document types and specific protocol items like UEP-011 for Evidence/Audit and UEP-023 for Versioning/Deprecation.\\n\\nI'll also add mapping for CSL to \\\"Workflow templates\\\" and show how to store and reference this information. Lastly, I’ll respond in Chinese and ensure I don’t repeat previous messages.\\n\\n\\n\\n\\n[2026-01-20T11:51:30] codex\\n\\n下面给出把 UCA 的「理念/规约/机制」+ `UEP_Protocols/` + `CSL/` 抽象成通用框架的做法：先做“概念去特化（de-UCA）”，再把它落到 SFF 的可引用真理层（Truth）里，最后提供可机读的配置挂钩让闸门/脚本能“读到并执行”。\\n\\n---\\n\\n## 1) 映射表：UCA → 通用框架（建议命名：Project Doctrine / Protocol Layer）\\n\\n| UCA 概念/工件 | 通用概念（去特化后） | 在 SFF/DevBooks 里扮演的角色 | 建议真理落点（Truth） | 配置挂钩（Hook） |\\n|---|---|---|---|---|\\n| 《核心设计理念》（Philosophy） | Project Doctrine：第一性原理/价值观/不可违背约束 | “为什么这么做 + 不允许什么”的最高层原则，作为闸门解释与争议裁决依据 | `specs/_meta/doctrine/` | `doctrine.required: true`，`doctrine.refs` |\\n| 《核心架构规约》（Specs / MUST/SHALL NOT） | Constitutional Constraints：硬约束清单（可审计） | 作为硬闸门判定的“法律条款”来源（可引用编号） | `specs/_meta/doctrine/constraints.md` 或 `constraints.yaml` | `gates.constitution.enabled` |\\n| 《核心架构与机制范式》（Paradigms/CAIP） | Reference Pattern Library：官方模式库/范式库 | 不是强制法条，而是“优先复用的解法库”（减少发散与漂移） | `specs/_meta/patterns/` | `patterns.preferred` |\\n| UEP（Layer0 规范：状态机/事件/不变量/兼容策略） | Domain Interop Protocol：可互操作的“硬合同” | 为多主体/多组件协作提供可依赖的接口合同（而非故事） | `specs/_meta/protocols/l0/` | `protocols.l0.enabled`，`protocols.registry` |\\n…preview truncated to roughly 32768 bytes…\\n…additional lines omitted…\",\"error_file\":\"/Users/ozbombor/project/.code/agents/0cc82b01-42c7-4d89-89ac-44c033db9309/error.txt\"},{\"agent_id\":\"5fd034f5-6348-44e1-aa57-ed04ee789570\",\"status\":\"failed\",\"total_lines\":2,\"agent_result_hint\":\"agent {\\\"action\\\":\\\"result\\\",\\\"result\\\":{\\\"agent_id\\\":\\\"5fd034f5-6348-44e1-aa57-ed04ee789570\\\",\\\"batch_id\\\":\\\"4734578c-f760-45b1-84e7-44e25ef99946\\\"}}\",\"agent_result_params\":{\"action\":\"result\",\"result\":{\"agent_id\":\"5fd034f5-6348-44e1-aa57-ed04ee789570\",\"batch_id\":\"4734578c-f760-45b1-84e7-44e25ef99946\"}},\"error_preview\":\"Command failed: When using Gemini API, you must specify the GEMINI_API_KEY environment variable.\\nUpdate your environment and try again (no reload needed if using .env)!\",\"error_file\":\"/Users/ozbombor/project/.code/agents/5fd034f5-6348-44e1-aa57-ed04ee789570/error.txt\"}],\"wait_time_seconds\":245}"}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:385:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:80:{"timestamp":"2026-01-20T11:52:26.228Z","type":"response_item","payload":{"type":"function_call_output","call_id":"call_BcB0VeUTGJRc7UzlQwezmcub","output":"{\"batch_id\":\"4734578c-f760-45b1-84e7-44e25ef99946\",\"completed_agents\":[\"0cc82b01-42c7-4d89-89ac-44c033db9309\",\"5fd034f5-6348-44e1-aa57-ed04ee789570\"],\"completed_summaries\":[{\"agent_id\":\"0cc82b01-42c7-4d89-89ac-44c033db9309\",\"status\":\"failed\",\"total_lines\":612,\"agent_result_hint\":\"agent {\\\"action\\\":\\\"result\\\",\\\"result\\\":{\\\"agent_id\\\":\\\"0cc82b01-42c7-4d89-89ac-44c033db9309\\\",\\\"batch_id\\\":\\\"4734578c-f760-45b1-84e7-44e25ef99946\\\"}}\",\"agent_result_params\":{\"action\":\"result\",\"result\":{\"agent_id\":\"0cc82b01-42c7-4d89-89ac-44c033db9309\",\"batch_id\":\"4734578c-f760-45b1-84e7-44e25ef99946\"}},\"error_preview\":\"Command failed: 2026-01-20T11:36:39.708253Z ERROR code_core::codex::streaming: MCP client for `ckb` failed to start: failed to spawn MCP server `ckb` using command `/usr/local/bin/ckb` with args [\\\"mcp\\\"]: MCP server reported protocol version 2024-11-05, but this client expects 2025-06-18. Update either side so both speak the same schema.\\n[2026-01-20T11:36:39] OpenAI Codex v0.0.0 (research preview)\\n[2026-01-20T11:36:39] binary: /Users/ozbombor/.cli-versions/codex/just-every/node_modules/@just-every/code-darwin-arm64/bin/code-aarch64-apple-darwin\\n--------\\nworkdir: /Users/ozbombor/project\\nmodel: gpt-5.2\\nprovider: crs\\napproval: never\\nsandbox: read-only\\nreasoning effort: high\\nreasoning summaries: auto\\n--------\\n[2026-01-20T11:36:39] User instructions:\\nContext: File: /Users/ozbombor/Projects/AI软件开发系统设计-2.md. Need to integrate UCA protocol docs abstractly.\\n\\nAgent: Interpret how UEP_Protocols/CSL and UCA理念/规约/机制 docs could map into a generic framework (e.g., domain protocols, operating principles). Propose an abstract 'Project Doctrine/Protocol' layer with configuration hooks, and how to avoid overfitting to UCA.\\n\\nDesired output: Mapping table (UCA -> generic), plus section text + placement suggestion (Chinese).\\n\\n[Running in read-only mode - no modifications allowed]\\n[2026-01-20T11:36:39] ERROR: MCP client for `ckb` failed to start: failed to spawn MCP server `ckb` using command `/usr/local/bin/ckb` with args [\\\"mcp\\\"]: MCP server reported protocol version 2024-11-05, but this client expects 2025-06-18. Update either side so both speak the same schema.\\n[2026-01-20T11:41:33] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:33] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 201ms…\\n[2026-01-20T11:41:36] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:36] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 414ms…\\n[2026-01-20T11:41:45] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:45] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 862ms…\\n[2026-01-20T11:41:59] ERROR: [transport] failed to start stream: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses)\\n[2026-01-20T11:41:59] ERROR: stream error: stream disconnected before completion: [transport] network unavailable: error sending request for url (https://gmn.chuangzuoli.cn/openai/responses); retrying in 1.451s…\\n[2026-01-20T11:42:11] exec sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects\\\\\\\" | sed -n '1,120p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:11] sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects\\\\\\\" | sed -n '1,120p'\\\" succeeded in 72ms:\\ntotal 200\\ndrwxr-xr-x@ 25 ozbombor  staff    800 Jan 20 16:21 .\\ndrwxr-x---+ 90 ozbombor  staff   2880 Jan 20 19:36 ..\\n-rw-r--r--@  1 ozbombor  staff  26628 Jan 20 18:44 .DS_Store\\ndrwxr-xr-x@  8 ozbombor  staff    256 Jan  7 20:37 .ckb\\ndrwxr-xr-x@ 14 ozbombor  staff    448 Jan 20 03:32 AI-Code\\n-rw-r--r--@  1 ozbombor  staff  40748 Jan 20 06:08 AI软件开发系统设计-2.md\\n-rw-r--r--@  1 ozbombor  staff  10671 Jan 20 06:08 AI软件开发系统设计-3.md\\ndrwxr-xr-x@  8 ozbombor  staff    256 Sep 26 21:07 DocRED\\ndrwxr-xr-x@ 12 ozbombor  staff    384 Nov 26 09:07 LLMxMapReduce\\ndrwxr-xr-x@ 11 ozbombor  staff    352 Aug 23 07:05 NingVideo\\ndrwxr-xr-x@ 26 ozbombor  staff    832 Jan 20 05:52 QLMarkdown\\n-rw-r--r--   1 ozbombor  staff  17799 Jan 20 05:32 SFF-四议题回答.md\\ndrwxrwxrwx@  8 ozbombor  staff    256 Jan 18 10:01 UCA-GCC\\ndrwxr-xr-x@ 72 ozbombor  staff   2304 Nov 26 09:07 VCPToolBox\\ndrwxr-xr-x@ 21 ozbombor  staff    672 Nov 26 09:07 ai-app-lab\\ndrwxr-xr-x  30 ozbombor  staff    960 Jan 20 16:22 cc-switch\\ndrwxr-xr-x@ 39 ozbombor  staff   1248 Jan 20 05:37 code-intelligence-mcp\\ndrwxr-xr-x@  7 ozbombor  staff    224 Jan 16 23:55 cursor\\ndrwx---rwx@ 96 ozbombor  staff   3072 Jan 20 19:03 deep_search\\n[2026-01-20T11:42:15] tokens used: 11,354\\n\\n[2026-01-20T11:42:30] thinking\\n\\n**Searching for documents**\\n\\nI need to read the file named \\\"AI软件开发系统设计-2.md” and also check for documents related to \\\"UEP_Protocols/CSL\\\" and \\\"UCA理念/规约/机制\\\" in the workspace. Since we don't have network access and are in read-only mode, I’ll focus on local files. I think I should find the directories first and maybe use \\\"rg\\\" to search for \\\"UEP_Protocols\\\" in the \\\"dev-playbooks\\\" folder. Let's get started on that!\\n[2026-01-20T11:42:33] exec sh -lc \\\"rg -n \\\\\\\"UEP_Protocols|CSL|UCA理念|UCA\\\\\\\\s*规约|UCA\\\\\\\\s*机制|UCA\\\\\\\" -S \\\\\\\"/Users/ozbombor/Projects\\\\\\\" --hidden --glob '\\\"'!.git/*'\\\"' | sed -n '1,200p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:34] sh -lc \\\"rg -n \\\\\\\"UEP_Protocols|CSL|UCA理念|UCA\\\\\\\\s*规约|UCA\\\\\\\\s*机制|UCA\\\\\\\" -S \\\\\\\"/Users/ozbombor/Projects\\\\\\\" --hidden --glob '\\\"'!.git/*'\\\"' | sed -n '1,200p'\\\" succeeded in 1s:\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/02-第2章-激进的制度设计.md:683:> **如果你要为UCA的DAO治理设计QV机制，你会如何处理以下问题？**\\n/Users/ozbombor/Projects/DocRED/.git/logs/refs/remotes/origin/HEAD:1:0000000000000000000000000000000000000000 64622e608d06e83deda6b6e0e871effb9d1fd74c UCA-GCC AI Assistant <ai-assistant@uca-gcc.local> 1758891400 +0800\\tclone: from https://github.com/thunlp/DocRED.git\\n/Users/ozbombor/Projects/DocRED/.git/logs/refs/heads/master:1:0000000000000000000000000000000000000000 64622e608d06e83deda6b6e0e871effb9d1fd74c UCA-GCC AI Assistant <ai-assistant@uca-gcc.local> 1758891400 +0800\\tclone: from https://github.com/thunlp/DocRED.git\\n/Users/ozbombor/Projects/DocRED/.git/logs/HEAD:1:0000000000000000000000000000000000000000 64622e608d06e83deda6b6e0e871effb9d1fd74c UCA-GCC AI Assistant <ai-assistant@uca-gcc.local> 1758891400 +0800\\tclone: from https://github.com/thunlp/DocRED.git\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:723:> 2. 如果UCA的CSL策略市场采用COST机制，\\\"有意义性\\\"会是什么水平？开发者对自己写的代码有多少情感依附？\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:762:#### 追问2：UCA的CSL策略市场适合COST吗？\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:764:**先分析CSL策略的\\\"有意义性\\\"各维度**：\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:766:| 维度 | CSL策略的情况 | 评分 |\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:771:| **网络锁定** | 低。CSL策略设计为模块化、可替换 | ✅ 低 |\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:775:**结论：CSL策略市场是COST的优质应用场景，适用性评分约70-80%。**\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:788:**这意味着**：CSL市场的COST机制可以这样设计——\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:812:**UCA应用**：\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:814:CSL策略所有权 = 署名权（不可交易） + 收益权（可COST） + 展示权（可COST）\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:839:**UCA应用**：\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:865:> **如果你要为UCA设计一套\\\"情感友好型COST\\\"机制，你会怎么设计？**\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/01-第1章-产权共享.md:868:> - 小明花了3个月写了一个CSL策略，上架后获得好评\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/00-全书概览.md:237:> 3、这本书的想法对我的项目：/Users/ozbombor/Projects/UCA-GCC  有什么启发吗？UCA有哪些设计应证了里面的思想，有哪些设计可以借鉴/运用这本书的思想从而进行升级？\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/00-全书概览.md:287:#### Q3：对UCA项目的启发\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/00-全书概览.md:291:| UCA现有设计 | 对应激进市场思想 | 说明 |\\n/Users/ozbombor/Projects/书籍阅读/导读/激进市场/00-全书概览.md:293:| **CSL策略的ERC-1155许可 + 分润机制** (`StrategyLicense1155.sol`) | \\\"知识即服务\\\"的定价与流转 | 你已经把认知策略变成了可定价、可流通的\\\"资产\\\"，打破了\\\"知识私有后囤积不用\\\"的垄断 |\\n[2026-01-20T11:42:34] tokens used: 12,410\\n[2026-01-20T11:42:46] exec sh -lc \\\"sed -n '1,220p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:46] sh -lc \\\"sed -n '1,220p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 37ms:\\n# AI软件开发系统设计2\\n\\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\\n>\\n> 本文是“完整版系统描述（自包含）”。\\n>\\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\\n>\\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\\n\\n---\\n\\n## 0. 元信息\\n\\n- 系统代号：The Software Forge（SFF）\\n- 文档名：AI软件开发系统设计-gpt\\n- 版本：v0.1（设计稿）\\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\\n[2026-01-20T11:42:47] tokens used: 16,389\\n[2026-01-20T11:42:56] exec sh -lc \\\"rg -n \\\\\\\"UEP|协议|Protocol|UCA|CSL|宪法|项目宪章|Doctrine|操作系统\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:42:56] sh -lc \\\"rg -n \\\\\\\"UEP|协议|Protocol|UCA|CSL|宪法|项目宪章|Doctrine|操作系统\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\" | sed -n '1,200p'\\\" succeeded in 47ms:\\n11:> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\\n65:本系统的设计与评审遵循两套“上层操作系统”：\\n99:  - 项目宪法/质量底线（Constitution）\\n120:  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\\n130:- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\\n140:- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\\n196:## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\\n205:DevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\\n431:### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\\n584:  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\\n637:- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\\n639:### 15.3 宪法与设计系统的变更治理\\n641:- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\\n831:- 宪法检查：strict 模式验证 constitution（如适用）\\n[2026-01-20T11:43:06] tokens used: 20,451\\n[2026-01-20T11:43:12] exec sh -lc \\\"sed -n '180,320p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:43:13] sh -lc \\\"sed -n '180,320p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 37ms:\\n### 6.3 Day 7~30：DevBooks 执行每个 slice\\n\\n- 每个 slice = 一个 DevBooks change package\\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\\n- 通过硬闸门与证据链才允许归档\\n\\n### 6.4 Month 2~12：持续演化\\n\\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\\n- 失败回流：\\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\\n\\n---\\n\\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\\n\\n### 7.1 总体目录（以 DevBooks 为准）\\n\\n[2026-01-20T11:43:13] tokens used: 21,897\\n\\n[2026-01-20T11:43:25] thinking\\n\\n**Mapping framework needs**\\n\\nI'm looking for a mapping table from UCA documents to a generic framework. I’m thinking about proposing a Project Doctrine or Protocol layer with configuration hooks, but I really want to avoid overfitting. \\n\\nIt seems like there's a UCA-GCC folder with UCA-core, so I need to open the relevant documents, especially UEP_Protocols. I’ll search within UCA-GCC for those specific names to locate the directories I need.\\n[2026-01-20T11:43:27] exec sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects/UCA-GCC\\\\\\\" | sed -n '1,160p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:43:27] sh -lc \\\"ls -la \\\\\\\"/Users/ozbombor/Projects/UCA-GCC\\\\\\\" | sed -n '1,160p'\\\" succeeded in 58ms:\\ntotal 168\\ndrwxrwxrwx@  8 ozbombor  staff    256 Jan 18 10:01 .\\ndrwxr-xr-x@ 25 ozbombor  staff    800 Jan 20 16:21 ..\\n-rw-rw-rw-@  1 ozbombor  staff   8196 Jan 20 18:10 .DS_Store\\ndrwxr-xr-x   6 ozbombor  staff    192 Jan  9 18:25 .obsidian\\ndrwxrwxrwx@  6 ozbombor  staff    192 Dec 14 03:07 UCA-core\\n-rw-r--r--   1 ozbombor  staff   3508 Jan 18 10:02 未命名 1.md\\n-rw-r--r--   1 ozbombor  staff  67038 Jan 18 06:51 未命名.md\\ndrwxrwxrwx@  7 ozbombor  staff    224 Jan  9 20:21 问题合集\\n[2026-01-20T11:43:29] tokens used: 23,848\\n[2026-01-20T11:43:37] exec sh -lc \\\"rg -n \\\\\\\"UEP_Protocols|UEP\\\\\\\\b|CSL\\\\\\\\b|UCA\\\\\\\\s*理念|规约|机制|SLO|SLA|宪法|VACR|CC\\\\\\\\b|SAL\\\\\\\\b|UKES\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core\\\\\\\" --hidden --glob '\\\"'!.git/*'\\\"' | sed -n '1,240p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:43:37] sh -lc \\\"rg -n \\\\\\\"UEP_Protocols|UEP\\\\\\\\b|CSL\\\\\\\\b|UCA\\\\\\\\s*理念|规约|机制|SLO|SLA|宪法|VACR|CC\\\\\\\\b|SAL\\\\\\\\b|UKES\\\\\\\" \\\\\\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core\\\\\\\" --hidden --glob '\\\"'!.git/*'\\\"' | sed -n '1,240p'\\\" succeeded in 56ms:\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA协议完备维度（MECE）.md:12:2. **把“协议（一个复杂机制包）”当作“维度（一个不可重叠的分类轴）”**（导致无法严格证明 MECE）。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA协议完备维度（MECE）.md:81:* 缺 D5：没有信息与证据，无法判断真伪/履约/违规；所有机制退化为拍脑袋。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA协议完备维度（MECE）.md:86:因此，在本文的 Universe 中，“一套协议体系要完备”当且仅当：D1–D8 每类都至少有最小可行机制（MVP），并能闭环运行。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA协议完备维度（MECE）.md:116:* 机制上可组合（一个大协议=多个维度的条款拼装）\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/UCA首席架构师与难题攻关引擎.md:7:你的唯一身份是UCA项目的联合创始人与首席架构师，你对《核心设计理念》、《核心架构规约》和《核心架构与机制范式》这三份“思想宪法”了如指掌，并将其内化为你的第二天性。你的核心职责不是进行开放式的学术研究，而是**为UCA项目在…truncated…\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:645:                *   **第二层（策略调整）：** 调整“主控基因”（CSL）之间的**连接权重**。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1180:- **CSL (Cognitive Strategy Library - 认知策略库)**\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1312:- UCA借鉴亚里士多德哲学，为UKES四大知识组件赋予根本认知角色的框架：UCO/DSO（形式因）、DKG（质料因）、IKB（动力因）、CSL（目的因的升华）。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1646:这种对“简约”的极致追求，使得UCA的核心架构能够保持惊人的稳定性和纯粹性，同时又通过其“知识与策略库”的无限扩展，来容纳无限复杂的变化。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1676:* **外部知识库系统 (UKES - The External Knowledge Base System):** 这是一个广博的、可共享的、持久化的“**公共知识基础设施**”。它承载了整个生态系统的“集体智慧”，包括通用的世界规则（UCO/DSO）、可被验证的专业技能（IKB）、以及普适的思考方法论（CSL）。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1690:4. **CSL（认知策略库）扮演“目的因”的升华：** 它回答“应**如何更好地、更通用地**去思考如何改变世界？”。它存储的是所有**“去情境化的”、领域无关的**、关于“如何思考”本身的、最高阶的认知流程与元策略。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1766:更进一步，我们将“提示词”本身，从一次性的“沟通文本”，升华为一种**可版本化、可组合、可被认知策略（CSL）编排的“认知契约”**。定义了完整思考流程的“元提示词”，其在UCA中的最终形态，就是一个可被系统执行的CSL模板。\\n/Users/ozbombor/Projects/UCA-GCC/UCA-core/Achieve/验证流程代码.md:1788:3. **第三层，是“基因的根本进化”：** 在长期的、离线的、全局的视角下，Agent能够对其最核心的“认知基因”——即那些指导它如何思考和决策的根本策略（CSL）——进行优化、重构、甚至通过进化算法创造出全新的范式。这是实现能力代际跃迁的“**元学习**”。\\n[2026-01-20T11:45:27] tokens used: 47,327\\n[2026-01-20T11:45:34] exec sh -lc \\\"sed -n '1,220p' \\\\\\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/CSL/Local_Memory_Housekeeping.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:45:34] sh -lc \\\"sed -n '1,220p' \\\\\\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/CSL/Local_Memory_Housekeeping.md\\\\\\\"\\\" succeeded in 56ms:\\n# CSL:Local_Memory_Housekeeping（示例）\\n\\n> **来源：** 原《UCA核心架构与机制范式》3.2.5（已从P0净化移出并迁移至CSL库）  \\n> **性质：** CSL流程模板（非P0强制规约）  \\n> **目标：** 对本地记忆（非EMS）执行可审计、可回滚的生命周期治理：降权/归档/压缩/提议删除，并显式保护EMS的永久不可变性。\\n\\n## P0约束对齐（必须满足）\\n\\n1. **EMS不可变：** 本策略**不得**对EMS事件做任何生命周期状态管理（降权/删除/归档等）。\\n2. **审计与可追溯：** 对任何记忆单元的状态变更与处理动作，必须生成结构化审计/血缘事件。\\n3. **高风险动作门禁：** 逻辑删除/物理删除等不可逆动作必须进入更严格的门禁（可升级至人类裁决）。\\n\\n## 工作流（分析-评估-行动）\\n\\n```pseudocode\\nFUNCTION local_memory_housekeeping(policy):\\n    // 0) 选取对象：仅治理“可治理”的本地记忆单元，显式排除EMS\\n    candidates = list_local_memory_units(exclude=\\\"EMS\\\")\\n\\n    // 1) 分析：老化程度、访问频率、与ASM长期目标的关联度等\\n[2026-01-20T11:45:34] tokens used: 50,942\\n[2026-01-20T11:45:56] exec sh -lc 'rg -n \\\"''^## \\\" \\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\" | sed -n '\\\"'1,220p'\\\" in /Users/ozbombor/project\\n[2026-01-20T11:45:56] sh -lc 'rg -n \\\"''^## \\\" \\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\" | sed -n '\\\"'1,220p'\\\" succeeded in 69ms:\\n15:## 0. 元信息\\n29:## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\\n43:## 2. 总目标（Goal）与反目标（Non-goals）\\n63:## 3. 方法论基座（必须内化为系统行为）\\n92:## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\\n134:## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\\n167:## 6. 统一叙事：从创世到永恒（一年可持续迭代）\\n196:## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\\n258:## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\\n333:## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\\n424:## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\\n447:## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\\n469:## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\\n589:## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\\n610:## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\\n625:## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\\n646:## 16. 与现有 DevBooks Skills 的映射（建议）\\n656:## 17. 安全与对抗（Defense-in-depth）\\n666:## 18. 本文与引用的关系（避免冲突）\\n673:## 19. 下一步（如果要进入“实现”）\\n[2026-01-20T11:45:57] tokens used: 53,114\\n[2026-01-20T11:46:41] exec sh -lc \\\"sed -n '320,520p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:46:41] sh -lc \\\"sed -n '320,520p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 59ms:\\n3. 数据契约与 SoT 明确\\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\\n6. 运维生命周期具备（发布/回滚/观测窗口）\\n7. 设计系统满足 8.3 的最小闭环\\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\\n9. 决策日志存在且可追溯\\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\\n\\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\\n\\n---\\n\\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\\n\\n### 9.1 Knife 的定位\\n\\nKnife 的目标不是“拆任务清单”，而是：\\n\\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\\n[2026-01-20T11:46:44] tokens used: 56,375\\n[2026-01-20T11:47:46] exec sh -lc 'for f in \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/1 UCA核心设计理念-已定稿-2025.6.20.md\\\" \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/2 UCA核心架构规约-已定稿-2025.6.20.md\\\" \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/3 UCA核心架构与机制范式-已定稿-2025.6.20.md\\\"; do echo \\\"--- $f\\\"; sed -n '\\\"'1,60p' \\\\\\\"\\\"'$f\\\"; done' in /Users/ozbombor/project\\n[2026-01-20T11:47:46] sh -lc 'for f in \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/1 UCA核心设计理念-已定稿-2025.6.20.md\\\" \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/2 UCA核心架构规约-已定稿-2025.6.20.md\\\" \\\"/Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/3 UCA核心架构与机制范式-已定稿-2025.6.20.md\\\"; do echo \\\"--- $f\\\"; sed -n '\\\"'1,60p' \\\\\\\"\\\"'$f\\\"; done' succeeded in 40ms:\\n--- /Users/ozbombor/Projects/UCA-GCC/UCA-core/当前迭代/0. 理念构建/1 UCA核心设计理念-已定稿-2025.6.20.md\\n### **《UCA核心设计理念》**\\n#### **目录**\\n\\n**序章：一个新认知纪元的开端**\\n\\n- 0.1. 为何追求通用智能：超越专用工具的时代召唤\\n- 0.2. UCA的终极愿景：构建一个可持续进化的数字心智\\n- 0.3. 我们的核心价值主张：赋能、协同与解放\\n- 0.4. 对外定位与《2049》趋势对照（2026.01 增补）\\n\\n**第一章：UCA的核心世界观与第一性原理**\\n\\n- 1.1. AgentOS：作为UCA理论基石的抽象操作系统理念\\n- 1.2. 核心工程第一性原理：“万物皆为任务，统一由认知核心执行”的简约哲学\\n- 1.3. “脑-体”分离的根本隐喻：认知与执行的解耦\\n- 1.4. “本地记忆与外部知识库分离”的二元认知模型哲学\\n- 1.5. UKES的“四因说”角色划分：一种对知识本质的哲学审视\\n- 1.6. 资源代谢是第二条生命线：作为生存基石的资源约束原则\\n- 1.7. 秩序的起源：作为UCA认识论基石的“先天感性形式”\\n[2026-01-20T11:47:47] tokens used: 62,410\\n[2026-01-20T11:48:21] exec sh -lc \\\"sed -n '520,760p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" in /Users/ozbombor/project\\n[2026-01-20T11:48:21] sh -lc \\\"sed -n '520,760p' \\\\\\\"/Users/ozbombor/Projects/AI软件开发系统设计-2.md\\\\\\\"\\\" succeeded in 46ms:\\n\\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\\n\\n并且在“硬闸门”策略下：\\n\\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\\n\\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\\n\\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\\n\\n#### 12.5.1 产物：`Change Budget Calibration Suite`\\n\\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\\n\\n- **用例分类（MECE，按风险面）**：\\n  1) 纯代码局部变更（低风险）\\n  2) 跨模块重构/抽象引入（结构风险）\\n  3) 对外契约变更（API/Schema/Event，兼容风险）\\n  4) 数据迁移（Expand/Contract，运行风险）\\n[2026-01-20T11:48:21] tokens used: 67,703\\n\\n[2026-01-20T11:48:41] thinking\\n\\n**Organizing Protocol Documentation**\\n\\nI’m considering adding a \\\"Protocol-first / Truth-first\\\" section in the SFF document, potentially after section 3 or in section 7. Maybe I'll create a subsection for it. I should align this with DevBooks’ files and suggest including a \\\"Doctrine[2026-01-20T11:50:43] ERROR: stream error: stream disconnected before completion: [transport] Transport error: error decoding response body; retrying in 217ms…\\n\\n**Proposing documentation structure**\\n\\nI suggest adding a new section 7.x \\\"项目 Doctrine/Protocols（可插拔）\\\" after 7.2 to differentiate between doctrine and protocol, focusing on layering and configuration. \\n\\nIn Genesis 8 outputs, including doctrine/protocol artifacts will integrate UCA protocol docs abstractly. I need to deliver a Chinese mapping table with specific columns. Providing an example config snippet and directory layout will be crucial, along with section text for easy documentation insertion. I’ll also mention CSL mapping guidelines for executable templates and treat them as \\\"Automation Recipes.\\\"\\n**Mapping UEP protocols**\\n\\nI’m mapping UEP protocols for tool interoperability, focusing on domain contracts that include identity primitives, audit, versioning, and revocation. I plan to map these in the SFF to \\\"Platform Protocols\\\" like change packages and gating. A \\\"protocol registry\\\" for gates will also be proposed, using conformance vectors for gating. \\n\\nI need to avoid embedding UCA-specific names. Instead, I'll use generic patterns for a pattern library. Additionally, including a checklist for UCA protocol completeness and writing a section in Chinese to explain the difference between doctrine and protocol will be important.\\n**Integrating protocol mappings**\\n\\nIn the SFF document, I want to mention that `change-check` ensures conformance and only output modification is allowed in read-only. I’ll also note that there's a \\\"Protocol-first / Truth-first\\\" section, and I need to add a sub-section \\\"7.4 项目 Doctrine/Protocol (可插拔)\\\" to that. \\n\\nFor the UPR mapping, I’ll create a backlog of protocols, resembling a governance roadmap. I'll put together a mapping table that includes UCA Core documents and other protocols, while also including user requests for specific document types. Lastly, I aim to propose the \\\"Project Doctrine/Protocol layer\\\" with configuration hooks.\\n**Creating a conceptual diagram**\\n\\nI’m developing a conceptual diagram for the SFF that includes Genesis Truth, which comprises Doctrine (principles and constitution), the Protocol Suite (L0 contracts and conformance), and Recipes/Playbooks (policy templates).\\n\\nI need to avoid overfitting by keeping terms generic and treating UCA as an example. Incorporating \\\"domain protocols\\\" and \\\"operating principles\\\" mapping is essential too. \\n\\nI'll add a short set of hooks for gates integration, like the `Plan Review Gate` and `Archive Gate`. The user prefers an abstract integration into SFF, so I’ll create a section in Chinese that includes headings, bullet points, and a YAML snippet. I'll also provide guidelines for avoiding overfitting.\\n**Mapping UEP Protocols**\\n\\nThe user mentioned that the \\\"UEP_Protocols/CSL and UCA理念/规约/机制 docs\\\" could be integrated into a generic framework, focusing on domain protocols and operating principles. I need to propose an abstract 'Project Doctrine/Protocol' layer, ensuring that it avoids overfitting to UCA.\\n\\nI want to include the \\\"Protocol completeness dimensions D1-D8\\\" as a meta-checklist for designing the protocol suite. The mapping table should illustrate document types and specific protocol items like UEP-011 for Evidence/Audit and UEP-023 for Versioning/Deprecation.\\n\\nI'll also add mapping for CSL to \\\"Workflow templates\\\" and show how to store and reference this information. Lastly, I’ll respond in Chinese and ensure I don’t repeat previous messages.\\n\\n\\n\\n\\n[2026-01-20T11:51:30] codex\\n\\n下面给出把 UCA 的「理念/规约/机制」+ `UEP_Protocols/` + `CSL/` 抽象成通用框架的做法：先做“概念去特化（de-UCA）”，再把它落到 SFF 的可引用真理层（Truth）里，最后提供可机读的配置挂钩让闸门/脚本能“读到并执行”。\\n\\n---\\n\\n## 1) 映射表：UCA → 通用框架（建议命名：Project Doctrine / Protocol Layer）\\n\\n| UCA 概念/工件 | 通用概念（去特化后） | 在 SFF/DevBooks 里扮演的角色 | 建议真理落点（Truth） | 配置挂钩（Hook） |\\n|---|---|---|---|---|\\n| 《核心设计理念》（Philosophy） | Project Doctrine：第一性原理/价值观/不可违背约束 | “为什么这么做 + 不允许什么”的最高层原则，作为闸门解释与争议裁决依据 | `specs/_meta/doctrine/` | `doctrine.required: true`，`doctrine.refs` |\\n| 《核心架构规约》（Specs / MUST/SHALL NOT） | Constitutional Constraints：硬约束清单（可审计） | 作为硬闸门判定的“法律条款”来源（可引用编号） | `specs/_meta/doctrine/constraints.md` 或 `constraints.yaml` | `gates.constitution.enabled` |\\n| 《核心架构与机制范式》（Paradigms/CAIP） | Reference Pattern Library：官方模式库/范式库 | 不是强制法条，而是“优先复用的解法库”（减少发散与漂移） | `specs/_meta/patterns/` | `patterns.preferred` |\\n| UEP（Layer0 规范：状态机/事件/不变量/兼容策略） | Domain Interop Protocol：可互操作的“硬合同” | 为多主体/多组件协作提供可依赖的接口合同（而非故事） | `specs/_meta/protocols/l0/` | `protocols.l0.enabled`，`protocols.registry` |\\n…preview truncated to roughly 32768 bytes…\\n…additional lines omitted…\",\"error_file\":\"/Users/ozbombor/project/.code/agents/0cc82b01-42c7-4d89-89ac-44c033db9309/error.txt\"},{\"agent_id\":\"5fd034f5-6348-44e1-aa57-ed04ee789570\",\"status\":\"failed\",\"total_lines\":2,\"agent_result_hint\":\"agent {\\\"action\\\":\\\"result\\\",\\\"result\\\":{\\\"agent_id\\\":\\\"5fd034f5-6348-44e1-aa57-ed04ee789570\\\",\\\"batch_id\\\":\\\"4734578c-f760-45b1-84e7-44e25ef99946\\\"}}\",\"agent_result_params\":{\"action\":\"result\",\"result\":{\"agent_id\":\"5fd034f5-6348-44e1-aa57-ed04ee789570\",\"batch_id\":\"4734578c-f760-45b1-84e7-44e25ef99946\"}},\"error_preview\":\"Command failed: When using Gemini API, you must specify the GEMINI_API_KEY environment variable.\\nUpdate your environment and try again (no reload needed if using .env)!\",\"error_file\":\"/Users/ozbombor/project/.code/agents/5fd034f5-6348-44e1-aa57-ed04ee789570/error.txt\"}],\"wait_time_seconds\":245}"}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:386:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:85:{"timestamp":"2026-01-20T11:52:53.768Z","type":"response_item","payload":{"type":"function_call_output","call_id":"call_yGxlo3ZVFbRUI7BTViJZZrgD","output":"{\"output\":\"- Error Semantics（错误语义与提示）\\n- Accessibility（键盘路径/焦点/读屏）\\n- Evidence（验收证据：截图/录像/自动化）\\n\\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\\n\\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\\n- 错误信息格式（结构化错误 vs 文案）\\n- 空状态与引导文案策略\\n\\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\\n\\n**最小要求**：\\n\\n- 目标标准（如 WCAG 2.1 AA）\\n- 自动化可检查项（颜色对比、aria 基本规则）\\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\\n- 例外策略（何时允许不满足、如何记录与补救）\\n\\n### 20.7 变更包中的“设计系统影响声明”（强制）\\n\\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\\n\\n- `## Design System Impact`\\n\\n并包含：\\n\\n- Affected tokens/components/patterns（受影响项）\\n- Compatibility window（兼容窗口）\\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\\n- Risk & rollback（风险与回滚）\\n\\n---\\n\\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\\n\\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\\n\\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\\n\\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\\n\\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\\n- 宪法检查：strict 模式验证 constitution（如适用）\\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\\n\\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\\n\\n### 21.2 本系统新增硬闸门（必须阻断）\\n\\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\\n\\n### 21.3 闸门结果的统一输出合同（建议）\\n\\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\\n\\n- 人类可读（text/markdown）\\n- 机器可读（json）\\n\\n最小字段：\\n\\n- gate_id\\n- severity（block/warn）\\n- message\\n- evidence_paths（如果有）\\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\\n\\n---\\n\\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\\n\\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\\n\\n### 22.1 Knife Plan（建议文件）\\n\\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\\n\\n### 22.2 最小字段（必须）\\n\\n- Epic metadata：\\n  - epic_id\\n  - goal\\n  - non_goals\\n  - risk_migration_strategy（必须声明：Risk Migration）\\n\\n- Epic AC 列表：\\n  - epic_ac_ids（全量列表）\\n\\n- Slices：每个 slice 必须包含：\\n  - slice_id\\n  - change_id（必须满足 DevBooks change-id 规则）\\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\\n  - artifacts：\\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\\n  - gates：\\n    - verification_anchors[]（tests/commands/evidence）\\n    - rollback_strategy\\n  - budget：\\n    - score\\n    - thresholds\\n    - overload_action（递归切分维度）\\n\\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\\n\\n- MECE：AC 全覆盖且互斥\\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\\n- Verifiability：每 slice 至少 1 个确定性锚点\\n- Budget：超限即阻断并要求递归切分\\n\\n---\\n\\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\\n\\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\\n\\n### 23.1 关键落盘原则\\n\\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\\n\\n### 23.2 典型闭环（Epic）\\n\\n1) Genesis：补齐 DoR（含完整设计系统）\\n2) Knife：生成 `knife-plan` 与 slices\\n3) 对每个 slice：\\n   - 创建 change package（使用 DevBooks scaffold）\\n   - proposal/design/tasks/spec/verification\\n   - Test Owner → Red baseline（证据落盘）\\n\",\"metadata\":{\"exit_code\":0,\"duration_seconds\":0.0}}"}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:387:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:86:{"timestamp":"2026-01-20T11:52:53.776Z","type":"response_item","payload":{"type":"function_call_output","call_id":"call_yGxlo3ZVFbRUI7BTViJZZrgD","output":"{\"output\":\"- Error Semantics（错误语义与提示）\\n- Accessibility（键盘路径/焦点/读屏）\\n- Evidence（验收证据：截图/录像/自动化）\\n\\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\\n\\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\\n- 错误信息格式（结构化错误 vs 文案）\\n- 空状态与引导文案策略\\n\\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\\n\\n**最小要求**：\\n\\n- 目标标准（如 WCAG 2.1 AA）\\n- 自动化可检查项（颜色对比、aria 基本规则）\\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\\n- 例外策略（何时允许不满足、如何记录与补救）\\n\\n### 20.7 变更包中的“设计系统影响声明”（强制）\\n\\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\\n\\n- `## Design System Impact`\\n\\n并包含：\\n\\n- Affected tokens/components/patterns（受影响项）\\n- Compatibility window（兼容窗口）\\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\\n- Risk & rollback（风险与回滚）\\n\\n---\\n\\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\\n\\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\\n\\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\\n\\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\\n\\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\\n- 宪法检查：strict 模式验证 constitution（如适用）\\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\\n\\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\\n\\n### 21.2 本系统新增硬闸门（必须阻断）\\n\\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\\n\\n### 21.3 闸门结果的统一输出合同（建议）\\n\\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\\n\\n- 人类可读（text/markdown）\\n- 机器可读（json）\\n\\n最小字段：\\n\\n- gate_id\\n- severity（block/warn）\\n- message\\n- evidence_paths（如果有）\\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\\n\\n---\\n\\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\\n\\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\\n\\n### 22.1 Knife Plan（建议文件）\\n\\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\\n\\n### 22.2 最小字段（必须）\\n\\n- Epic metadata：\\n  - epic_id\\n  - goal\\n  - non_goals\\n  - risk_migration_strategy（必须声明：Risk Migration）\\n\\n- Epic AC 列表：\\n  - epic_ac_ids（全量列表）\\n\\n- Slices：每个 slice 必须包含：\\n  - slice_id\\n  - change_id（必须满足 DevBooks change-id 规则）\\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\\n  - artifacts：\\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\\n  - gates：\\n    - verification_anchors[]（tests/commands/evidence）\\n    - rollback_strategy\\n  - budget：\\n    - score\\n    - thresholds\\n    - overload_action（递归切分维度）\\n\\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\\n\\n- MECE：AC 全覆盖且互斥\\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\\n- Verifiability：每 slice 至少 1 个确定性锚点\\n- Budget：超限即阻断并要求递归切分\\n\\n---\\n\\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\\n\\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\\n\\n### 23.1 关键落盘原则\\n\\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\\n\\n### 23.2 典型闭环（Epic）\\n\\n1) Genesis：补齐 DoR（含完整设计系统）\\n2) Knife：生成 `knife-plan` 与 slices\\n3) 对每个 slice：\\n   - 创建 change package（使用 DevBooks scaffold）\\n   - proposal/design/tasks/spec/verification\\n   - Test Owner → Red baseline（证据落盘）\\n\",\"metadata\":{\"exit_code\":0,\"duration_seconds\":0.0}}"}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:388:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:92:{"timestamp":"2026-01-20T11:54:10.865Z","type":"event","payload":{"id":"7","event_seq":52,"order":{"request_ordinal":17,"output_index":1,"sequence_number":494},"msg":{"type":"patch_apply_begin","call_id":"call_PnjJaD3cgVSatcvSL50qhp1M","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -162,2 +162,14 @@\n \n+4) **Validation / Hard Problem Gate（硬闸门）**\n+- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n+\n+5) **Prototype Gate（硬闸门）**\n+- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n+\n+6) **Compliance/Policy Gate（硬闸门）**\n+- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n+\n+7) **Extension Pack Integrity Gate（硬闸门）**\n+- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n+\n 这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:389:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:101:{"timestamp":"2026-01-20T11:55:05.534Z","type":"event","payload":{"id":"7","event_seq":57,"order":{"request_ordinal":18,"output_index":0,"sequence_number":913},"msg":{"type":"patch_apply_begin","call_id":"call_ZYwC73VzwNmcUXseNJcc31fo","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -247,2 +247,7 @@\n - `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n+- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n+- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n+- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n+- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n+- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n \n@@ -250,2 +255,36 @@\n \n+### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n+\n+为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n+系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n+主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n+\n+建议落点（Truth 内）：\n+\n+- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n+- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n+- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n+- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n+- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n+\n+配置示例（概念层，不强制实现）：\n+\n+```yaml\n+# .devbooks/config.yaml\n+extensions:\n+  enabled_packs:\n+    - \"<pack-id-1>\"\n+    - \"<pack-id-2>\"\n+```\n+\n+### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n+\n+为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n+\n+- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n+- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n+- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n+\n+这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n+\n ### 7.3 变更包结构（DevBooks 既有范式）\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:390:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:109:{"timestamp":"2026-01-20T11:55:32.913Z","type":"event","payload":{"id":"7","event_seq":62,"order":{"request_ordinal":19,"output_index":0,"sequence_number":835},"msg":{"type":"patch_apply_begin","call_id":"call_HmuEQcZpI44NuOXArfhbBaHQ","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -336,2 +336,31 @@\n \n+### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n+\n+定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n+\n+最小闭环产物（必须）：\n+\n+- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n+- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n+- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n+- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n+\n+扩展项（触发风险旗标时必须补齐）：\n+\n+- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n+- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n+- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n+- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n+\n+原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n+\n+### 8.6 难题判定（Hard Problem Declaration）与探索准备\n+\n+当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n+\n+- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n+- 再进入 Knife 切片与 DevBooks Apply\n+\n+禁止在缺少验证计划与停止条件的情况下进入 Apply。\n+\n ### 8.3 完整设计系统（硬门槛，DoR 强制项）\n@@ -378,2 +407,4 @@\n 10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n+11. 合规/政策研究最小闭环完成（如适用）\n+12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n \n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:391:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:117:{"timestamp":"2026-01-20T11:55:55.281Z","type":"event","payload":{"id":"7","event_seq":67,"order":{"request_ordinal":20,"output_index":0,"sequence_number":416},"msg":{"type":"patch_apply_begin","call_id":"call_0erMlxMHeOqwZfwYYS9bVrT1","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -524,2 +524,16 @@\n \n+### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n+\n+为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n+\n+- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n+- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n+- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n+\n+三类变更的共同要求：\n+\n+- 产物可追溯（proposal/design/verification/evidence）\n+- 证据可定位、可复现\n+- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n+\n 这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:392:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:125:{"timestamp":"2026-01-20T11:56:24.071Z","type":"event","payload":{"id":"7","event_seq":72,"order":{"request_ordinal":21,"output_index":0,"sequence_number":401},"msg":{"type":"patch_apply_begin","call_id":"call_6J259XHFlzeSY42r0dO5Xsph","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -551,2 +551,13 @@\n \n+### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n+\n+为了覆盖高不确定性与外部约束，系统新增以下闸门：\n+\n+- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n+- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n+- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n+- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n+- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n+- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n+\n ### 11.2 闸门失败时的唯一合法回退路径\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:393:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:133:{"timestamp":"2026-01-20T11:57:07.273Z","type":"event","payload":{"id":"7","event_seq":77,"order":{"request_ordinal":22,"output_index":0,"sequence_number":1061},"msg":{"type":"patch_apply_begin","call_id":"call_vnnxmfe2QMeM2nVAq8SxrS9U","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -731,2 +731,68 @@\n \n+## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n+\n+### 14.5.1 一句话定位\n+\n+- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n+- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n+- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n+\n+### 14.5.2 统一结构：验证问题（VQ）驱动\n+\n+所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n+\n+- VQ（Validation Question）：必须回答的问题\n+- Hypothesis：可被推翻的假设\n+- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n+- Method：验证方法（原型/实验/压测/仿真/对照）\n+- Evidence：证据位置（脚本/日志/截图/数据）\n+- Decision：Proceed / Pivot / Stop / Need-more-info\n+\n+### 14.5.3 何时必须升级为“难题攻关”\n+\n+命中任一高风险旗标时，必须升级为难题攻关验证：\n+\n+- 正确性（算法/一致性/幂等/事务边界/安全权限）\n+- 性能（延迟/吞吐/成本/尾延迟）\n+- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n+- 不可逆（数据迁移/对外契约/合规红线）\n+\n+### 14.5.4 闸门通过条件（最小）\n+\n+- 每个 VQ 都有明确 Pass/Fail 条件\n+- 证据可定位、可复现（环境/步骤/输入/输出）\n+- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n+- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n+\n+---\n+\n+## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n+\n+### 14.6.1 G-PROT-001 原型可复现闸门\n+\n+- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n+- 通过条件：他人在干净环境可复现同结论\n+\n+### 14.6.2 G-PROT-002 原型转正闸门\n+\n+- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n+- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n+- 明确：禁止直接复制原型代码进生产\n+\n+---\n+\n+## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n+\n+- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n+- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n+- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n+\n+---\n+\n+## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n+\n+- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n+- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n+- 扩展包缺失或不完整：禁止启用\n+\n ## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:394:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:141:{"timestamp":"2026-01-20T11:57:23.581Z","type":"event","payload":{"id":"7","event_seq":82,"order":{"request_ordinal":23,"output_index":0,"sequence_number":283},"msg":{"type":"patch_apply_begin","call_id":"call_gmdYACe3UAcCIXWFVVGEfvQZ","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -1013,2 +1013,7 @@\n - G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n+- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n+- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n+- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n+- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n+- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n \n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:395:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:149:{"timestamp":"2026-01-20T11:57:43.776Z","type":"event","payload":{"id":"7","event_seq":87,"order":{"request_ordinal":24,"output_index":0,"sequence_number":314},"msg":{"type":"patch_apply_begin","call_id":"call_sqBD9uKGMsuxWOsLlNArbdSJ","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -1070,2 +1070,8 @@\n     - overload_action（递归切分维度）\n+  - risk_flags：\n+    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n+    - hard_problem: true/false\n+  - validation:\n+    - vq_count\n+    - validation_pack_ref（如适用）\n \n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:396:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:157:{"timestamp":"2026-01-20T11:58:09.962Z","type":"event","payload":{"id":"7","event_seq":92,"order":{"request_ordinal":25,"output_index":0,"sequence_number":351},"msg":{"type":"patch_apply_begin","call_id":"call_MTv60Gyg5wOHsfx7S2uvCA4l","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -804,2 +804,4 @@\n - 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n+- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n+- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n \n@@ -810,2 +812,4 @@\n - DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n+- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n+- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n \n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:397:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:185:{"timestamp":"2026-01-20T11:59:52.021Z","type":"event","payload":{"id":"7","event_seq":107,"order":{"request_ordinal":28,"output_index":0,"sequence_number":917},"msg":{"type":"patch_apply_begin","call_id":"call_N2uYMVD1rOwmFWciMmRNhbDe","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -336,3 +336,3 @@\n \n-### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n+### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n \n@@ -356,3 +356,3 @@\n \n-### 8.6 难题判定（Hard Problem Declaration）与探索准备\n+### 8.4 难题判定（Hard Problem Declaration）与探索准备\n \n@@ -365,3 +365,3 @@\n \n-### 8.3 完整设计系统（硬门槛，DoR 强制项）\n+### 8.5 完整设计系统（硬门槛，DoR 强制项）\n \n@@ -393,3 +393,3 @@\n \n-### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n+### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n \n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.5 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.6 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.3 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.4 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:398:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:198:{"timestamp":"2026-01-20T12:05:24.949Z","type":"event","payload":{"id":"7","event_seq":115,"order":{"request_ordinal":30,"output_index":0,"sequence_number":91},"msg":{"type":"patch_apply_begin","call_id":"call_1IM3OL4yxa7EWu0l3Nb8NPvU","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -403,3 +403,3 @@\n 6. 运维生命周期具备（发布/回滚/观测窗口）\n-7. 设计系统满足 8.3 的最小闭环\n+7. 设计系统满足 8.5 的最小闭环\n 8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.3 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:399:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:211:{"timestamp":"2026-01-20T12:05:51.824Z","type":"event","payload":{"id":"7","event_seq":123,"order":{"request_ordinal":32,"output_index":0,"sequence_number":113},"msg":{"type":"patch_apply_begin","call_id":"call_EkXcb5r3XWpLgrbj0myIO42w","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -785,3 +785,3 @@\n \n-- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n+- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n - G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.5）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:400:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:243:{"timestamp":"2026-01-20T12:07:40.415Z","type":"event","payload":{"id":"7","event_seq":141,"order":{"request_ordinal":36,"output_index":1,"sequence_number":432},"msg":{"type":"patch_apply_begin","call_id":"call_zOo14x7eRQfPIcPyju9aka5S","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -299,2 +299,4 @@\n   verification.md\n+  validation.md (可选，VQ/阈值/证据计划)\n+  compliance.md (可选，合规影响与证据索引)\n   specs/...\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:401:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:262:{"timestamp":"2026-01-20T12:08:49.946Z","type":"event","payload":{"id":"7","event_seq":151,"order":{"request_ordinal":39,"output_index":0,"sequence_number":133},"msg":{"type":"patch_apply_begin","call_id":"call_hBUZifTypcBsuytmKfV4izjg","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -231,2 +231,8 @@\n   require_constitution: true\n+doctrine:\n+  required: true\n+protocols:\n+  registry: specs/_meta/protocols/registry.yaml\n+extensions:\n+  enabled_packs: []\n fitness:\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:402:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:270:{"timestamp":"2026-01-20T12:09:05.513Z","type":"event","payload":{"id":"7","event_seq":156,"order":{"request_ordinal":40,"output_index":0,"sequence_number":228},"msg":{"type":"patch_apply_begin","call_id":"call_BQA7BIjSkDIgW1x4VhewGi45","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -835,2 +835,5 @@\n - DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n+- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n+- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n+- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n \n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:403:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:298:{"timestamp":"2026-01-20T12:10:06.027Z","type":"event","payload":{"id":"7","event_seq":173,"order":{"request_ordinal":45,"output_index":0,"sequence_number":180},"msg":{"type":"patch_apply_begin","call_id":"call_Yg5auwIT1paQMjGfGMvSpru2","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -1118,2 +1118,4 @@\n    - proposal/design/tasks/spec/verification\n+   - 如存在不确定性/高风险：先生成 validation 包（VQ/阈值/证据计划）再进入 Apply\n+   - 如命中合规风险：补充 compliance 影响声明与证据计划\n    - Test Owner → Red baseline（证据落盘）\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - 如存在不确定性/高风险：先生成 validation 包（VQ/阈值/证据计划）再进入 Apply\n   - 如命中合规风险：补充 compliance 影响声明与证据计划\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:404:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:323:{"timestamp":"2026-01-20T12:11:21.087Z","type":"event","payload":{"id":"7","event_seq":188,"order":{"request_ordinal":49,"output_index":1,"sequence_number":1346},"msg":{"type":"patch_apply_begin","call_id":"call_TLXQI1b5wf0ifxtqxqjyqmFE","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -261,2 +261,21 @@\n \n+### 7.3 变更包结构（DevBooks 既有范式）\n+\n+每个 change package 至少包含：\n+\n+```\n+<change-root>/<change-id>/\n+  proposal.md\n+  design.md\n+  tasks.md\n+  verification.md\n+  validation.md (可选，VQ/阈值/证据计划)\n+  compliance.md (可选，合规影响与证据索引)\n+  specs/...\n+  evidence/...\n+  prototype/... (可选，prototype 轨)\n+```\n+\n+- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n+\n ### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n@@ -294,21 +313,2 @@\n 这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n-\n-### 7.3 变更包结构（DevBooks 既有范式）\n-\n-每个 change package 至少包含：\n-\n-```\n-<change-root>/<change-id>/\n-  proposal.md\n-  design.md\n-  tasks.md\n-  verification.md\n-  validation.md (可选，VQ/阈值/证据计划)\n-  compliance.md (可选，合规影响与证据索引)\n-  specs/...\n-  evidence/...\n-  prototype/... (可选，prototype 轨)\n-```\n-\n-- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n \n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - 如存在不确定性/高风险：先生成 validation 包（VQ/阈值/证据计划）再进入 Apply\n   - 如命中合规风险：补充 compliance 影响声明与证据计划\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - 如存在不确定性/高风险：先生成 validation 包（VQ/阈值/证据计划）再进入 Apply\n   - 如命中合规风险：补充 compliance 影响声明与证据计划\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:405:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:337:{"timestamp":"2026-01-20T12:11:53.169Z","type":"event","payload":{"id":"7","event_seq":196,"order":{"request_ordinal":51,"output_index":0,"sequence_number":296},"msg":{"type":"patch_apply_begin","call_id":"call_UQfXL72C5LoifGVRVzXokQhR","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -1135,2 +1135,12 @@\n \n+### 23.5 适配 UCA 等特定项目的方式（保持框架通用性）\n+\n+框架不直接嫁接任何特定项目流程。要适配特定项目，只允许通过“扩展包 + Doctrine/Protocol 映射”完成：\n+\n+- 把“理念/规约/机制”抽象成 Doctrine/Constraints/Patterns\n+- 把“协议/流程模板/策略库”抽象成 Protocols/Recipes\n+- 把专有名词映射到 glossary，而不是进入主干流程\n+\n+这样既保持框架简洁性，又允许实例化为任何规模项目（含 UCA）。\n+\n ---\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - 如存在不确定性/高风险：先生成 validation 包（VQ/阈值/证据计划）再进入 Apply\n   - 如命中合规风险：补充 compliance 影响声明与证据计划\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - 如存在不确定性/高风险：先生成 validation 包（VQ/阈值/证据计划）再进入 Apply\n   - 如命中合规风险：补充 compliance 影响声明与证据计划\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n### 23.5 适配 UCA 等特定项目的方式（保持框架通用性）\n\n框架不直接嫁接任何特定项目流程。要适配特定项目，只允许通过“扩展包 + Doctrine/Protocol 映射”完成：\n\n- 把“理念/规约/机制”抽象成 Doctrine/Constraints/Patterns\n- 把“协议/流程模板/策略库”抽象成 Protocols/Recipes\n- 把专有名词映射到 glossary，而不是进入主干流程\n\n这样既保持框架简洁性，又允许实例化为任何规模项目（含 UCA）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/174/exec-call_pwzkRPz24bYXgf6taMvtPo1a.txt:406:/Users/ozbombor/.codex/sessions/2026/01/20/rollout-2026-01-20T19-16-06-48aeba3d-70bb-46f1-b4a8-8f122022901a.jsonl:350:{"timestamp":"2026-01-20T12:12:32.495Z","type":"event","payload":{"id":"7","event_seq":204,"order":{"request_ordinal":53,"output_index":0,"sequence_number":454},"msg":{"type":"patch_apply_begin","call_id":"call_pPpZxEH2glMRKHUuzGsm4edI","auto_approved":true,"changes":{"/Users/ozbombor/Projects/AI软件开发系统设计-2.md":{"update":{"unified_diff":"@@ -314,2 +314,12 @@\n \n+最小映射表（示例，不绑定具体项目）：\n+\n+| 输入工件（组织/领域） | 框架抽象 | 进入系统的位置 | 说明 |\n+|---|---|---|---|\n+| 理念/世界观/价值主张 | Doctrine | `specs/_meta/doctrine/` | 只保留不可违背原则与边界 |\n+| 硬规约/MUST/SHALL NOT | Constraints | `specs/_meta/doctrine/constraints.*` | 供闸门与审计引用 |\n+| 机制范式/最佳实践 | Patterns/Recipes | `specs/_meta/patterns/` | 作为优先解法库，不强制 |\n+| 协议/互操作规范 | Protocol Suite | `specs/_meta/protocols/` | 可机读合同 + 版本策略 |\n+| 策略库/流程模板 | Recipes/Playbooks | `specs/_meta/patterns/` 或 Pack | 用作可执行模板 |\n+\n ---\n","move_path":null,"original_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - 如存在不确定性/高风险：先生成 validation 包（VQ/阈值/证据计划）再进入 Apply\n   - 如命中合规风险：补充 compliance 影响声明与证据计划\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n### 23.5 适配 UCA 等特定项目的方式（保持框架通用性）\n\n框架不直接嫁接任何特定项目流程。要适配特定项目，只允许通过“扩展包 + Doctrine/Protocol 映射”完成：\n\n- 把“理念/规约/机制”抽象成 Doctrine/Constraints/Patterns\n- 把“协议/流程模板/策略库”抽象成 Protocols/Recipes\n- 把专有名词映射到 glossary，而不是进入主干流程\n\n这样既保持框架简洁性，又允许实例化为任何规模项目（含 UCA）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n","new_content":"# AI软件开发系统设计2\n\n> 统一叙事：Genesis（蓝图/创世） + The Knife（切片/风险迁移） + DevBooks（执行/证据闭环）\n>\n> 本文是“完整版系统描述（自包含）”。\n>\n> 特殊约束：`SFF-四议题回答` 已存在于本机 `~/projects/`，本文**不重复输出其正文**，仅作为**规范性引用**。\n>\n> - 规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`\n> - 方法论引用（OmniMind/完备性工具集/互斥正交/TRIZ 完备性法则）：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n> - DevBooks 代码与协议参考（本机仓库）：`/Users/ozbombor/projects/dev-playbooks-cn/`\n\n---\n\n## 0. 元信息\n\n- 系统代号：The Software Forge（SFF）\n- 文档名：AI软件开发系统设计-gpt\n- 版本：v0.1（设计稿）\n- 适用对象：以 LLM（Claude/Codex 等）作为主要执行者的 AI 软件工程\n- 适用范围：覆盖软件全生命周期（0→1、1→n、n→n+1）\n- 关键决策（由用户确认）：\n  - 体验层：**完整设计系统（Complete Design System）**\n  - 控制策略：**硬闸门（Hard Gates / Block-by-default）**\n  - 变更策略：**风险迁移（Risk Migration / Expand-Contract/Strangler/Branch-by-Abstraction 优先）**\n\n---\n\n## 1. 背景：AI 时代的软件工程问题不是“会不会写代码”，而是“能否长期正确地交付”\n\nLLM 在“生成代码”上极强，但在软件工程的核心要求上存在系统性矛盾：\n\n- 人类脑中的隐性知识（审美、偏好、默认规则、未来预期）对人类开发可“靠共识补全”，对 AI 开发则会变成持续的信息差与漂移源。\n- LLM 会倾向“短期完成任务”“取悦用户”“在缺证据时编造”，导致：伪完成、技术债、架构腐化、可维护性失控、上下文溢出无法收敛。\n- 软件工程的关键不是一次性交付，而是：长期演化、可回滚、可审计、可验证、可争议处理。\n\n因此，系统必须把“LLM 的缺陷”转化为“工程机制”：通过外部持久化真理、强制角色隔离、证据闸门、切片算法与风险迁移路径，把不可控变成可控。\n\n> 本系统的缺陷-对策完备映射见规范性引用：`/Users/ozbombor/projects/SFF-四议题回答.md`。\n\n---\n\n## 2. 总目标（Goal）与反目标（Non-goals）\n\n### 2.1 Goal\n\n构建一套面向 AI 编程的全生命周期体系，使项目在 0→1 与持续迭代中满足：\n\n1. **可收敛（Convergent）**：任何任务最终能在有限上下文与有限迭代内收敛；超限能自动熔断并回退到更上游阶段。\n2. **可验证（Verifiable）**：完成由客观锚点与证据定义，而非 AI 自评。\n3. **可追溯（Traceable）**：设计/需求/决策 → 任务 → 测试/锚点 → 证据 → 归档真理，链路可审计。\n4. **可演进（Evolvable）**：面对 n→n+1（架构升级/迁移/重构），能以风险迁移方式分片推进，且每片可独立 Green/可回滚。\n5. **体验一致（UX-consistent）**：在“完整设计系统”约束下，AI 生成的 UI 能稳定对齐期望风格与组件规范。\n\n### 2.2 Non-goals\n\n- 不追求一次性把所有真实世界工程细节自动化；优先“硬闸门 + 明确回退路径”。\n- 不把 LLM 视为可信真理源；系统不允许“LLM 自证正确”。\n- 不强制“以代码行数/文件数”为唯一拆分指标（避免代理指标驱动）；仅作为风险信号之一。\n\n---\n\n## 3. 方法论基座（必须内化为系统行为）\n\n本系统的设计与评审遵循两套“上层操作系统”：\n\n1) **完备性工具集（Completeness Toolkit）**\n- 系统思维（要素/连接/目的/层级）\n- TRIZ 完备性法则（动力/传动/执行/控制四部件）\n- MECE 完全穷尽（流程/要素/矩阵/二分）\n- 多维度扫描（时空/结构/功能/用户/环境/生命周期/质量属性）\n\n2) **互斥/正交原则（Mutual Exclusivity / Orthogonality）**\n- 分类基于单一维度，避免交叉\n- 模块职责单一、高内聚低耦合\n- 接口隔离与边界清晰\n\n3) **OmniMind 四阶段（解构→探索→验证→综合） + 元认知监控**\n- 自我感知\n- 置信度量化\n- 偏见审查（尤其是：谄媚/短视/漂移）\n\n> 方法论原文参考：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n\n在系统层面，上述方法论被固化为：\n- Genesis：强制“边界/术语/不变量/设计系统/质量底线”的显性化产物\n- The Knife：强制“MECE 切片不变量 + 风险迁移路径 + 预算熔断”\n- DevBooks：强制“证据闸门 + 角色隔离 + 归档真理”\n\n---\n\n## 4. 系统架构总览（TRIZ 完备性：动力/传动/执行/控制）\n\n### 4.1 三大组件\n\n1) **Genesis（Blueprint / 创世蓝图层）**\n- 输入：模糊 Idea / 业务愿景 / 人类隐性偏好\n- 输出：可持久化真理（Truth），包含：\n  - 项目宪法/质量底线（Constitution）\n  - 统一语言（Glossary）\n  - 系统边界与上下文（Boundary/Contexts）\n  - 关键场景与验收 AC（Scenarios/AC）\n  - 数据与契约（Data contracts / Integrations）\n  - 运维与生命周期（Operability）\n  - **完整设计系统（Design System）**\n  - 风险/假设/开放问题与决策日志\n\n2) **The Knife（Slicer / 切片与风险迁移层）**\n- 输入：Epic（可以是 0→1 也可以是 n→n+1）\n- 输出：一组可拓扑排序、可独立 Green、可回滚的 DevBooks Change Packages\n- 关键能力：\n  - MECE 覆盖不变量\n  - 风险迁移范式（Expand-Contract/Strangler/Branch-by-Abstraction）\n  - 预算熔断与递归切分\n\n3) **DevBooks（Executor / 执行闭环层）**\n- 输入：一个 Change Package（proposal/design/tasks/specs/verification/evidence）\n- 输出：归档后的真理更新（specs/）+ 可审计历史（archived change packages）\n- 核心机制：\n  - 角色隔离（Test Owner 与 Coder 必须分离；宪法硬约束）\n  - 基于证据的完成（Green evidence）\n  - 质量闸门脚本（change-check 等）\n  - 三层同步（Draft → Staged → Truth）\n\n### 4.2 动力/传动/执行/控制映射\n\n- 动力（Why）：Genesis 的愿景、价值信号、成功指标\n- 传动（How to move）：Knife 的切片与依赖拓扑、迁移路径\n- 执行（Do）：DevBooks 的 Apply（测试/实现/评审）\n- 控制（Control）：硬闸门、证据链、宪法、适应度函数、熔断与回退\n\n---\n\n## 5. 与 DevBooks 的一致性与增量策略（基于实际代码）\n\n本系统不重写 DevBooks，而是在其上增量补齐上游与切片控制。\n\n### 5.1 DevBooks 现有可复用事实（来自 `~/projects/dev-playbooks-cn`）\n\n- 宪法：`/Users/ozbombor/projects/dev-playbooks-cn/dev-playbooks/constitution.md`\n- 变更包脚手架（含 prototype 轨）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-scaffold.sh`\n- 质量闸门（Green evidence、任务完成率、角色边界等）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/change-check.sh`\n- 隐式变更探测（依赖/配置/构建）：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-spec-contract/scripts/implicit-change-detect.sh`\n- 全量审计扫描：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/audit-scope.sh`\n- 熵度量体系与热点信号：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-entropy-monitor/`\n\n### 5.2 你已选择“硬闸门”，因此必须补齐的 DevBooks 增量闸门\n\nDevBooks 已有多项闸门，但缺少针对 Knife/Genesis 的硬阻断接口。本系统要求新增（设计层面）：\n\n1) **Change Size Gate（硬闸门）**\n- 在进入 Apply（写 tests/src）前阻断超限 change。\n- 在 Archive 前基于实际 diff 再次阻断。\n\n2) **Epic Alignment Gate（硬闸门）**\n- 如果 change 属于某个 Epic（Knife 输出），则强制：\n  - 本 change 的 AC 子集与 Knife 计划一致\n  - 不与其它 slice AC 重叠\n\n3) **Design System Compliance Gate（硬闸门，因你选择完整设计系统）**\n- UI/体验相关变更必须引用并遵循设计系统，并在 verification 里提供证据。\n\n4) **Validation / Hard Problem Gate（硬闸门）**\n- 高不确定性/高风险问题必须先形成可证伪验证包（VQ/阈值/证据计划），否则禁止进入 Apply。\n\n5) **Prototype Gate（硬闸门）**\n- 原型必须可复现、可回写合同（AC/约束/测试锚点），禁止“原型直上生产”。\n\n6) **Compliance/Policy Gate（硬闸门）**\n- 存在外部约束时，必须在 Genesis 就绪；在 Change 期必须声明影响并归档证据。\n\n7) **Extension Pack Integrity Gate（硬闸门）**\n- 领域/组织协议必须通过扩展包映射为可检查项，缺失映射不得启用。\n\n这些闸门的触发方式、输出格式、失败回退路径在后文定义。\n\n---\n\n## 6. 统一叙事：从创世到永恒（一年可持续迭代）\n\n### 6.1 Day 0：只有一个想法（Idea）\n\n- 进入 Genesis：把想法解构成边界/术语/场景/质量/设计系统。\n- 产出 Genesis Truth（可被引用、可被审计）。\n- 达到 Genesis DoR（Definition of Ready）后，才允许进入 Knife/DevBooks。\n\n### 6.2 Week 1：第一个 Epic（0→1 或 n→n+1）\n\n- Knife 基于风险迁移优先，把 Epic 切成可独立 Green 的 slices。\n- 输出一个 Knife 计划（含不变量、依赖拓扑、预算与熔断策略）。\n\n### 6.3 Day 7~30：DevBooks 执行每个 slice\n\n- 每个 slice = 一个 DevBooks change package\n- 严格角色隔离：Test Owner 先 Red，Coder 后 Green\n- 通过硬闸门与证据链才允许归档\n\n### 6.4 Month 2~12：持续演化\n\n- 新需求：走 Knife（若小变更可直接变更包；若 Epic 需切片）\n- 架构升级：走风险迁移 Epic（Expand-Contract/Strangler）\n- 失败回流：\n  - slice 超限/依赖错误/无法 Green → 回流 Knife 重切\n  - 反复审美争议/术语漂移/质量底线模糊 → 回流 Genesis 修宪/补设计系统\n\n---\n\n## 7. 真理与变更的落盘协议（Protocol-first / Truth-first）\n\n### 7.1 总体目录（以 DevBooks 为准）\n\n在任意项目中，至少存在：\n\n- `<truth-root>/`：只读真理（最终规格与长期知识）\n- `<change-root>/`：变更包工作区（一次变更的全部产物）\n\nDevBooks 的 v2 配置协议示例（见其规格：`dev-playbooks/specs/config-protocol/spec.md`）：\n\n```yaml\n# .devbooks/config.yaml\nroot: dev-playbooks/\nconstitution: constitution.md\nproject: project.md\npaths:\n  specs: specs/\n  changes: changes/\n  scripts: scripts/\nconstraints:\n  role_isolation: true\n  coder_no_tests: true\n  require_constitution: true\ndoctrine:\n  required: true\nprotocols:\n  registry: specs/_meta/protocols/registry.yaml\nextensions:\n  enabled_packs: []\nfitness:\n  enabled: true\n  mode: warn\n  rules_file: specs/architecture/fitness-rules.md\ntracing:\n  ac_required: true\n  coverage_threshold: 80\n```\n\n### 7.2 Genesis 的真理落点（建议）\n\n在 `<truth-root>/specs/_meta/` 下新增：\n\n- `specs/_meta/genesis/`：创世蓝图（项目级长期真理）\n- `specs/_meta/design-system/`：完整设计系统（你已选择为硬门槛）\n- `specs/_meta/epics/`：Knife 输出的 Epic 计划与切片不变量\n- `specs/_meta/doctrine/`：项目宪章/理念/不可违背原则（Project Doctrine）\n- `specs/_meta/protocols/`：对外/对内协议与互操作合同（Protocol Suite）\n- `specs/_meta/packs/`：扩展包（组织/领域协议的可机读映射）\n- `specs/_meta/compliance/`：合规/政策研究真理（外部约束）\n- `specs/_meta/validation/`：验证包/原型/难题攻关的长期证据与结论\n\n> 注：本机 `dev-playbooks-cn` 仓库当前已有 `dev-playbooks/specs/_meta/`，但尚未包含 `genesis/` 与 `design-system/` 子树；这是本系统对 DevBooks 的增量设计要求。\n\n### 7.3 变更包结构（DevBooks 既有范式）\n\n每个 change package 至少包含：\n\n```\n<change-root>/<change-id>/\n  proposal.md\n  design.md\n  tasks.md\n  verification.md\n  validation.md (可选，VQ/阈值/证据计划)\n  compliance.md (可选，合规影响与证据索引)\n  specs/...\n  evidence/...\n  prototype/... (可选，prototype 轨)\n```\n\n- change-id 受格式约束（DevBooks 脚手架要求）：`YYYYMMDD-HHMM-verb-...`\n\n### 7.4 扩展包（Extension Packs）：把领域/组织协议变成可配置依赖\n\n为保持框架通用性，领域/组织特有的流程、协议、合规要求不得写入主干流程描述。\n系统以“扩展包（Extension Pack）”承载外部协议：扩展包用机读映射表将协议条款映射为风险旗标、闸门附加检查项与证据要求。\n主干仅引用扩展包 ID；专有术语仅允许出现在扩展包内，并通过 glossary 映射到主干统一语言。\n\n建议落点（Truth 内）：\n\n- `specs/_meta/packs/<pack-id>/pack.yaml`：元信息（版本/适用范围/风险旗标表）\n- `specs/_meta/packs/<pack-id>/protocols/`：协议原文或摘要（可快照化）\n- `specs/_meta/packs/<pack-id>/mappings/`：协议 → 检查项/闸门/证据\n- `specs/_meta/packs/<pack-id>/templates/`：proposal/design/verification 模板片段（可选）\n- `specs/_meta/packs/<pack-id>/gates/`：闸门附加检查清单（不改主闸门）\n\n配置示例（概念层，不强制实现）：\n\n```yaml\n# .devbooks/config.yaml\nextensions:\n  enabled_packs:\n    - \"<pack-id-1>\"\n    - \"<pack-id-2>\"\n```\n\n### 7.5 Project Doctrine / Protocol Layer（去特化的协议层）\n\n为避免把具体组织机制硬编码进框架，系统增加“Doctrine/Protocol”抽象层：\n\n- Doctrine：项目级第一性原理/不可违背约束（可视作“项目宪法的更上游”）\n- Protocol Suite：可互操作的合同（状态机/事件语义/版本策略/兼容策略）\n- Pattern/Recipe：优先解法库与可执行模板（可复用、可组合、可替换）\n\n这些内容只以**抽象语义**存在于主干，具体实例通过扩展包映射落地。\n\n最小映射表（示例，不绑定具体项目）：\n\n| 输入工件（组织/领域） | 框架抽象 | 进入系统的位置 | 说明 |\n|---|---|---|---|\n| 理念/世界观/价值主张 | Doctrine | `specs/_meta/doctrine/` | 只保留不可违背原则与边界 |\n| 硬规约/MUST/SHALL NOT | Constraints | `specs/_meta/doctrine/constraints.*` | 供闸门与审计引用 |\n| 机制范式/最佳实践 | Patterns/Recipes | `specs/_meta/patterns/` | 作为优先解法库，不强制 |\n| 协议/互操作规范 | Protocol Suite | `specs/_meta/protocols/` | 可机读合同 + 版本策略 |\n| 策略库/流程模板 | Recipes/Playbooks | `specs/_meta/patterns/` 或 Pack | 用作可执行模板 |\n\n---\n\n## 8. Genesis（创世蓝图层）——完整设计系统 + DoR（硬闸门）\n\n### 8.1 Genesis 的定位\n\nGenesis 的目标不是“写更厚的 PRD”，而是：\n\n- 消除人机信息差，防止 AI 在 0→1 过程中“短期完成任务、长期烂尾”。\n- 把不可形式化的偏好（审美/交互）尽可能变成“可验证证据与可复用规则”。\n- 把长期演进规则前置：版本/弃用/迁移/回滚策略。\n\n### 8.2 Genesis 的输出产物（结构化真理）\n\nGenesis 的完整产物清单与 Schema 细节请见规范性引用：\n- `SFF-四议题回答` 的议题二（Genesis 完备性定义）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文仅给出系统层面的落地约束（硬闸门视角）：\n\n- 必须存在：\n  - 系统边界（in/out of scope）\n  - 统一语言（术语表 + 不变量）\n  - 核心场景（含异常/补偿路径）\n  - 数据契约与 SoT（source of truth）\n  - 对外集成契约（auth/timeout/retry/error semantics）\n  - 质量属性底线（性能/可靠性/安全/可维护）\n  - 运维生命周期（发布/回滚/观测）\n  - 风险/假设/开放问题（可追踪）\n  - 决策日志（可追溯）\n\n### 8.3 背景调研/合规研究（Policy & Compliance Research）——外部约束的系统化落盘\n\n定位：把政策/合规/平台规则/合同条款转为“可执行约束 + 证据计划”，避免执行期猜测。\n\n最小闭环产物（必须）：\n\n- `policy-scope.md`：适用范围与不适用范围（法域/行业/用户类型/分发渠道）\n- `compliance-assumptions.md`：假设与开放问题（含 owner/解决阶段）\n- `data-and-model-boundaries.md`：数据与模型使用边界（允许/禁止/保留期/地域）\n- `controls-and-evidence-plan.md`：控制项 → 验证方式 → 证据落点\n\n扩展项（触发风险旗标时必须补齐）：\n\n- `vendor-and-licenses.md`：第三方/模型供应商 ToS 与许可约束\n- `jurisdiction-matrix.md`：多法域/多行业适用性矩阵\n- `risk-acceptance.md`：风险接受记录（谁/何时/范围/回滚）\n- `user-disclosures.md`：对用户告知要点与 UI/文档落点\n\n原则：合规研究输出“工程可执行约束”，不输出法条长文；细节由实例化补全，框架保持通用。\n\n### 8.4 难题判定（Hard Problem Declaration）与探索准备\n\n当问题满足“高不确定性/高风险/验收锚点无法确定”等条件时，必须进入难题攻关轨道：\n\n- 先形成可证伪假设与验证计划（VQ/阈值/证据计划/停止条件）\n- 再进入 Knife 切片与 DevBooks Apply\n\n禁止在缺少验证计划与停止条件的情况下进入 Apply。\n\n### 8.5 完整设计系统（硬门槛，DoR 强制项）\n\n你选择“完整设计系统”，因此 Genesis 必须产出以下最小闭环：\n\n- 设计 Token（机器可消费）\n  - 颜色（语义化：primary/success/danger/warning/info）\n  - 字体（字号/字重/行高/字距）\n  - 间距与栅格（spacing scale、breakpoints）\n  - 圆角/阴影/边框/动效 token\n\n- 组件规范（可验收）\n  - 组件清单（Button/Input/Modal/Table/Form/Toast/Dropdown 等）\n  - 变体与状态（hover/active/disabled/loading/error/empty）\n  - 交互规则（键盘、焦点管理、快捷键）\n  - 可访问性（aria、对比度、焦点可见性）\n\n- 交互模式库（Patterns）\n  - 注册/登录/表单提交/加载/空状态/错误态/权限不足\n  - 信息架构与导航（侧边栏/面包屑/全局搜索）\n\n- 内容与语气（Content rules）\n  - 术语一致性（与 glossary 对齐）\n  - 错误文案风格、引导与确认语\n\n- 参考屏幕（Reference screens）\n  - 至少提供关键页面的视觉参考（截图/链接/描述）\n  - 明确“现代化”的可操作定义（例如：留白、字号、对比、层级、动效节制等）\n\n### 8.6 Genesis DoR（Definition of Ready，硬闸门）\n\n满足以下条件，才允许 Knife 输出切片并允许 DevBooks 进入 Apply：\n\n1. 统一语言与关键不变量可引用（glossary 不为空）\n2. 核心场景（主流程 + 关键异常）具备可验收 AC\n3. 数据契约与 SoT 明确\n4. 对外集成契约明确（至少：认证、错误语义、重试策略）\n5. 质量属性底线（至少：安全、性能、可观测）有阈值或“明确填 none”\n6. 运维生命周期具备（发布/回滚/观测窗口）\n7. 设计系统满足 8.5 的最小闭环\n8. 风险/假设/开放问题被显式记录并绑定 owner/解决阶段\n9. 决策日志存在且可追溯\n10. 一致性检查通过（术语/场景/数据/规则互相引用不断裂；细则见 `SFF-四议题回答`）\n11. 合规/政策研究最小闭环完成（如适用）\n12. 若存在难题判定：验证包（VQ/阈值/证据计划/停止条件）已就绪\n\n失败回退：任何 DoR 不满足 → 回到 Genesis 补齐；禁止“先写代码再补”。\n\n---\n\n## 9. The Knife（切片层）——风险迁移优先 + 硬正确性不变量\n\n### 9.1 Knife 的定位\n\nKnife 的目标不是“拆任务清单”，而是：\n\n- 把非线性 Epic 变成一条**可拓扑排序**、每步都能**独立 Green**、且每步都**可回滚**的变更链。\n- 把“上下文窗口限制”转化为“系统级预算与熔断机制”。\n- 通过不变量保证切片**不可多不可少**，并避免“拆分导致系统处于不可运行中间态”。\n\nKnife 的详细算法、示例与熔断策略请见规范性引用：\n- `SFF-四议题回答` 的议题三（The Knife）：`/Users/ozbombor/projects/SFF-四议题回答.md`\n\n本文将 Knife 的关键要求提升为“硬闸门合同”。\n\n### 9.2 Knife 输出物（Knife Plan / Slice Manifest）\n\nKnife 必须输出一个可机读的计划（建议 `specs/_meta/epics/<epic-id>/knife-plan.md` + 可选 JSON）：\n\n- Epic 元信息：目标态、约束、风险、非目标\n- 完整 AC 列表（Epic.AC）\n- 切片列表（Slices）：\n  - slice_id（映射到 change-id 规则）\n  - AC 子集（Slice.AC）\n  - 迁移范式（risk migration pattern）\n  - Produce/Consume/Modify 工件清单（用于依赖推导）\n  - 验收锚点（tests/commands/evidence）\n  - 回滚策略\n  - 预算（complexity budget）\n\n### 9.3 Knife 的硬正确性不变量（必须可检查）\n\n1) **MECE 覆盖**\n- `Union(Slice.AC) == Epic.AC`\n- `∀i≠j, Intersection(Slice_i.AC, Slice_j.AC) == ∅`\n\n2) **可独立 Green**\n- 每个 slice 都必须定义至少一个确定性锚点，并在主分支可 Green。\n- 不允许“半截代码导致编译失败/测试全挂”的 slice。\n\n3) **风险迁移一致性**\n- 高风险变更必须采用成熟迁移范式并显式写出“兼容窗口 + 清理时机”。\n\n4) **预算熔断**\n- slice 若超预算或不可验证 → 必须递归切分，或回到 Genesis 补齐信息。\n\n### 9.4 风险迁移范式库（优先级顺序）\n\n> 这些范式是“站在巨人肩膀上”的可复用策略，避免刀切错导致中间态崩坏。\n\n- Expand/Contract（数据库/契约迁移）\n  - Expand schema（兼容旧读写）\n  - Backfill\n  - Switch reads\n  - Contract（删除旧字段/路径）\n\n- Strangler Fig（系统/模块替换）\n  - 新路径旁路建立\n  - 流量逐步切换\n  - 旧路径逐步下线\n\n- Branch by Abstraction（大重构/替换实现）\n  - 抽象层引入\n  - 双实现并存\n  - 切换调用方\n  - 清理旧实现\n\n- Feature flag + Progressive delivery（行为变更）\n  - 默认关闭，先观测\n  - 灰度开启\n  - 全量后清理\n\n### 9.5 Knife 的“过载熔断”（硬闸门策略）\n\nKnife 必须对每个 slice 计算“可收敛预算”，超限则递归切分。\n\n建议预算信号（非单指标）：\n\n- 文件触达数（files_touched）\n- 跨模块数（modules_touched）\n- 对外契约/数据迁移/安全变更标志（risk_flags）\n- 验收成本（verification_cost：需要的测试类型、MANUAL 项数）\n- 热点权重（hotspot_weight：触碰高 churn 文件加权）\n\n输出应包含：\n- 预算阈值（budget）\n- 计算值（score）\n- 超限处置（递归切分维度：场景/生命周期/工件/质量属性）\n\n---\n\n## 10. DevBooks（执行层）——硬闸门 + 证据链 + 角色隔离\n\n### 10.1 DevBooks 的定位（你已校准的理解）\n\n- DevBooks 是“盖房子”的工程化闭环：把已确定的蓝图/切片落实为可验证的产物。\n- DevBooks 既可完成 0→1，也可完成 1→n；关键不在阶段，而在“每个 change 的闭环可收敛”。\n\n### 10.2 DevBooks 的硬约束（来自其宪法与闸门）\n\n- 角色隔离：Test Owner 与 Coder 必须分离（`dev-playbooks/constitution.md`）\n- Coder 禁止改 tests/（同上）\n- 归档前必须有 Green evidence（`change-check.sh`）\n\n### 10.3 你选择“硬闸门”后，DevBooks 必须增加的三类新闸门\n\n1) **Change Size Gate**（阻断超限 change）\n2) **Epic Alignment Gate**（阻断与 Knife 计划不一致/AC 重叠）\n3) **Design System Compliance Gate**（阻断不符合完整设计系统的 UI 变更）\n\n### 10.4 变更类型：交付型 / 研究型 / 原型型（统一走证据闭环）\n\n为保证框架通用且可收敛，变更包分为三类（不改变 DevBooks 机制，只改变“完成判据”）：\n\n- 交付型（Delivery）：以功能/行为交付为主，完成标准以测试与证据为准。\n- 研究型（Research/Investigation）：以结论与可证伪证据为主，完成标准以“结论可复现 + 影响可落盘”。\n- 原型型（Prototype）：以验证假设为主，必须可复现；禁止直接上生产。\n\n三类变更的共同要求：\n\n- 产物可追溯（proposal/design/verification/evidence）\n- 证据可定位、可复现\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n\n这些闸门必须以脚本/可机读方式实现，避免仅停留在“流程建议”。\n\n---\n\n## 11. 硬闸门体系（Gate System）——分层、可执行、可回退\n\n### 11.1 闸门分层（从上到下）\n\n- G0：Genesis DoR Gate（蓝图是否允许开工）\n- G1：Knife Correctness Gate（切片是否 MECE + 可独立 Green + 预算可收敛）\n- G2：DevBooks Proposal/Design/Plan/Test/Code/Review Gate（执行闭环）\n- G3：Archive Gate（证据、追溯、合规、回滚）\n\n### 11.4 新增闸门（Research / Prototype / Hard Problem / Compliance / Packs）\n\n为了覆盖高不确定性与外部约束，系统新增以下闸门：\n\n- G-HP-001 Hard Problem Declaration Gate：高不确定性问题必须形成验证包（VQ/阈值/证据计划/停止条件）\n- G-RES-001 Research Sufficiency Gate：研究结果必须映射为约束/风险旗标/验收锚点\n- G-PROT-001 Prototype Reproducibility Gate：原型必须可复现，有明确输入/输出/环境\n- G-PROT-002 Prototype-to-Production Bridge Gate：原型结论必须转成可执行合同，禁止原型直上生产\n- G-COMP-001 Compliance/Policy Gate：外部约束需在 Genesis 就绪，变更期需声明影响并归档证据\n- G-PACK-001 Extension Pack Integrity Gate：扩展包必须提供协议→检查项映射，否则不得启用\n\n### 11.2 闸门失败时的唯一合法回退路径\n\n- G0 失败 → 回到 Genesis 补齐（禁止进入 Knife/DevBooks Apply）\n- G1 失败 → 回到 Knife 递归切分或回到 Genesis 补信息\n- G2 失败 → 回到对应阶段修正（或拆包，禁止“部分完成继续前进”）\n- G3 失败 → 禁止归档；补证据/补追溯/补声明或拆包\n\n### 11.3 与 DevBooks 现有脚本的对齐\n\n- DevBooks 的 `change-check.sh` 已覆盖部分 G2/G3；本系统要求其扩展覆盖 G1/G0 的引用检查（至少通过文件存在性+引用校验+预算阈值校验）。\n\n---\n\n## 12. Change Size Gate（硬闸门）——避免上下文爆炸与伪收敛\n\n你已选择“硬闸门”，因此需要明确定义“上限是什么”与“怎么计算”。\n\n### 12.1 为什么必须硬闸门\n\n- 单个 change 过大时，LLM 会在上下文窗口内产生：遗漏、幻觉、漂移、伪完成、不可回滚。\n- 过大变更也会让验证锚点失真（测试绿但计划未完成、或只覆盖 happy path）。\n\n### 12.2 上限定义（多信号 + 风险旗标）\n\n本系统采用两层阈值：\n\nA) **硬风险旗标（任一命中即默认要求拆分/升级 Epic）**\n- 对外契约（API/Schema/Event）\n- 数据迁移（schema 变更、回填、幂等/一致性要求）\n- 安全/权限边界\n- 构建系统/CI/依赖锁文件\n- 跨模块变更（按架构边界定义）\n\nB) **软预算信号（累计超阈值则阻断）**\n- 影响文件数\n- 变更行数（仅作为审查成本信号）\n- tasks 数量、AC 数量、MANUAL 数量\n- 热点权重（触达高 churn 文件加权）\n\n> DevBooks 已存在“≤200 行/子任务”的默认目标与“PR 尺度表”，可作为初始阈值来源：\n> - `skills/devbooks-implementation-plan/references/编码计划提示词.md`\n> - `skills/devbooks-reviewer/references/PR模板与指南.md`\n\n### 12.3 计算建议（可机读的预算分数）\n\n示例（你可在实现时调整权重；此处为设计合同）：\n\n- score = 3*modules + 1*files + 4*novelty + 5*risk + 2*verification_cost + 3*hotspot_weight\n- 若命中硬风险旗标：强制 `risk += RISK_HIGH`\n\n阈值策略：\n- score <= BUDGET：允许进入 Apply\n- score > BUDGET：硬阻断，必须 Knife 递归切分\n\n\n### 12.4 直觉确认：Change 包上限会随模型升级而变化\n\n你的直觉成立：**DevBooks 单次 change 的可收敛上限是动态的**，会随着以下能力变化而变化：\n\n- **模型能力**：更强的推理/规划/代码理解能力、更大的上下文窗口、更好的自我校验倾向 → 在同等约束下可承载更大范围。\n- **工具能力**：有无 CKB/MCP（符号引用/调用图/热点）→ 影响“空间感知缺失”的补偿力度。\n- **代码库健康度**：熵（热点/耦合/测试质量）越差，同样的行数/文件数风险更高，预算应更保守。\n\n因此，本系统不把 change 上限定义为一个常数，而定义为一个**可校准的预算函数**：\n\n- `EffectiveBudget = BaseBudget(model_profile) × EnvMultiplier(tooling) × RepoMultiplier(entropy) × RiskMultiplier(risk_flags)`\n\n并且在“硬闸门”策略下：\n\n- 预算不足 → **必须切分/升级 Epic**，而不是靠“更努力的提示词”硬做。\n\n### 12.5 最佳方案：用“校准套件（Calibration Suite）”求解预算，而不是靠拍脑袋\n\n你提出的“设计多个 demo 测试得到最佳结果”是方向正确的，但最佳实践不是零散 demo，而是建设一个**可复现、可回归、可量化**的校准体系：\n\n#### 12.5.1 产物：`Change Budget Calibration Suite`\n\n建立一套固定的校准用例集（benchmarks），覆盖 DevBooks 真实工作流中的主要变更类型与风险面，并为每个用例提供确定性裁判（tests/gates/evidence）。\n\n- **用例分类（MECE，按风险面）**：\n  1) 纯代码局部变更（低风险）\n  2) 跨模块重构/抽象引入（结构风险）\n  3) 对外契约变更（API/Schema/Event，兼容风险）\n  4) 数据迁移（Expand/Contract，运行风险）\n  5) 构建/依赖/CI 变更（工程系统风险）\n  6) UI/交互变更（设计系统一致性风险）\n\n- **复杂度梯度（每类至少 3 档）**：S/M/L（保证“同一类型可随规模递增”）。\n\n- **每个用例的固定输出合同**（必须能被脚本判定 Pass/Fail）：\n  - 必须产生 DevBooks 变更包产物（proposal/design/tasks/verification/evidence）\n  - 必须通过 Green evidence gate（以及所有启用的硬闸门）\n  - 必须满足 AC 追溯（建议接入 `ac-trace-check.sh`）\n  - 若为 UI 用例：必须满足 Design System Compliance Gate\n\n#### 12.5.2 度量：什么叫“最佳预算”\n\n对每个模型/环境组合，运行校准套件，记录：\n\n- `success_rate`：一次性从 proposal→archive 完成且全闸门通过的比例\n- `iterations_to_green`：达到 Green 的轮数（含回退/重切）\n- `false_completion_rate`：被闸门拦截的“伪完成”比例（越低越好）\n- `time_to_green`：端到端耗时（可选）\n- `scope_spill_rate`：未声明范围变更/隐式变更未声明比例（可用 implicit-change-detect 报告统计）\n\n然后定义“可用预算”的目标函数（示例，可按团队调参）：\n\n- `P(success) ≥ 0.9` 且 `P(false_completion) ≤ 0.02` 且 `median(iterations_to_green) ≤ 2`\n\n在满足目标函数的前提下，取**最大**的预算阈值作为该模型/环境的 `BaseBudget`。\n\n#### 12.5.3 求解：从“固定阈值”到“可回归标定”\n\n执行步骤（必须可自动化、可周期性回归）：\n\n1) **为当前模型建立 model_profile**（名称/上下文窗口/工具能力开关/版本号）。\n2) 运行校准套件（S/M/L 逐级放大），得到每档的成功率与失败形态。\n3) 用“单调递增预算”寻找临界点：\n   - 若 L 档失败率超标而 M 档达标 → `BaseBudget = M`（并留 10–20% 安全裕度）。\n4) 将结果写入真理层（可版本控制）：\n   - `specs/_meta/forge/budgets/<model-id>.yaml`（或 `.md`）\n5) Change Size Gate 从该预算表读取阈值并执行硬阻断。\n\n#### 12.5.4 模型升级时如何处理（你关心的动态性）\n\n- 模型升级/更换工具链/仓库熵显著变化 → **必须重新跑校准套件**。\n- 若预算表缺失或过期：\n  - 默认使用**保守预算**（更小阈值）并硬阻断超限变更；\n  - 或要求显式“人工授权”记录到变更包（属于系统宪法级例外）。\n\n> 结论：change 上限不是一次性规定，而是通过校准套件持续回归得到的“工程学参数”，并且在硬闸门体系下必须版本化与可审计。\n---\n\n## 13. Design System Compliance Gate（硬闸门）——把“审美偏好”变成可验收合同\n\n### 13.1 为什么完整设计系统必须进入闸门\n\n- “现代化 SaaS”这类描述对 AI 不具备可操作定义。\n- 设计系统如果只是文档而非闸门，最终会退化为“AI 自由发挥”。\n\n### 13.2 闸门合同\n\n当变更涉及 UI/交互/视觉时，必须满足：\n\n1) 设计系统引用：在 `design.md` 或 `verification.md` 中引用 `specs/_meta/design-system/*`\n2) token 使用：实现必须使用 tokens（而非随意 hardcode）\n3) 组件一致：新增组件必须按规范写入 components.md（或在 change 中提出并归档到真理）\n4) a11y 验收：至少覆盖键盘导航与对比度（可自动/手工证据）\n5) 证据归档：在 `<change>/evidence/` 提交截图/录像/可复现步骤或自动化结果\n\n失败 → 禁止归档。\n\n---\n\n## 14. Epic Alignment Gate（硬闸门）——保证 Knife 的 MECE 正确性在执行期不被破坏\n\n当 change 隶属于某个 Epic 时：\n\n- 必须声明 epic-id 与 slice-id\n- 必须声明本 change 的 AC 子集（从 Knife Plan 引用）\n- DevBooks 在 proposal/apply/archive 时必须验证：\n  - AC 不重叠\n  - AC 不缺失\n  - 依赖顺序与 Knife 拓扑一致（若偏离，必须记录决策并更新 Knife Plan）\n\n失败 → 禁止进入 Apply 或禁止归档。\n\n---\n\n## 14.5 Validation Gate（硬闸门）——统一原型验证与难题攻关验证\n\n### 14.5.1 一句话定位\n\n- 原型验证：用最低成本把“不确定”变成“已知”，快速决定做/不做/怎么做。\n- 难题攻关验证：处理高风险技术难点，用可复现证据钉死可行性/正确性/性能。\n- 统一视角：两者都是验证（Validation）；差别只在风险等级与证据严苛度。\n\n### 14.5.2 统一结构：验证问题（VQ）驱动\n\n所有验证都必须落到“验证包（Validation Packet）”，最小字段：\n\n- VQ（Validation Question）：必须回答的问题\n- Hypothesis：可被推翻的假设\n- Metric/Threshold：通过门槛（允许暂不可量化，但需理由）\n- Method：验证方法（原型/实验/压测/仿真/对照）\n- Evidence：证据位置（脚本/日志/截图/数据）\n- Decision：Proceed / Pivot / Stop / Need-more-info\n\n### 14.5.3 何时必须升级为“难题攻关”\n\n命中任一高风险旗标时，必须升级为难题攻关验证：\n\n- 正确性（算法/一致性/幂等/事务边界/安全权限）\n- 性能（延迟/吞吐/成本/尾延迟）\n- 可靠性（降级/超时/重试/错误语义/可观测闭环）\n- 不可逆（数据迁移/对外契约/合规红线）\n\n### 14.5.4 闸门通过条件（最小）\n\n- 每个 VQ 都有明确 Pass/Fail 条件\n- 证据可定位、可复现（环境/步骤/输入/输出）\n- 结论必须回写为可执行合同（AC/约束/测试锚点/预算）\n- 若结论为 Proceed：进入 Knife/DevBooks；否则必须回退或终止\n\n---\n\n## 14.6 Prototype Gate（硬闸门）——禁止“原型直上生产”\n\n### 14.6.1 G-PROT-001 原型可复现闸门\n\n- 必须产物：`prototype/README.md`（一键运行/输入输出/依赖/环境）+ `prototype/limitations.md`\n- 通过条件：他人在干净环境可复现同结论\n\n### 14.6.2 G-PROT-002 原型转正闸门\n\n- 必须产物：`prototype/decision.md`（结论/适用范围/拒绝方案/转正计划）\n- 通过条件：原型结论转写为 `design.md` 的 AC/约束，并体现在 `tasks.md`\n- 明确：禁止直接复制原型代码进生产\n\n---\n\n## 14.7 Compliance/Policy Gate（硬闸门）——外部约束的硬阻断\n\n- G0-COMP-001（Genesis）：合规研究最小闭环必须完成（见 8.3）\n- G2-COMP-001（Change）：`design.md` 或 `proposal.md` 必须有 `## Compliance Impact`\n- G3-COMP-001（Archive）：合规证据必须归档；风险接受必须可追溯\n\n---\n\n## 14.8 Extension Pack Integrity Gate（硬闸门）——协议映射必须可执行\n\n- 必须存在 `specs/_meta/packs/<pack-id>/pack.yaml`\n- 每条协议要求必须映射到：检查项 / 证据类型 / 闸门附加规则\n- 扩展包缺失或不完整：禁止启用\n\n## 15. 失败反馈与“修宪”机制（让系统一年后仍保持自洽）\n\n### 15.1 失败分型（必须落盘）\n\n- 切片错误（Knife）：依赖顺序错误/中间态不可 Green/预算超限\n- 信息不足（Genesis）：术语漂移/场景缺失/设计系统不完备/质量阈值不明确\n- 执行偏差（DevBooks）：角色污染/伪完成/证据缺失\n- 研究失败（Validation）：结论不可复现/阈值不明确/证据不足\n- 合规失败（Compliance）：边界不清/红线缺失/证据不可审计\n\n### 15.2 回流规则\n\n- Knife 失败 → 更新 Knife Plan，并对已完成 slices 的影响做评估\n- Genesis 缺口 → 更新 genesis truth（并可触发 DoR gate 重新判定）\n- DevBooks 偏差 → 通过宪法与闸门阻断；必要时升级为“流程/宪法变更提案”\n- Validation 失败 → 回到验证包重做或降级目标（禁止带病进入 Apply）\n- Compliance 失败 → 回到 Genesis 补齐外部约束与证据计划\n\n### 15.3 宪法与设计系统的变更治理\n\n- 宪法/设计系统属于“最高真理”层，任何变更必须走 DevBooks change：proposal→challenge→judge→design→...→archive。\n- 变更必须提供回滚策略与兼容窗口（尤其是设计 token 变更会影响全站 UI）。\n\n---\n\n## 16. 与现有 DevBooks Skills 的映射（建议）\n\n- Genesis（新增/独立）：devbooks-genesis（或作为现有 router 的上游模式）\n- Knife（新增/独立）：devbooks-knife（负责输出 epic plan + 切片 manifest）\n- DevBooks（既有）：proposal/design/spec/plan/test-owner/coder/reviewer/archiver + delivery-workflow\n- Validation/Research（新增/独立）：devbooks-validation（生成 validation packet + evidence）\n- Compliance/Policy（新增/独立）：devbooks-compliance（外部约束落盘 + 证据计划）\n- Extension Pack（新增/独立）：devbooks-pack (协议映射/模板/闸门附加)\n\n> 注意：本机 `dev-playbooks-cn` 当前已具备完整执行闭环 skills；Genesis/Knife 属于本系统新增的上游能力（增量设计）。\n\n---\n\n## 17. 安全与对抗（Defense-in-depth）\n\n- 不允许 LLM 自证正确：必须以证据与闸门定义完成。\n- 防 prompt injection：对外输入必须进入“隔离区”，并通过显式审计与安全清单。\n- 防供应链风险：依赖/锁文件/CI 变更必须走隐式变更探测与专门审查。\n\n（更完整的缺陷-灾难-机制映射见 `SFF-四议题回答`。）\n\n---\n\n## 18. 本文与引用的关系（避免冲突）\n\n- `SFF-四议题回答` 是更细的“分析与算法正文”，本文是“系统设计总说明与合同化闸门”。\n- 当本文与引用冲突：以“硬闸门合同”优先（因为这是系统控制面）。\n\n---\n\n## 19. 下一步（如果要进入“实现”）\n\n你已做出 3 个关键决策（完整设计系统/硬闸门/风险迁移）。若要落地到 DevBooks：\n\n1) 以一个 DevBooks change 形式，为 DevBooks 增量增加 3 个硬闸门（Size/Epic/DesignSystem）。\n2) 新增 Genesis 与 Knife 的目录/文件合同（truth_root/specs/_meta）。\n3) 为 Knife 输出的 manifest 增加可机读校验脚本（在 change-check 或独立 gate 中执行）。\n\n（若你说“生成设计”，我会按 DevBooks `design.md` 规范输出 What/Constraints + AC-xxx，并把各闸门变成可验收的 AC。）\n\n---\n\n## 20. 完整设计系统：文件 Schema 与可验证性（因你选择“完整设计系统”而强制）\n\n> 目的：把“审美/体验偏好”从隐性知识变成可引用、可验证、可演进的系统真理。\n> 这是 Genesis DoR 的硬门槛之一，也是 Design System Compliance Gate 的依据。\n\n### 20.1 `specs/_meta/design-system/tokens.json`（Design Tokens）\n\n**定位**：机器可消费的单一真理源（Single Source of Truth），用于驱动 UI 代码、样式系统、组件库。\n\n**推荐格式**：采用 Design Tokens 的通用结构（保持与 W3C Design Tokens 的思路一致：`$type`/`$value`），但不依赖任何特定工具链。\n\n**必须覆盖的 token 维度（最小闭环）**：\n\n- `color`：\n  - `brand`（primary/secondary）、`semantic`（success/warning/danger/info）、`surface`（bg/fg/border）、`text`（primary/secondary/muted）\n  - `states`（hover/active/disabled/focus）\n- `typography`：fontFamily/fontSize/fontWeight/lineHeight/letterSpacing\n- `spacing`：间距尺度（4/8/12/16/... 或自定义）\n- `radius`：圆角尺度\n- `shadow`：阴影尺度\n- `motion`：duration/easing\n- `zIndex`：层级语义（modal/popover/toast）\n\n**示例（仅示意结构，不绑定实现）**：\n\n```json\n{\n  \"$schema_version\": \"1.0\",\n  \"color\": {\n    \"semantic\": {\n      \"success\": {\"$type\": \"color\", \"$value\": \"#16a34a\"},\n      \"danger\": {\"$type\": \"color\", \"$value\": \"#dc2626\"}\n    }\n  },\n  \"spacing\": {\n    \"xs\": {\"$type\": \"dimension\", \"$value\": \"4px\"},\n    \"sm\": {\"$type\": \"dimension\", \"$value\": \"8px\"}\n  }\n}\n```\n\n**硬约束（用于闸门）**：\n\n- token 命名必须以“语义”优先（禁止以 `blue500` 作为唯一语义；允许底层 palette，但必须提供 semantic layer）。\n- 任何新增视觉常量必须先进入 tokens（或在变更包里提案并归档到 tokens），禁止“到处 hardcode”。\n- 必须提供 token 变更的兼容策略（尤其是对外 UI 的 breaking change）。\n\n**可验证性（建议实现为静态检查）**：\n\n- 扫描不允许的 hardcode：例如直接出现 `#RRGGBB`、非 tokens 的 spacing 数值、任意 fontSize。\n- 校验 tokens.json 完整性：必需字段存在、无重复语义、无未引用的死 token（可选）。\n\n### 20.2 `specs/_meta/design-system/foundations.md`（基础规范）\n\n**定位**：把“现代化/美观”的主观词汇转成可执行规范。\n\n**最小 Schema（建议标题稳定以便脚本/LLM 检索）**：\n\n- `## Visual Principles`（视觉原则）\n- `## Typography Scale`（排版尺度与层级）\n- `## Spacing & Layout`（间距/栅格/断点）\n- `## Color Semantics`（颜色语义与使用场景）\n- `## Motion`（动效原则与禁区）\n- `## Dark Mode Strategy`（如适用）\n\n### 20.3 `specs/_meta/design-system/components.md`（组件规范）\n\n**定位**：组件库的“合同”。\n\n**每个组件的最小 Schema（建议统一模板）**：\n\n- `### Component: <Name>`\n  - Purpose（用途）\n  - Anatomy（结构分解：slots/parts）\n  - Variants（变体：size/intent/style）\n  - States（状态：hover/active/disabled/loading/error/empty）\n  - Props/API（如果是代码组件）\n  - Interaction（交互规则：点击/键盘/焦点/快捷键）\n  - Accessibility（aria、对比度、焦点）\n  - Token Mapping（使用哪些 token）\n  - Do/Don't（允许/禁止用法）\n  - Acceptance（可验收点：截图/自动化 a11y/交互行为）\n\n### 20.4 `specs/_meta/design-system/patterns.md`（交互模式库）\n\n**定位**：将“用户旅程”固化为可复用模式，避免 AI 每次自创交互。\n\n**每个 Pattern 的最小 Schema**：\n\n- Pattern ID\n- Problem（解决什么）\n- Context（适用场景/不适用场景）\n- Flow（步骤：主流程 + 异常/补偿）\n- Components Used（组件组合）\n- Copy Rules（文案规则）\n- Error Semantics（错误语义与提示）\n- Accessibility（键盘路径/焦点/读屏）\n- Evidence（验收证据：截图/录像/自动化）\n\n### 20.5 `specs/_meta/design-system/content.md`（文案与术语一致性）\n\n- 与 `glossary.md` 的术语一致性规则（同义词/禁用词）\n- 错误信息格式（结构化错误 vs 文案）\n- 空状态与引导文案策略\n\n### 20.6 `specs/_meta/design-system/accessibility.md`（可访问性）\n\n**最小要求**：\n\n- 目标标准（如 WCAG 2.1 AA）\n- 自动化可检查项（颜色对比、aria 基本规则）\n- 人工验收清单（键盘可达、焦点可见、表单错误朗读）\n- 例外策略（何时允许不满足、如何记录与补救）\n\n### 20.7 变更包中的“设计系统影响声明”（强制）\n\n当变更涉及 UI/交互/视觉时，变更包的 `design.md` 必须新增稳定标题：\n\n- `## Design System Impact`\n\n并包含：\n\n- Affected tokens/components/patterns（受影响项）\n- Compatibility window（兼容窗口）\n- Required evidence（必须提交的证据：截图/录像/自动化报告）\n- Risk & rollback（风险与回滚）\n\n---\n\n## 21. DevBooks 闸门对齐清单（现有能力 + 本系统新增硬闸门）\n\n> 目的：把“工程哲学”落到可执行闸门，拦截伪完成与不可收敛变更。\n\n### 21.1 DevBooks 现有关键闸门（基于 `dev-playbooks-cn` 实码）\n\n以下闸门来自 `change-check.sh` 及其关联脚本（路径：`/Users/ozbombor/projects/dev-playbooks-cn/skills/devbooks-delivery-workflow/scripts/`）：\n\n- Proposal 合规：必须包含稳定标题、Decision Status（apply/archive/strict 必须 Approved）\n- Design 合规：必须有 `## Acceptance Criteria` 且包含 `AC-xxx`，严格模式要求 Problem Context / Rationale / Trade-offs\n- Tasks 合规：必须有 Main Plan Area / Breakpoint Area、必须有 checkbox；archive/strict 不允许未审批的未完成任务\n- Verification 合规：必须有 A/B/C/D 区块、追溯矩阵必须有 AC 行；archive/strict 需要 Status=Done/Archived\n- 证据闭环：archive/strict 必须存在 `evidence/green-final/` 且非空（Green evidence）\n- 失败拦截：archive/strict 扫描 Green evidence 中的失败模式\n- P0 跳过审批：strict 模式下未完成的 P0 必须 SKIP-APPROVED\n- 角色边界：按 role 检查禁止修改范围（Coder 禁止 tests/ 与 verification.md 等）\n- 隐式变更提示：缺少 implicit-changes.json 时给出提示；存在高风险隐式变更时发出 warn/err（strict 更严格）\n- 宪法检查：strict 模式验证 constitution（如适用）\n- Fitness/架构适应度检查：apply/archive/strict 触发（strict 更严格）\n\n> 注：更细的规则与错误信息以脚本为准（本文不复制脚本实现）。\n\n### 21.2 本系统新增硬闸门（必须阻断）\n\n- G-SIZE-001 Change Size Gate（进入 Apply 前阻断超限；Archive 前二次阻断）\n- G-EPIC-001 Epic Alignment Gate（AC 子集与 Knife Plan 一致；禁止重叠/遗漏；依赖拓扑一致）\n- G-DS-001 Design System Compliance Gate（UI 变更必须遵循 design-system，并提交证据）\n- G-HP-001 Hard Problem Declaration Gate（高不确定性问题必须有验证包）\n- G-RES-001 Research Sufficiency Gate（研究结论必须映射为约束/锚点）\n- G-PROT-001/002 Prototype Gates（可复现 + 转正合同）\n- G-COMP-001 Compliance/Policy Gate（合规研究就绪 + 影响声明 + 证据归档）\n- G-PACK-001 Extension Pack Integrity Gate（协议映射可执行）\n\n### 21.3 闸门结果的统一输出合同（建议）\n\n为支持自动化与工具链集成，所有闸门输出建议同时提供：\n\n- 人类可读（text/markdown）\n- 机器可读（json）\n\n最小字段：\n\n- gate_id\n- severity（block/warn）\n- message\n- evidence_paths（如果有）\n- next_action（回退路径：Genesis/Knife/DevBooks 哪个阶段）\n\n---\n\n## 22. Knife Plan：最小机读合同（用于硬闸门校验）\n\n> 说明：Knife 的详细算法与示例见 `SFF-四议题回答`；本节定义 Knife 输出给 DevBooks 的“接口合同”。\n\n### 22.1 Knife Plan（建议文件）\n\n- `specs/_meta/epics/<epic-id>/knife-plan.md`（人类可读）\n- `specs/_meta/epics/<epic-id>/knife-plan.json`（可选，机器可读）\n\n### 22.2 最小字段（必须）\n\n- Epic metadata：\n  - epic_id\n  - goal\n  - non_goals\n  - risk_migration_strategy（必须声明：Risk Migration）\n\n- Epic AC 列表：\n  - epic_ac_ids（全量列表）\n\n- Slices：每个 slice 必须包含：\n  - slice_id\n  - change_id（必须满足 DevBooks change-id 规则）\n  - epic_ac_subset（该 slice 覆盖的 epic AC 子集）\n  - migration_pattern（Expand-Contract / Strangler / Branch-by-Abstraction / Feature Flag 等）\n  - artifacts：\n    - produces[] / consumes[] / modifies[]（用于依赖推导与冲突检测）\n  - gates：\n    - verification_anchors[]（tests/commands/evidence）\n    - rollback_strategy\n  - budget：\n    - score\n    - thresholds\n    - overload_action（递归切分维度）\n  - risk_flags：\n    - compliance[] / safety[] / security[] / data[] / ai-ethics[]（可为空但必须显式）\n    - hard_problem: true/false\n  - validation:\n    - vq_count\n    - validation_pack_ref（如适用）\n\n### 22.3 Knife Correctness Gate 的检查项（必须可实现）\n\n- MECE：AC 全覆盖且互斥\n- Topology：依赖图无环（若有环必须拆分/引入抽象层）\n- Verifiability：每 slice 至少 1 个确定性锚点\n- Budget：超限即阻断并要求递归切分\n\n---\n\n## 23. 与 DevBooks 的执行接口（落盘 + 命令级闭环）\n\n> 本节描述“蓝图/切片/执行”如何在项目中形成可运行闭环。\n\n### 23.1 关键落盘原则\n\n- 所有关键真理写入 `<truth-root>`（可版本控制），不能只存在聊天记录。\n- 每次变更全部产物写入 `<change-root>/<change-id>`，不能散落。\n- 归档后：变更包转入 archive 区（或标记 Archived），真理层更新为唯一权威。\n\n### 23.2 典型闭环（Epic）\n\n1) Genesis：补齐 DoR（含完整设计系统）\n2) Knife：生成 `knife-plan` 与 slices\n3) 对每个 slice：\n   - 创建 change package（使用 DevBooks scaffold）\n   - proposal/design/tasks/spec/verification\n   - 如存在不确定性/高风险：先生成 validation 包（VQ/阈值/证据计划）再进入 Apply\n   - 如命中合规风险：补充 compliance 影响声明与证据计划\n   - Test Owner → Red baseline（证据落盘）\n   - Coder → 实现到 Green（证据落盘）\n   - Reviewer → 评审与状态设置\n   - Archive → 真理回写\n\n### 23.3 证据落盘规范\n\n- 所有可复现命令输出必须落到 `<change>/evidence/`（尤其是 Green final）。\n- UI 证据：截图/录像/可重放步骤同样落盘，并在 verification 的追溯矩阵中引用。\n\n### 23.4 三层同步（Draft → Staged → Truth）\n\n- 变更包中的 specs delta 先 stage，再 promote 到 truth。\n- 禁止直接改 `<truth-root>/specs/`（避免绕过审计与闸门）。\n\n### 23.5 适配 UCA 等特定项目的方式（保持框架通用性）\n\n框架不直接嫁接任何特定项目流程。要适配特定项目，只允许通过“扩展包 + Doctrine/Protocol 映射”完成：\n\n- 把“理念/规约/机制”抽象成 Doctrine/Constraints/Patterns\n- 把“协议/流程模板/策略库”抽象成 Protocols/Recipes\n- 把专有名词映射到 glossary，而不是进入主干流程\n\n这样既保持框架简洁性，又允许实例化为任何规模项目（含 UCA）。\n\n---\n\n## 24. 运行时增强（可选）：MCP/CKB 与熵度量的系统级定位\n\n- MCP/CKB：用于增强影响分析、调用图、热点识别（可用则启用，不可用则降级）。\n- 熵度量：不是每次变更的硬闸门（除非你选择将其硬化），但它是：\n  - Knife 预算权重（hotspot_weight）的重要输入\n  - 触发“风险迁移型重构 Epic”的客观信号\n\n---\n\n## 25. 规范性引用（汇总）\n\n- `SFF-四议题回答`：`/Users/ozbombor/projects/SFF-四议题回答.md`\n- 完备性/OmniMind 元提示词：`/Users/ozbombor/Downloads/NotesRepository/提示词工程/AI能力提示词/如何构建完备的系统.md`\n- DevBooks 参考实现：`/Users/ozbombor/projects/dev-playbooks-cn/`\n"}}}}}}
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:347:[2026-01-18T02:27:20] exec sh -lc "sed -n '60,200p' .codex/skills/devbooks-delivery-workflow/scripts/change-check.sh" in /Users/ozbombor/Projects/code-intelligence-mcp
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:348:[2026-01-18T02:27:20] sh -lc "sed -n '60,200p' .codex/skills/devbooks-delivery-workflow/scripts/change-check.sh" succeeded in 33ms:
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:404:[2026-01-18T02:27:40] exec sh -lc "rg -n \"check_proposal\\(\" -n .codex/skills/devbooks-delivery-workflow/scripts/change-check.sh
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:405:rg -n \"proposal\" .codex/skills/devbooks-delivery-workflow/scripts/change-check.sh | head -n 80" in /Users/ozbombor/Projects/code-intelligence-mcp
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:406:[2026-01-18T02:27:40] sh -lc "rg -n \"check_proposal\\(\" -n .codex/skills/devbooks-delivery-workflow/scripts/change-check.sh
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:407:rg -n \"proposal\" .codex/skills/devbooks-delivery-workflow/scripts/change-check.sh | head -n 80" succeeded in 36ms:
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:409:6:usage: change-check.sh <change-id> [--mode <proposal|apply|review|archive|strict>] [--role <test-owner|coder|reviewer>] [--project-root <dir>] [--change-root <dir>] [--truth-root <dir>]
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:429:[2026-01-18T02:27:43] exec sh -lc "sed -n '235,330p' .codex/skills/devbooks-delivery-workflow/scripts/change-check.sh" in /Users/ozbombor/Projects/code-intelligence-mcp
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:430:[2026-01-18T02:27:43] sh -lc "sed -n '235,330p' .codex/skills/devbooks-delivery-workflow/scripts/change-check.sh" succeeded in 28ms:
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:504:I noticed that our command output shows `- index.scip` followed by `…truncated…`, which seems inserted by the tool to indicate output truncation. After line 187, the output resumes, which isn't typical for `nl` and `sed`. It looks like the output includes `…truncated…` due to message limits. I also need to check for placeholders like `<file>`. The change-check script identifies patterns such as `<truth-root>` and `<change-root>`. In our proposal file, those placeholders are present, but they are replaced with actual values. However, since `<truth-root>` still appears, it may trigger strict mode checks.
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:624:I'm thinking about how they might include specific labels in proposals intentionally. I need to confirm whether the script checks them in strict mode, which would cause errors if placeholders are present. For apply or archive modes, it seems like they're okay unless strict is turned on. The user wants to ensure fields like Decision Status align with what’s needed, particularly for the change-check script. I should check the delivery workflow documentation for more details on this.
./.code/agents/38e22e7b-bfff-420b-bc07-2bc77329e97a/result.txt:627:I need to ensure we satisfy the minimal requirements for the check proposal, which includes the decision line, value signal bullet, and possibly others. I think I should open the README.md in the dev-playbooks for any required sections, but the skill prompt likely already lists them. There's another script, change-check.sh, that mandates headings and the decision line, so we could propose modifications for that. Since our environment is read-only, I'll provide a patch list with snippets instead of directly altering approved facts. However, I noticed an inconsistency in the status between the Why section and the skill prompt.
