现在我已经收集了足够的上下文信息。让我作为 Challenger 输出质疑报告。

---

# Challenger 质疑报告

## 1. 结论

**Revise** — 提案存在多处关键设计缺口与可行性风险,必须补齐后才能进入实施。

**理由**：提案虽已补齐大量细节(会话连续性、错误码、融合规则等),但仍存在**架构边界模糊、实现可行性未验证、范围膨胀风险**三大核心问题,直接影响交付质量与可维护性。

---

## 2. 阻断项 (Blocking)

### B1. 架构边界违反:编排内核与现有 hooks 职责重叠

**证据**:
- proposal.md:234-246 定义了三者调用链,但 `hooks/context-inject-global.sh` 已实现完整的意图检测(L426-500)、符号提取(L502-528)、搜索编排(L658-701)、Graph-RAG 调用(L877-908)
- 新增 `hooks/auto-tool-orchestrator.sh` 的职责(L194:工具路由/预算/并发/降级/结果标准化/融合解释)与现有 `context-inject-global.sh` 的 `build_structured_output`(L1137-1283)、`add_graph_context`(L1352-1396) 高度重叠

**风险**:
- 两套并行的编排逻辑会导致维护成本翻倍、行为不一致、测试覆盖困难
- 现有 `context-inject-global.sh` 已有 1546 行,再叠加编排内核会突破单文件可维护边界

**要求**:
- 明确 `auto-tool-orchestrator.sh` 与 `context-inject-global.sh` 的**互斥或复用关系**:是重构替换、还是并行共存?
- 若并行共存,必须给出**迁移路径**:现有逻辑如何逐步迁移到编排内核,避免"两套系统长期并存"
- 若重构替换,必须在 proposal 中明确**向后兼容策略**与**回滚路径**

---

### B2. Codex CLI 会话连续性依赖未验证的假设

**证据**:
- proposal.md:276-286 假设 `codex exec --json` 输出包含 `session_id`,但未提供**权威文档引用**或**实际输出样例**
- proposal.md:278-280 给出的 JSON 样例标注为"示例字段集;用于解析,不作为权威契约",无法作为实现依据

**风险**:
- 若 `codex exec --json` 不存在或输出格式不符,会话连续性功能完全失效
- 降级方案(L283-286)虽存在,但"无会话模式"会导致用户体验显著下降,与提案目标(L14:自动调用不再是固定 1-2 个工具)冲突

**要求**:
- 补充 `codex exec --help` 与 `codex exec --json` 的**实际输出截图**或**官方文档链接**
- 若无法验证,必须将"Codex CLI 会话连续性"标记为**可选项**,并在 MVP 中默认关闭
- 明确"无会话模式"下的**最小可用功能边界**:是否仍能满足 AC-002(L594)的验收标准?

---

### B3. 参数裁剪强制执行位置不明确

**证据**:
- proposal.md:346-372 定义了参数裁剪规则表,但未明确**执行位置**在编排内核的哪个函数/阶段
- proposal.md:351 声明"在任何工具调用前完成裁剪/拒绝",但调用链(L234-246)显示入口层(`context-inject-global.sh`)也可能直接调用工具(如现有 L877-908 的 `call_graph_rag`)

**风险**:
- 入口层绕过编排内核直接调用工具时,参数裁剪失效,导致安全边界被突破
- 多个执行点会导致裁剪逻辑重复实现,增加不一致风险

**要求**:
- 在 design.md 中明确**唯一裁剪执行点**:是编排内核的 `plan_tools` 阶段、还是入口层的统一拦截器?
- 补充**绕过检测机制**:如何保证所有工具调用(包括降级路径)都经过裁剪?
- 在 AC-006(L598)中补充**绕过测试用例**:构造入口层直接调用工具的场景,验证裁剪仍生效

---

### B4. MVP 范围仍不够收敛:Tier-2 触发条件模糊

**证据**:
- proposal.md:226-232 声明"Tier-2 默认关闭,仅显式确认启用",但未定义**显式确认的触发方式**
- proposal.md:316 的 `CI_AUTO_TOOLS_TIER_MAX=2` 是环境变量,但未说明**用户如何知道何时需要启用 Tier-2**
- proposal.md:228 声明"MVP 不实现意图自动触发",但 L342-344 的 Tier-2 工具列表(ci_call_chain/ci_bug_locate/ci_impact)与意图检测(L1094-1120)高度耦合

**风险**:
- 用户不知道何时启用 Tier-2,导致功能"存在但不可用"
- 若后续补充"意图自动触发",会导致 MVP 范围膨胀,影响交付时间

**要求**:
- 明确 MVP 的 Tier-2 触发方式:**仅手动环境变量**,还是**提供 CLI 参数**(如 `--tier-max=2`)?
- 在 docs/auto-tools.md 中补充**用户决策树**:何时需要启用 Tier-2?有哪些典型场景?
- 在 AC-009(L601)中补充**用户引导验证**:默认配置下触发 Tier-2 工具时,输出明确提示"需启用 Tier-2"

---

## 3. 遗漏项 (Missing)

### M1. 现有 `context-inject-global.sh` 的迁移计划缺失

**证据**:
- 现有 `context-inject-global.sh` 已有完整的意图检测、Graph-RAG 集成、降级策略(L393-420)
- proposal 未说明这些逻辑如何迁移到 `auto-tool-orchestrator.sh`,或是否保留两套系统

**影响**:
- 若不迁移,两套系统长期并存,维护成本翻倍
- 若迁移,现有用户(已安装 hook)的升级路径不明确

**建议**:
- 在 proposal 中补充**迁移策略**:分阶段迁移(先并行、后替换)、还是一次性重构?
- 在 tasks.md 中明确**迁移任务项**:哪些函数需要重构、哪些可以复用?

---

### M2. 结果融合的冲突解决策略不可执行

**证据**:
- proposal.md:561-563 定义了冲突结论呈现规则,但未给出**冲突判定标准**
- 示例:两个工具返回"函数 A 调用 B"与"函数 A 不调用 B",如何判定为冲突?

**影响**:
- 实现时无法判断何时标记 `conflict=true`,导致冲突检测失效或误报

**建议**:
- 在 design.md 中补充**冲突判定规则**:基于语义相似度、还是结构化字段比对?
- 在 AC-011(L603)中补充**冲突样例**:构造两个工具返回互斥结论的场景,验证冲突标记生效

---

### M3. 安装脚本未覆盖 Codex wrapper 的安装路径

**证据**:
- proposal.md:581-587 定义了 Codex wrapper 的安装位置(`/usr/local/bin/codex-auto` 或 `<repo-root>/bin/codex-auto`)
- 现有 `install.sh` 仅安装 `code-intelligence-mcp` 与 `ci-search`(L193-194),未包含 `codex-auto`

**影响**:
- 用户无法通过 `./install.sh` 安装 Codex wrapper,需要手动复制,降低可用性

**建议**:
- 在 tasks.md 中补充**安装脚本修改任务**:增加 `--with-codex-wrapper` 参数
- 在 AC-015(L607)中补充**安装验证**:执行 `./install.sh --with-codex-wrapper` 后,`codex-auto` 可用

---

### M4. 降级路径的可观测性不足

**证据**:
- proposal.md:489 要求"任何失败都不得阻塞模型输出,但必须把降级原因写入 [Limits]"
- 但未定义**降级日志的持久化位置**:仅在终端输出,还是写入文件?

**影响**:
- 用户无法回溯历史降级事件,难以诊断"为什么某次查询没有调用 Tier-2 工具"

**建议**:
- 在 design.md 中补充**降级日志策略**:写入 `<repo-root>/.devbooks/logs/auto-tools-degraded.log`
- 在 AC-008(L600)中补充**日志验证**:模拟降级场景,验证日志文件包含降级原因与时间戳

---

### M5. 性能基线与预算调优依据缺失

**证据**:
- proposal.md:393-405 给出了具体预算数字(总墙钟 5000ms、并发 3),但未说明**取值依据**
- L391 声明"对齐现有 `hooks/context-inject-global.sh` 的默认超时",但现有脚本的 `SEARCH_TIMEOUT=2`(L39)与 `ci_search` 的 2000ms(L397)对齐,其他工具的超时未在现有脚本中定义

**影响**:
- 预算值可能过于保守(导致工具调用不足)或过于激进(导致超时频繁)
- 无法在实施后验证预算是否合理

**建议**:
- 在 verification.md 中补充**性能基线测试**:在典型项目(如本项目)上测量各工具的实际耗时
- 在 docs/auto-tools.md 中补充**预算调优指南**:如何根据项目规模调整预算?

---

## 4. 非阻断项 (Non-blocking)

### N1. I/O schema 版本策略过于复杂

**证据**:
- proposal.md:472-476 要求 `schema_version` 采用 SemVer,并强制向前兼容
- 但编排内核是内部组件,不对外暴露 API,版本管理成本高于收益

**建议**:
- 简化为**单一版本号**(如 `v1`),仅在破坏性变更时 bump
- 在入口层提供**文本兜底**已足够应对 schema 变更

---

### N2. 结果融合的稳定排序规则过于严格

**证据**:
- proposal.md:557-564 要求"同一输入、同一工具输出顺序必须稳定;禁止基于运行时 hash/随机数排序"
- 但工具调用是并发的(L394:并发上限 3),并发顺序本身不稳定

**建议**:
- 放宽为"相同去重键的条目顺序稳定",不要求全局顺序稳定
- 在 AC-011(L603)中明确**稳定性边界**:仅验证去重后的条目顺序,不验证原始工具返回顺序

---

### N3. 安全边界的脱敏规则可能过于严格

**证据**:
- proposal.md:386-387 要求脱敏 `Bearer <redacted>`、`AKIA<redacted>` 等模式
- 但某些场景下(如调试 OAuth 流程),用户可能需要看到完整 token

**建议**:
- 提供**脱敏开关**(如 `CI_AUTO_TOOLS_REDACT=off`),默认开启,允许用户临时关闭
- 在 docs/auto-tools.md 中补充**安全警告**:关闭脱敏的风险

---

## 5. 替代方案

### 方案 A:收敛为"单工具自动化"MVP

**思路**:
- MVP 仅自动调用 `ci_index_status`(Tier-0),其他工具通过 `recommended_tools` 提示用户手动调用
- 避免编排复杂度,快速验证"自动调用 + 结果回填"的基础链路

**优势**:
- 范围最小,风险最低,可在 1-2 周内交付
- 为后续多工具编排积累经验

**劣势**:
- 与提案目标(L14:自动调用不再是固定 1-2 个工具)不符

---

### 方案 B:重构现有 `context-inject-global.sh` 而非新增编排内核

**思路**:
- 在现有 `context-inject-global.sh` 基础上重构,提取编排逻辑到独立函数(如 `orchestrate_tools`)
- 避免两套系统并存,降低维护成本

**优势**:
- 复用现有逻辑(意图检测、Graph-RAG、降级策略),减少重复开发
- 向后兼容性更好,现有用户无需迁移

**劣势**:
- 单文件会更长(可能超过 2000 行),需要更严格的模块化设计

---

## 6. 风险与证据缺口

### R1. Codex CLI 集成的可行性未验证

**缺口**:
- 未提供 `codex exec --json` 的实际输出或官方文档
- 未验证 wrapper 能否拦截 Codex TUI 内的每轮输入

**建议**:
- 在 proposal 批准前,先做**技术预研**:编写最小 wrapper 原型,验证会话连续性可行
- 若不可行,将 Codex CLI 集成标记为**实验性功能**,不纳入 MVP

---

### R2. 多工具并发调用的稳定性未测试

**缺口**:
- proposal 假设并发调用 3 个工具不会导致资源竞争或死锁
- 未提供并发场景的压力测试计划

**建议**:
- 在 verification.md 中补充**并发压力测试**:同时触发 5 个工具调用,验证预算与超时机制生效
- 在 AC-007(L599)中补充**并发验证**:验证并发上限生效且不阻塞

---

### R3. 结果融合的正确性依赖人工判断

**缺口**:
- proposal.md:561-563 的冲突解决策略要求"人工判断",但未定义**自动化验证方式**
- 若融合逻辑有 bug,可能导致错误结论被回填到 prompt

**建议**:
- 在 verification.md 中补充**融合正确性测试**:构造已知正确答案的场景,验证融合结果与预期一致
- 在 AC-011(L603)中补充**融合错误检测**:验证冲突标记能捕获明显的互斥结论

---

**报告结束**
