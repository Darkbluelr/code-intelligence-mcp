# 自动工具编排层说明（Auto Tool Orchestration）

版本：2026-01-22

## 1. 目标

在 AI 输出前，自动完成“工具选择与调用，并将结果回填进上下文”，降低 AI 的认知负担并提升一次命中率。

---

## 2. 复杂度评估（工程维度）

### 低复杂度（1-2 天）
- 仅做“推荐工具 + 手动触发”
- 输出建议，不自动调用

### 中复杂度（3-7 天）
- 根据意图自动调用 1-2 个低成本工具
- 结果以结构化 JSON 回填
- 有超时、预算控制、白名单

### 高复杂度（2 周+）
- 多工具并行调用 + 结果融合（去噪、排序）
- 工具链路可解释性、错误恢复、质量评分
- 适配多个 IDE/CLI 客户端

结论：你需要的是“中复杂度”版本，收益最大、风险可控。

---

## 3. 如何做到 AI 输出前调用

核心方法：

1) **拦截用户输入**（客户端层）
- Cursor IDE: 通过其 MCP/插件体系（如可用）
- Claude Code: 已有 Hook 机制（UserPromptSubmit）
- Codex CLI: 可用 wrapper 或 hook

2) **在 Hook 中进行：**
- 意图识别
- 选择工具
- 执行工具
- 合并结果

3) **将结果注入 AI prompt**

如果 Hook 有执行点（Claude Code / Codex CLI），就能做到“AI 输出前自动调用”。

---

## 4. 通用性评估

### 通用方案（难）
- 需要对不同 IDE/客户端写插件或适配器

### 实用方案（建议）
- 先支持 1-2 个客户端：Claude Code + Codex CLI
- 其余客户端保留“手动触发”模式

---

## 5. 推荐方案

### Phase 1（快速落地）
- Claude Code Hook + Codex CLI wrapper
- 自动调用：`ci_search` + `ci_graph_rag`（只选 1-2 个）
- 输出：`tool_results` 字段（结构化 JSON）

### Phase 2（增强）
- 并行调用 + 预算控制
- 置信度阈值 + 失败回退

---

## 6. 风险点

- 延迟抖动：工具调用会增加等待
- 错误传播：错误结果会误导模型
- 不同客户端兼容性

---

## 7. 结论

- **帮助很大，但需要克制**：只自动调用低成本、低风险工具
- **先支持 1-2 个客户端**，再扩展

