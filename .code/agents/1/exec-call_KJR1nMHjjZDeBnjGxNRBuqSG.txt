# Claude Code / Codex CLI：自动工具编排 + 结果融合的上下文注入（单变更包交付）

> <truth-root> = `dev-playbooks/specs/`
> <change-root> = `dev-playbooks/changes/`
> Status: Revise（Judge 要求修改后再评审）

> 治理约束（强制）：本次变更**所有任务必须在一个变更包里完成**，禁止拆分为多个变更包；若 Proposal Challenger 要求拆分，Proposal Judge **必须驳回拆分请求**（允许在同一变更包内重排优先级/范围，但不得拆包）。

## 🎯 结论先行（30秒阅读）

**本提案会导致**：
- ✅ 在 Claude Code 与 Codex CLI 中，用户输入后可在模型输出前自动执行“合适的”MCP 工具，并把结果回填进 Prompt
- ✅ 自动调用不再是“固定 1-2 个工具”，而是按意图/置信度/预算选择多工具，并做结果融合与解释（面向用户可读）
- ✅ 中英文都可触发自动注入（语言无关），并保留“可见 + 可控”的用户体验
- ✅ 明确 `hooks/context-inject-global.sh` 与新增 `hooks/auto-tool-orchestrator.sh` 的分工：前者做客户端适配入口，后者做可复用的编排内核

**本提案不会导致**：
- ❌ 不做 Cursor/其他 IDE 的适配（明确排除）
- ❌ 不改变 Thin Shell 架构约束（TypeScript 仍是薄壳，核心能力仍在 Shell 脚本 / MCP 工具侧）

**一句话总结**：把“工具自动调用 + 结果融合 + 可扩展适配”做成可维护的编排层，让 Claude Code/Codex CLI 在回答前自动把该查的都查了。

---

## 🤔 需求对齐（5分钟阅读）

### 你是谁？（角色定位）

请选择最符合你的描述：

- [ ] **效率型使用者**：希望“问一次就给完整答案”，可接受少量延迟
- [ ] **质量型维护者**：更关心准确性与可控性（工具计划/证据/可回滚）
- [ ] **平台扩展者**：未来要扩展到更多 AI 客户端/更多工具，需要清晰扩展点

**如果你不确定**：默认选择“质量型维护者”。

---

### 你要什么？（核心需求）

**基础需求（必须）**：
- [x] 解释 `hooks/context-inject-global.sh` 与 `hooks/auto-tool-orchestrator.sh` 的关系：不是替代关系；两者同时存在且职责清晰
- [x] 本次 change 只适配 Claude Code 与 Codex CLI，但适配逻辑必须容易扩展
- [x] 自动工具调用要“尽可能调用所有合适的”，并由我（提案）给出最佳实践决策
- [x] 中英文均可触发自动注入
- [x] 本次需要实现“自动结果融合 + 解释”，并兼顾用户体验与效率

**排除项（明确不做）**：
- [x] Cursor/其他 IDE 适配

---

### 你可能没想到什么？（隐藏需求）

#### 隐藏需求 1：无上限“全工具自动调用”会拖垮体验

**问题**：如果每次提问都把所有工具都跑一遍，你更在意“最全”还是“可接受的延迟/噪音”？

**为什么重要**：
- 过多工具会带来：延迟陡增、噪音干扰、错误传播、token 暴涨
- 结果融合需要“去重/聚合/溯源”，否则反而降低回答质量

**默认选择（提案给出决策）**：
- 采用“尽可能多，但有预算与置信度边界”的自动化策略（见下文 What/设计要点）

---

### 🎯 基于你的选择，推荐方案

默认推荐：**质量型维护者**路径
- 自动调用：按意图与置信度选择“合适的多工具组合”，但受预算与超时约束
- 输出：用户可见的 Tool Plan + 可折叠 Results + 最终融合解释
- 扩展：编排内核与客户端适配解耦，后续可加 Cursor 适配但不阻塞本次交付

---

## ✅ 批准流程（1分钟）

### 快速批准（推荐）

如果你同意“多工具自动化（带预算边界）+ 结果融合解释 + 仅 Claude/Codex 适配”的推荐方案：
- [ ] ✅ 我同意推荐方案，直接开始

如果你想自定义（例如更激进/更保守的自动调用策略）：
- [ ] 🔧 我想自定义方案（在 Debate Packet 的问题上给出选择）

默认状态：未批准（必须显式勾选其一；不提供任何“自动批准”机制）

---

## 📋 详细提案（AI阅读）

### Why（为什么要改）

#### 问题描述

当前用户需求已经明确从“低成本/低风险工具自动调用”升级为：
- 在模型输出前自动调用“所有合适的工具”，并把结果融合解释后回填
- 同时要兼顾延迟与可读性（用户体验），并支持中英文触发
- 仅做 Claude Code + Codex CLI 适配，但必须为未来扩展预留清晰扩展点

如果没有一个明确的“工具编排层”，会出现：
- 逻辑散落在不同 Hook/Wrapper 中，难扩展、难测试、难统一体验
- 自动化策略不可控（要么太少、要么无上限），导致效果不稳定

#### 影响

- 对最终用户：一次提问可获得更有证据、上下文更完整的回答
- 对维护者：集中式编排内核降低耦合，未来增加工具/客户端成本更低

---

## Debate Packet（供 Challenger/Judge 对辩）

> 目标：把争议点与风险摆在桌面上，避免“隐性假设”。

### 必须写入的治理说明（强制）

- 本次变更**所有任务必须在一个变更包里完成**，禁止拆分为多个变更包。
- 如果 Proposal Challenger 提出“拆分变更包”的要求，Proposal Judge **必须驳回拆分请求**（可要求在同一变更包内重排优先级，但不得拆包）。

### 需要 Judge 明确的裁决点

1) 自动调用的预算默认值（例如：总超时、并发数、回填 token 上限）取“保守”还是“激进”？
2) Tier-2 工具（如 `ci_impact`、`ci_call_chain`）的默认触发条件：
   - 仅 modify/debug 触发（保守）
   - explore 也触发但降低 top-k（更激进）
3) 用户可控性：默认是否允许“完全关闭自动调用”，还是仅允许“降级为 Tier-1”？

### Open Questions

1) Codex CLI 的“预调用入口”以 wrapper/hook 为主：当前项目期望的集成方式是什么（安装脚本/文档如何引导）？
2) 输出格式：用户希望在终端中看到多详细的 Tool Results（摘要优先还是原始结果优先）？

---

### What（要改什么）

#### 目标

1) **“AI 输出前”自动工具调用**：在 Claude Code 与 Codex CLI 的调用链中保证工具先跑、结果后回填、最后再生成回答。

2) **多工具选择（尽可能调用合适的）**：
- 不是“固定 1-2 个”，而是基于意图/置信度/预算选择工具集合
- 同时避免无上限调用导致的延迟与噪音

3) **自动结果融合 + 解释（面向用户）**：
- 结构化回填（供模型稳定消费）
- 用户可读摘要（展示执行了哪些工具、为什么、得到什么结论/证据）

4) **中英文均可触发**：语言不应成为自动化的开关；意图识别需对中英文均有效。

5) **易扩展的适配层**：本次只实现 Claude Code/Codex CLI，但设计上要明确“新增客户端适配点”。

#### 范围

本次变更将交付（预期文件/模块，供后续 design/tasks 细化）：
- `hooks/auto-tool-orchestrator.sh`：编排内核（工具路由/预算/并发/降级/结果标准化/融合解释）
- `hooks/context-inject-global.sh`：作为客户端适配入口（Claude Code Hook / Codex CLI wrapper），调用编排内核
- `config/auto-tools.yaml`：白名单/阈值/预算/工具分层策略（默认值可用，支持覆盖）
- `docs/auto-tools.md`：用户说明（可见+可控、隐私/安全、常见问题）
- `tests/auto-tools.bats`：最小验证集（预算/降级/融合格式的契约测试）

本次明确不做：
- Cursor/其他 IDE 适配

---

#### 设计完善（对后续 Design Doc 的明确要求）

> 本小节用于满足“proposal.md 必须包含设计完善/设计要点内容”的要求（与下方“设计要点”互补）：列出必须在 `design.md` 中补齐并固化的关键设计点，避免实现阶段反推设计。

- **边界与契约**：客户端适配层（Claude Code Hook / Codex CLI wrapper）与编排内核（orchestrator）的输入/输出契约；错误码/退出码/输出 schema 的稳定性
- **自动调用策略**：白名单、置信度阈值、预算模型（总超时/并发/回填 token 上限）、超时/失败降级与重试规则
- **结果融合与解释**：结构化 JSON（供模型消费）与用户可读摘要（供终端展示）的格式；聚合/去重/溯源策略；top-k 限制与噪音抑制
- **中英文触发**：语言无关触发策略（中英关键词 + 结构信号），以及误触发/漏触发时的行为（例如自动降级、提示用户如何补充信息）
- **安全与隐私**：路径过滤/脱敏策略、默认采集边界、日志与可观测性（避免输出敏感内容到 prompt）
- **验收锚点**：如何在测试中验证“模型输出前已调用工具并回填”（含失败/超时降级的证据采集方式）

---

### 设计完善 / 设计要点（必须）

> 本节用于满足“proposal 需要完善里面的设计”的要求：只描述 What/Constraints/AC，不写实现步骤。

#### 设计要点 0：范围收敛（同包分阶段，不拆包）

本次变更强制保持“单变更包”，但允许**在同一变更包内分阶段交付**（同包分阶段，不拆包）：

- **MVP（必须交付）**：Tier-0/1 默认自动；Tier-2 仅条件触发或需用户确认；具备控制面/安全边界/预算/契约/验收锚点。
- **Tier-0/1**：自动（无需用户确认）。
- **Tier-2**：默认不“无条件自动”。触发必须满足：
  - 条件触发：意图=modify/debug 且明确给出文件/符号/报错；并且预算允许
  - 或用户确认触发：用户显式同意（例如在 prompt 中写“允许深度分析/impact/call chain”）
- **Tier-3**：高成本/高风险，默认永不自动（仅提示 + 手动触发）。

该约束用于保证“范围收敛”，避免本次交付演变成“把所有工具都塞进自动化”。

#### 设计要点 1：hooks 关系与调用链（回答用户 Q1；补齐调用链要求）

三者关系（都需要存在，且是**调用链**而非互斥）：

```
Claude Code (UserPromptSubmit)
  -> ~/.claude/hooks/context-inject-global.sh
       -> hooks/context-inject-global.sh (入口适配层)
            -> hooks/auto-tool-orchestrator.sh (编排内核)

兼容层：hooks/augment-context-global.sh
  -> exec hooks/context-inject-global.sh (仅为历史路径/测试保持兼容)
```

- `hooks/context-inject-global.sh`：入口与适配层
  - 负责输入适配：Claude Code Hook payload / Codex CLI wrapper 输入 / CLI 参数（如 `--prompt`）
  - 负责输出适配：
    - Claude Code：输出 `hookSpecificOutput.additionalContext`
    - Codex CLI：输出可拼接到 prompt 的“增强上下文块”（或 JSON 供 wrapper 二次格式化）
  - 负责**可控性与降级**：根据控制面决定是否调用编排内核；失败时 fail-open（不阻塞模型输出）

- `hooks/augment-context-global.sh`：仅做向后兼容
  - 现状已是“委托给 `context-inject-global.sh`”的 wrapper；本次保持该定位不膨胀

- `hooks/auto-tool-orchestrator.sh`：编排内核
  - 输入：标准化 prompt + signals + budget + allowlist + policy
  - 输出：Tool Plan + Tool Results + Fused Context（见下方 I/O 契约）

#### 设计要点 2：Codex CLI “模型输出前调用”的集成路径（补齐入口/触发/最小配置/差异）

Codex CLI 与 Claude Code 的关键差异：**Codex CLI 没有等价的官方 Hook 事件（如 UserPromptSubmit）**可直接复用，因此必须通过“入口包装”来保证“模型输出前调用”。

本提案采用“双入口策略”，都在“模型输出前”触发编排：

1) **入口 A（推荐，保证每轮预调用）：Codex CLI wrapper（外层交互循环）**
   - 入口形式：提供一个 wrapper 命令（例如 `codex-auto`），由它负责读取用户输入（每一轮）
   - 触发时机：每次用户提交一条 prompt -> 先调用 `hooks/auto-tool-orchestrator.sh` -> 再把增强后的 prompt 交给 `codex exec`（或 `codex exec resume`）
   - 最小配置：
     - 用户机器上已安装 `codex`
     - `~/.codex/config.toml` 已配置本项目的 MCP server（例如 `mcp_servers.code-intelligence`）
     - wrapper 能找到本仓库的 `hooks/context-inject-global.sh`（通常通过安装脚本复制到固定位置或加入 PATH）

