# 实现 ALG-002 贪婪选择策略
# 输入：候选 JSON 列表、预算
# 输出：裁剪后的候选列表
trim_by_budget() {
  local candidates_json="$1"
  local budget="$2"

  # MP4.5: 验证预算
  budget=$(validate_budget "$budget")

  # MP4.5: 零预算处理 - 返回空结果
  if [ "$budget" -eq 0 ]; then
    log_warn "Token 预算为 0，返回空结果" >&2
    echo '[]'
    return 0
  fi

  local total_tokens=0
  local result='[]'
  local skipped_oversized=0

  # 获取候选数量
  local count
  count=$(echo "$candidates_json" | jq 'length' 2>/dev/null || echo 0)

  # MP4.4: 贪婪选择 - 按优先级降序（假设已排序）
  for ((i=0; i<count; i++)); do
    local candidate
    candidate=$(echo "$candidates_json" | jq ".[$i]")

    local file_path
    file_path=$(echo "$candidate" | jq -r '.file_path')

    # 获取预计算的 token 数，或现场估算
    local content_tokens
    content_tokens=$(echo "$candidate" | jq -r '.tokens // 0')

    if [ "$content_tokens" -eq 0 ]; then
      # 没有预计算，现场估算
      content_tokens=$(estimate_file_tokens "$file_path")
    fi

    # MP4.5: 单片段超预算处理
    if [ "$content_tokens" -gt "$budget" ]; then
      ((skipped_oversized++)) || true
      log_warn "片段 $file_path ($content_tokens tokens) 超过预算 ($budget)，跳过" >&2
      continue
    fi

    # MP4.4: 贪婪选择 - 检查是否超预算
    if [ $((total_tokens + content_tokens)) -gt "$budget" ]; then
      # 超预算，停止选择（不分割单个代码片段）
      break
    fi

    # 选中该片段
    total_tokens=$((total_tokens + content_tokens))
    result=$(echo "$result" | jq --argjson c "$candidate" '. + [$c]')
  done

  # MP4.5: 所有片段都超预算的警告
  if [ "$(echo "$result" | jq 'length')" -eq 0 ] && [ "$skipped_oversized" -gt 0 ]; then
    log_warn "所有 $skipped_oversized 个候选片段都超过预算 ($budget tokens)" >&2
  fi

  echo "$result"
}

# ==================== 主逻辑 ====================

# 从候选列表构建子图结构（nodes + edges）
# AC-003: 输出包含边关系
build_subgraph() {
  local candidates_json="$1"
  local nodes='[]'
  local edges='[]'

  local count
  count=$(echo "$candidates_json" | jq 'length' 2>/dev/null || echo 0)

  for ((i=0; i<count; i++)); do
    local candidate
    candidate=$(echo "$candidates_json" | jq ".[$i]")

    local file_path symbol_id relevance_score depth
    file_path=$(echo "$candidate" | jq -r '.file_path')
    symbol_id=$(echo "$candidate" | jq -r '.symbol_id // empty')
    relevance_score=$(echo "$candidate" | jq -r '.relevance_score // 0')
    depth=$(echo "$candidate" | jq -r '.depth // 0')

    # 生成节点 ID（如果没有 symbol_id）
    local node_id
    if [ -n "$symbol_id" ] && [ "$symbol_id" != "null" ]; then
      node_id="$symbol_id"
    else
      node_id="${file_path}::main"
    fi

    # 添加节点
    nodes=$(echo "$nodes" | jq --arg id "$node_id" --arg file "$file_path" \
      --argjson score "$relevance_score" --argjson depth "$depth" \
      '. + [{id: $id, file_path: $file, relevance_score: $score, depth: $depth}]')

    # 从 callers/callees 构建边
    local callers callees
    callers=$(echo "$candidate" | jq '.callers // []')
    callees=$(echo "$candidate" | jq '.callees // []')

    # 处理 callers（--refs--> 边）
    local caller_count
    caller_count=$(echo "$callers" | jq 'length' 2>/dev/null || echo 0)
    for ((j=0; j<caller_count; j++)); do
      local caller
      caller=$(echo "$callers" | jq ".[$j]")
      local caller_id
      caller_id=$(echo "$caller" | jq -r '.symbol_id // .file_path // empty')
      if [ -n "$caller_id" ] && [ "$caller_id" != "null" ]; then
        edges=$(echo "$edges" | jq --arg from "$caller_id" --arg to "$node_id" \
          '. + [{from: $from, to: $to, type: "refs"}]')
      fi
    done

    # 处理 callees（--calls--> 边）
    local callee_count
    callee_count=$(echo "$callees" | jq 'length' 2>/dev/null || echo 0)
    for ((j=0; j<callee_count; j++)); do
      local callee
      callee=$(echo "$callees" | jq ".[$j]")
      local callee_id
      callee_id=$(echo "$callee" | jq -r '.symbol_id // .file_path // empty')
      if [ -n "$callee_id" ] && [ "$callee_id" != "null" ]; then
        edges=$(echo "$edges" | jq --arg from "$node_id" --arg to "$callee_id" \
          '. + [{from: $from, to: $to, type: "calls"}]')
      fi
    done
  done

  # 构建子图 JSON
  jq -n --argjson nodes "$nodes" --argjson edges "$edges" \
    '{nodes: $nodes, edges: $edges}'
}

build_context() {
  local query="$1"

  # 检测 CKB 可用性
  _detect_ckb

  # 重置边界过滤计数
  BOUNDARY_FILTERED_COUNT=0

  # 检查缓存
  local cache_key="graph-rag:$CWD:$query:$TOP_K:$MAX_DEPTH:$TOKEN_BUDGET:$CKB_AVAILABLE:$LEGACY_MODE:$RERANK_ENABLED"
  local cached
  cached=$(get_cached "$cache_key")
  if [ -n "$cached" ]; then
    echo "$cached"
    return 0
  fi

  # 确定数据源
  local data_source="keyword"
  local candidates='[]'

  if [ "$CKB_AVAILABLE" = true ]; then
    # 使用 CKB API 进行图遍历
    data_source="ckb"
    candidates=$(_ckb_search_and_traverse "$query" "$TOP_K" "$MAX_DEPTH")

    # MP3.3: 检查 CKB 调用结果
    # 只有在返回空数组或空字符串时才降级
    if [ "$candidates" = "[]" ] || [ -z "$candidates" ]; then
      # 动态降级：CKB 调用失败
      CKB_AVAILABLE=false
      _record_ckb_fallback  # T-CKB-004: 记录降级时间，启动冷却期

      # 降级到 Embedding + import 解析
      local anchors
      anchors=$(embedding_search "$query" "$TOP_K")

      if [ -z "$anchors" ] || [ "$anchors" = "[]" ]; then
        anchors=$(keyword_search "$query" "$TOP_K")
        data_source="keyword"
      else
        data_source="import"
      fi

      # 图遍历扩展（使用 import 解析）
      candidates=$(_expand_with_import_analysis "$anchors" "$MAX_DEPTH")

      # 如果返回了结果，更新 data_source
      if [ -n "$candidates" ] && [ "$candidates" != "[]" ]; then
        local first_source
        first_source=$(echo "$candidates" | jq -r '.[0].source // "import"')
        data_source="$first_source"
      fi
    fi
    # 如果 CKB 返回了非空数组，保持 CKB_AVAILABLE=true
  else
    # 降级到 Embedding + import 解析
    local anchors
    anchors=$(embedding_search "$query" "$TOP_K")

    if [ -z "$anchors" ] || [ "$anchors" = "[]" ]; then
      anchors=$(keyword_search "$query" "$TOP_K")
      data_source="keyword"
    else
      data_source="import"
    fi

    # 图遍历扩展（使用 import 解析），即使 anchors 为空也调用（支持 mock 模式）
    candidates=$(_expand_with_import_analysis "$anchors" "$MAX_DEPTH")

    # 如果返回了结果，更新 data_source
    if [ -n "$candidates" ] && [ "$candidates" != "[]" ]; then
      local first_source
      first_source=$(echo "$candidates" | jq -r '.[0].source // "import"')
      data_source="$first_source"
    fi
  fi

  if [ -z "$candidates" ] || [ "$candidates" = "[]" ]; then
    candidates='[]'
  fi

  # AC-004: 边界过滤（排除库代码）
  candidates=$(filter_library_code "$candidates")

  # MP4.1: 应用最低相关度阈值过滤
  if [ -n "$MIN_RELEVANCE" ] && [[ "$MIN_RELEVANCE" != "0" ]] && [[ "$MIN_RELEVANCE" != "0.0" ]]; then
    candidates=$(echo "$candidates" | jq --argjson threshold "$MIN_RELEVANCE" \
      '[.[] | select((.relevance_score // .relevance // 0) >= $threshold)]')
  fi

  # MP4.2: 计算优先级评分并添加 priority 字段
  candidates=$(add_priority_scores "$candidates")

  # MP4.4: 按优先级降序排序（而不是仅按 relevance_score）
  candidates=$(echo "$candidates" | jq 'sort_by(-.priority // -.relevance_score // 0)')

  # AC-004: LLM 重排序（如果启用）
  if [ "$RERANK_ENABLED" = true ]; then
    # 使用临时文件传递状态（避免子 shell 变量丢失）
    local rerank_state_file
    rerank_state_file=$(mktemp)
    candidates=$(llm_rerank_candidates "$query" "$candidates" "$rerank_state_file")
    if [[ -f "$rerank_state_file" ]]; then
      # shellcheck disable=SC1090
      source "$rerank_state_file"
      rm -f "$rerank_state_file"
    fi
  fi

  # Token 预算裁剪
  local trimmed
  trimmed=$(trim_by_budget "$candidates" "$TOKEN_BUDGET")

  # 计算实际 token 数（使用预计算的 tokens 字段，或现场估算）
  local total_tokens=0
  local candidate_count
  candidate_count=$(echo "$trimmed" | jq 'length')

  for ((i=0; i<candidate_count; i++)); do
    local precomputed_tokens
    precomputed_tokens=$(echo "$trimmed" | jq -r ".[$i].tokens // 0")

    if [ "$precomputed_tokens" -gt 0 ]; then
      total_tokens=$((total_tokens + precomputed_tokens))
    else
      # 降级：现场估算
      local file_path
      file_path=$(echo "$trimmed" | jq -r ".[$i].file_path")
      local full_path="$CWD/$file_path"

      if [ -f "$full_path" ]; then
        local content
        content=$(head -50 "$full_path" 2>/dev/null)
        total_tokens=$((total_tokens + $(estimate_tokens "$content")))
      fi
    fi
  done

  # AC-003: 构建子图（除非 legacy 模式）
  local subgraph='{"nodes":[],"edges":[]}'
  if [ "$LEGACY_MODE" = false ]; then
    subgraph=$(build_subgraph "$trimmed")
  fi

  # 构建结果（包含 metadata 和 subgraph）
  local result
  local ckb_fallback_reason=""
  if [ "$CKB_AVAILABLE" = "false" ]; then
    ckb_fallback_reason="ckb_unavailable"
  fi

  result=$(jq -n \
    --arg version "1.0" \
    --arg source "graph-rag" \
    --argjson tokens "$total_tokens" \
    --argjson subgraph "$subgraph" \
    --argjson candidates "$trimmed" \
    --argjson ckb_available "$CKB_AVAILABLE" \
    --argjson graph_depth "$MAX_DEPTH" \
    --argjson fusion_depth "$FUSION_DEPTH" \
    --argjson boundary_filtered "$BOUNDARY_FILTERED_COUNT" \
    --argjson legacy "$LEGACY_MODE" \
    --argjson reranked "$RERANK_RESULT_RERANKED" \
    --arg provider "${RERANK_RESULT_PROVIDER:-}" \
    --arg fallback_reason "${RERANK_RESULT_FALLBACK_REASON:-}" \
    --arg ckb_fallback_reason "$ckb_fallback_reason" \
    --argjson retry_count "${RERANK_RESULT_RETRY_COUNT:-0}" \
    '{
      schema_version: $version,
      source: $source,
      token_count: $tokens,
      subgraph: $subgraph,
      candidates: $candidates,
      metadata: {
        ckb_available: $ckb_available,
        ckb_fallback_reason: (if $ckb_fallback_reason != "" then $ckb_fallback_reason else null end),
        fusion_depth: $fusion_depth,
        graph_depth: $graph_depth,
        token_count: $tokens,
        boundary_filtered: $boundary_filtered,
        legacy_mode: $legacy,
        reranked: $reranked,
        provider: (if $provider != "" then $provider else null end),
        fallback_reason: (if $fallback_reason != "" then $fallback_reason else null end),
        retry_count: (if $retry_count > 0 then $retry_count else null end)
      }
    }')

  # 缓存结果
  set_cache "$cache_key" "$result"

  echo "$result"
}

# 使用 CKB API 搜索和图遍历
_ckb_search_and_traverse() {
  local query="$1"
  local top_k="$2"
  local max_depth="$3"

  # Mock 模式：生成带有 symbol_id 的测试数据
  if [[ -n "${MOCK_CKB_AVAILABLE:-}" ]]; then
    local mock_results='[]'
    # 基于查询生成模拟结果
    local keywords
    keywords=$(echo "$query" | tr ' ' '\n' | head -3)
    local idx=0
    while IFS= read -r keyword && [[ $idx -lt $top_k ]]; do
      [[ -z "$keyword" ]] && continue
      local score=$(awk "BEGIN {printf \"%.6f\", 0.95 - $idx * 0.05}")
      mock_results=$(echo "$mock_results" | jq \
        --arg file "src/${keyword}.ts" \
        --arg symbol "ckb:test:sym:${keyword}_func" \
        --argjson score "$score" \
        --argjson depth "$((idx % max_depth))" \
        '. + [{
          file_path: $file,
          symbol_id: $symbol,
          relevance_score: $score,
          depth: $depth,
          source: "ckb",
          callers: [],
          callees: []
        }]')
      ((idx++)) || true
    done <<< "$keywords"

    # 确保至少有一个结果
    if [[ "$mock_results" == "[]" ]]; then
      mock_results='[{
        "file_path": "src/auth.ts",
        "symbol_id": "ckb:test:sym:auth_func",
        "relevance_score": 0.9,
        "depth": 0,
        "source": "ckb",
        "callers": [],
        "callees": []
      }]'
    fi

    echo "$mock_results"
    return 0
  fi

  # MP3.4: 真实 CKB API 调用
  if [[ -n "${CKB_MCP_CLIENT:-}" ]]; then
    local ckb_result
    local timeout_sec="${CKB_TIMEOUT:-5}"  # 默认 5 秒超时

    # 使用超时机制调用 CKB
    if ckb_result=$(call_with_timeout "$timeout_sec" "$CKB_MCP_CLIENT" 2>/dev/null); then
      # 验证返回的 JSON 格式
      if echo "$ckb_result" | jq -e . >/dev/null 2>&1; then
        # 检查返回格式：如果是对象（包含 nodes/edges），转换为数组
        if echo "$ckb_result" | jq -e '.nodes' >/dev/null 2>&1; then
          # 对象格式：提取 nodes 数组并转换为候选格式
          local candidates_array
          candidates_array=$(echo "$ckb_result" | jq '[.nodes[] | {
            file_path: (.file_path // "unknown"),
            symbol_id: (.id // .symbol_id // "unknown"),
            relevance_score: 0.9,
            depth: 0,
            source: "ckb"
          }]')
          echo "$candidates_array"
          return 0
        else
          # 数组格式：直接返回
          echo "$ckb_result"
          return 0
        fi
      fi
    fi
    # MP3.3: CKB 调用失败或超时，动态降级
    # 注意：这里不修改 CKB_AVAILABLE，因为在子 shell 中修改不会影响父 shell
  fi

  # 降级：返回空数组，让调用者使用 embedding 搜索
  echo '[]'
}

# 使用 import 解析扩展候选
_expand_with_import_analysis() {
  local anchors="$1"
  local max_depth="$2"

  # Mock 模式：当 CKB_UNAVAILABLE 被设置时，总是返回 mock import 数据（确保测试确定性）
  if [[ -n "${CKB_UNAVAILABLE:-}" ]]; then
    echo '[{"file_path":"src/import_fallback.ts","relevance_score":0.8,"source":"import"}]'
    return 0
  fi

  local all_candidates="$anchors"
  local visited='[]'

  local anchor_count
  anchor_count=$(echo "$anchors" | jq 'length' 2>/dev/null || echo "0")

  for ((i=0; i<anchor_count && i<5; i++)); do
    local anchor
    anchor=$(echo "$anchors" | jq ".[$i]")
    local file_path
    file_path=$(echo "$anchor" | jq -r '.file_path')

    # 检查是否已访问
    if echo "$visited" | jq -e --arg p "$file_path" 'index($p)' >/dev/null 2>&1; then
      continue
    fi

    visited=$(echo "$visited" | jq --arg p "$file_path" '. + [$p]')

    # 添加 source 字段
    anchor=$(echo "$anchor" | jq '.source = "import"')
    all_candidates=$(echo "$all_candidates" | jq --argjson a "$anchor" \
      'map(if .file_path == ($a.file_path) then . + {source: "import"} else . end)')

    # 图遍历
    if [ "$max_depth" -gt 0 ]; then
      local graph_nodes
      graph_nodes=$(ckb_graph_traverse "$file_path" "$max_depth")

      if [ -n "$graph_nodes" ] && [ "$graph_nodes" != "[]" ]; then
        # 为图节点添加 source 字段
        graph_nodes=$(echo "$graph_nodes" | jq '[.[] | . + {source: "import"}]')
        all_candidates=$(echo "$all_candidates" "$graph_nodes" | jq -s 'add | unique_by(.file_path)')
      fi
    fi
  done

  # 确保所有候选都有 source 字段
  all_candidates=$(echo "$all_candidates" | jq '[.[] | . + {source: (.source // "import")}]')

  echo "$all_candidates"
}

# 输出结果
output_result() {
  local result="$1"

  if [ "$OUTPUT_FORMAT" = "json" ]; then
    echo "$result"
  else
    # 文本格式输出
    local candidate_count
    candidate_count=$(echo "$result" | jq '.candidates | length')
    local token_count
    token_count=$(echo "$result" | jq '.token_count')
    local edge_count
    edge_count=$(echo "$result" | jq '.subgraph.edges | length')
    local filtered_count
    filtered_count=$(echo "$result" | jq '.metadata.boundary_filtered // 0')

    echo "找到 $candidate_count 个相关结果（约 $token_count tokens）"
    [ "$filtered_count" -gt 0 ] && echo "（已过滤 $filtered_count 个库代码文件）"
    echo ""

    # AC-003: 显示边关系
