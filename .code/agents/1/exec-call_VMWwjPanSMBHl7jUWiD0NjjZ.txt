
#### 设计完善（对后续 Design Doc 的明确要求）

> 本小节用于满足“proposal.md 必须包含设计完善/设计要点内容”的要求（与下方“设计要点”互补）：列出必须在 `design.md` 中补齐并固化的关键设计点，避免实现阶段反推设计。

- **边界与契约**：客户端适配层（Claude Code Hook / Codex CLI wrapper）与编排内核（orchestrator）的输入/输出契约；错误码/退出码/输出 schema 的稳定性
- **自动调用策略**：白名单、置信度阈值、预算模型（总超时/并发/回填 token 上限）、超时/失败降级与重试规则
- **结果融合与解释**：结构化 JSON（供模型消费）与用户可读摘要（供终端展示）的格式；聚合/去重/溯源策略；top-k 限制与噪音抑制
- **中英文触发**：语言无关触发策略（中英关键词 + 结构信号），以及误触发/漏触发时的行为（例如自动降级、提示用户如何补充信息）
- **安全与隐私**：路径过滤/脱敏策略、默认采集边界、日志与可观测性（避免输出敏感内容到 prompt）
- **验收锚点**：如何在测试中验证“模型输出前已调用工具并回填”（含失败/超时降级的证据采集方式）

---

### 设计完善 / 设计要点（必须）

> 本节用于满足“proposal 需要完善里面的设计”的要求：只描述 What/Constraints/AC，不写实现步骤。

#### 设计要点 0：范围收敛（同包分阶段，不拆包）

本次变更强制保持“单变更包”，但允许**在同一变更包内分阶段交付**（同包分阶段，不拆包）：

- **MVP（必须交付）**：Tier-0/1 默认自动；Tier-2 仅条件触发或需用户确认；具备控制面/安全边界/预算/契约/验收锚点。
- **Tier-0/1**：自动（无需用户确认）。
- **Tier-2**：默认不“无条件自动”。触发必须满足：
  - 条件触发：意图=modify/debug 且明确给出文件/符号/报错；并且预算允许
  - 或用户确认触发：用户显式同意（例如在 prompt 中写“允许深度分析/impact/call chain”）
- **Tier-3**：高成本/高风险，默认永不自动（仅提示 + 手动触发）。

该约束用于保证“范围收敛”，避免本次交付演变成“把所有工具都塞进自动化”。

#### 设计要点 1：hooks 关系与调用链（回答用户 Q1；补齐调用链要求）

三者关系（都需要存在，且是**调用链**而非互斥）：

```
Claude Code (UserPromptSubmit)
  -> ~/.claude/hooks/context-inject-global.sh
       -> hooks/context-inject-global.sh (入口适配层)
            -> hooks/auto-tool-orchestrator.sh (编排内核)

兼容层：hooks/augment-context-global.sh
  -> exec hooks/context-inject-global.sh (仅为历史路径/测试保持兼容)
```

- `hooks/context-inject-global.sh`：入口与适配层
  - 负责输入适配：Claude Code Hook payload / Codex CLI wrapper 输入 / CLI 参数（如 `--prompt`）
  - 负责输出适配：
    - Claude Code：输出 `hookSpecificOutput.additionalContext`
    - Codex CLI：输出可拼接到 prompt 的“增强上下文块”（或 JSON 供 wrapper 二次格式化）
  - 负责**可控性与降级**：根据控制面决定是否调用编排内核；失败时 fail-open（不阻塞模型输出）

- `hooks/augment-context-global.sh`：仅做向后兼容
  - 现状已是“委托给 `context-inject-global.sh`”的 wrapper；本次保持该定位不膨胀

- `hooks/auto-tool-orchestrator.sh`：编排内核
  - 输入：标准化 prompt + signals + budget + allowlist + policy
  - 输出：Tool Plan + Tool Results + Fused Context（见下方 I/O 契约）

#### 设计要点 2：Codex CLI “模型输出前调用”的集成路径（补齐入口/触发/最小配置/差异）

Codex CLI 与 Claude Code 的关键差异：**Codex CLI 没有等价的官方 Hook 事件（如 UserPromptSubmit）**可直接复用，因此必须通过“入口包装”来保证“模型输出前调用”。

本提案采用“双入口策略”，都在“模型输出前”触发编排：

1) **入口 A（推荐，保证每轮预调用）：Codex CLI wrapper（外层交互循环）**
   - 入口形式：提供一个 wrapper 命令（例如 `codex-auto`），由它负责读取用户输入（每一轮）
   - 触发时机：每次用户提交一条 prompt -> 先调用 `hooks/auto-tool-orchestrator.sh` -> 再把增强后的 prompt 交给 `codex exec`（或 `codex exec resume`）
   - 最小配置：
     - 用户机器上已安装 `codex`
     - `~/.codex/config.toml` 已配置本项目的 MCP server（例如 `mcp_servers.code-intelligence`）
     - wrapper 能找到本仓库的 `hooks/context-inject-global.sh`（通常通过安装脚本复制到固定位置或加入 PATH）
   - 会话连续性（MVP，满足“入口 A 会话连续性”要求）：
     - session_id 来源：wrapper 以 `codex exec --json` / `codex exec resume --json` 运行，解析 JSON 事件中的 `session_id`；若未输出则视为无会话
     - 保存位置：`<repo-root>/.devbooks/cache/auto-tools/codex-session.json`（按 repo-root 存放，见 repo-root 规则）
     - resume 时机：第二轮起若 session_id 存在且为合法 UUID -> 执行 `codex exec resume <session_id>`；否则执行 `codex exec` 新会话
     - 丢失/冲突降级：session_id 缺失/非法/恢复失败 -> [Limits] 明示原因，降级为新会话并重写 session 文件
     - 回滚路径：删除该 session 文件（或设置 `CI_AUTO_TOOLS=off` 完全关闭自动编排）

2) **入口 B（次选，仅覆盖单次执行）：`codex exec <PROMPT>` 前置注入**
   - 入口形式：在运行 `codex exec` 之前，先把工具结果融合进用户本次 prompt
   - 触发时机：仅对该次 `codex exec` 有效（不保证在 Codex TUI 内的每轮输入都能拦截）

**plan/dry-run 与入口关系（明确）**：
- `CI_AUTO_TOOLS_MODE=plan` / `CI_AUTO_TOOLS_DRY_RUN=1` 时，入口 A/B 只输出增强 prompt/编排 JSON，不调用 codex
- 该模式用于 bats 自动化（确定性输出），避免依赖外部 codex

与 Claude Code 的差异点总结：
- Claude Code：Hook 由客户端原生触发（UserPromptSubmit），自动且可覆盖每轮对话
- Codex CLI：通过 wrapper 保证“每轮 prompt 都先编排再回答”；不依赖 Codex CLI 内部改造

#### 设计要点 3：控制面（开关/降级/回滚）与配置优先级（env > config > default）

控制面目标：用户可控、可降级、可快速回滚，且默认行为明确。

- **配置优先级（强制）**：`env > config > default`
  - env：紧急回滚/本地临时覆盖（不改文件）
  - config：统一指向 `config/auto-tools.yaml`（新增，唯一来源；禁止与 `.devbooks/config.yaml` 混用）
  - default：脚本内的保守默认值

- **与 `.devbooks/config.yaml` 的关系（明确）**：
  - `.devbooks/config.yaml` 仅用于 DevBooks 工具链/AI 工具配置，不参与自动编排控制面
  - 若用户在 `.devbooks/config.yaml` 误放自动编排配置，视为无效，并在 [Limits] 提示“请迁移到 `config/auto-tools.yaml`”

- **最小控制面（建议键）**：
  - `CI_AUTO_TOOLS=auto|on|off`（默认 `auto`：仅代码意图/明确需求时启用）
  - `CI_AUTO_TOOLS_MODE=run|plan`（默认 `run`；`plan` 仅生成计划与解释，不实际调用工具/不调用 codex）
  - `CI_AUTO_TOOLS_TIER_MAX=1|2`（默认 `1`；Tier-2 仅条件/确认触发）
  - `CI_AUTO_TOOLS_BUDGET_WALL_MS=5000`（默认 5000ms；见预算默认值）
  - `CI_AUTO_TOOLS_MAX_CONCURRENCY=3`（默认 3）
  - `CI_AUTO_TOOLS_DRY_RUN=0|1`（默认 `0`；为 `1` 时等价于 `CI_AUTO_TOOLS_MODE=plan`）

- **默认行为（明确）**：
  - 默认 `CI_AUTO_TOOLS=auto`：代码意图 -> 走 Tier-0/1；非代码意图 -> 输出空注入
  - 默认 `CI_AUTO_TOOLS_TIER_MAX=1`：不无条件触发 Tier-2
  - 默认 fail-open：任一工具超时/失败 -> 降级并继续输出（必须在 [Limits] 中说明原因）

- **回滚策略**：
  - 软回滚：`CI_AUTO_TOOLS_MODE=plan` 或 `CI_AUTO_TOOLS_TIER_MAX=1`（保留可见性但降低成本）
  - 硬回滚：`CI_AUTO_TOOLS=off`（完全关闭自动编排，回到旧行为）

- **plan/dry-run 确定性输出契约（可重复验收）**：
  - 输出固定 JSON：至少包含 `schema_version`、`run_id`、`tool_plan`、`fused_context.for_model.additional_context`
  - 该模式**不调用 codex**，仅输出增强 prompt/编排 JSON 供 bats 断言
  - `run_id` 规则：
    - plan/dry-run：`plan-<hash12>`（hash 为 `prompt + repo_root + tool_plan` 的稳定哈希）
    - run：`YYYYMMDD-HHMMSS-<hash6>`（hash 为 `prompt + repo_root` 的稳定哈希）

#### 设计要点 4：自动调用白名单/安全边界/脱敏与路径过滤规则

- **自动调用白名单（默认允许）**：仅允许“只读/分析类” MCP 工具自动调用；默认禁止任何具有外部副作用的操作（写文件/删文件/执行任意命令/联网扫描）。
- **工具分层（默认策略）**：
  - Tier-0（默认自动）：`ci_index_status`
  - Tier-1（默认自动）：`ci_search`、`ci_graph_rag`
  - Tier-2（条件/确认）：`ci_call_chain`、`ci_bug_locate`、`ci_impact`、`ci_complexity`、`ci_hotspot`
  - Tier-3（默认不自动）：任何可能触发网络/重依赖扫描/大规模遍历的工具（例如依赖漏洞扫描等）

- **参数裁剪（必须）**：对自动调用的工具强制上限，禁止从 prompt 直接透传“危险参数”。
  - `ci_graph_rag.depth <= 2`、`budget <= 8000`、`top_k <= 10`
  - `ci_search.limit <= 10`
  - `ci_call_chain.depth <= 3`
  - `ci_hotspot.days <= 30`、`top <= 20`

- **路径过滤（必须）**：
  - **repo-root 判定优先级（强制）**：
    1) 明确配置：`CI_AUTO_TOOLS_REPO_ROOT`（env）或 `config/auto-tools.yaml` 中 `repo_root`
    2) Git：若 `git rev-parse --show-toplevel` 成功 -> 该输出为 repo-root
    3) 兜底：`pwd`（仅在无 git/非工作树时生效）
  - **无 git 场景**：使用 `pwd` 作为 repo-root，并在 [Limits] 标注 “no-git-root”；路径过滤仍按 repo-root 生效
  - **子目录场景**：若在子目录运行，仍使用 git 的顶层目录作为 repo-root，保证路径过滤一致
  - **monorepo 场景**：默认仍使用 git 顶层目录；如需子项目根，必须显式配置 `repo_root`
  - 仅允许读取 `<repo-root>` 下的路径（realpath 校验，禁止 `..` 逃逸）。
  - 默认排除：沿用现有 `EXCLUDE_PATTERN`；并追加敏感模式（即使在 repo 内也默认不回填内容）：`.env`、`*.pem`、`*.key`、`id_rsa*`、`**/.ssh/**`、`**/secrets/**`、`**/.npmrc`。
  - 二进制/超大文件：默认跳过或仅回填元信息（路径 + 大小 + 哈希），避免泄露与 token 爆炸。

- **脱敏（必须）**：
  - 回填到 prompt 的任何文本都要做脱敏：例如 `Bearer <redacted>`、`AKIA<redacted>`、`-----BEGIN ... KEY-----`。
  - 默认只回填“摘要 + 溯源 + 片段（严格限额）”，不回填整文件。

#### 设计要点 5：预算/并发默认值（具体数字 + 依据）

默认取“质量型维护者”的保守预算（交互可接受，避免无上限调用）。取值尽量对齐现有 `hooks/context-inject-global.sh` 的默认超时/Top-K 习惯，减少不确定性：

- **总墙钟预算（Tier-0/1）**：`5000ms`
- **并发上限**：`3`
- **单工具超时（默认）**：
  - `ci_index_status`：`500ms`
  - `ci_search`：`2000ms`（对齐现有 `SEARCH_TIMEOUT=2`）
  - `ci_graph_rag`：`3500ms`（对齐现有 `max_depth=2/top_k=10/token_budget=8000` 的保守上限）
  - `ci_complexity`：`1000ms`（对齐现有 `COMPLEXITY_TIMEOUT=1`）
  - Tier-2（条件/确认）额外预算：`+5000ms`（仅在触发时启用）

- **结果与回填限额（默认）**：
  - `graph_rag.max_depth=2`、`graph_rag.top_k=10`、`graph_rag.token_budget=8000`
  - 代码片段：`max_snippets=3`、`max_lines_per_snippet=20`（对齐现有默认）
  - 回填上限：`max_injected_chars=12000`（约 2k-3k tokens）；超出必须标记 `truncated=true`

#### 设计要点 6：编排内核 I/O 契约（Tool Plan / Tool Results / Fused Context JSON schema + 版本/兼容）

编排内核输出必须是**稳定 JSON**，并携带版本号，供入口层与不同客户端消费。

Schema（v1.0；新增字段必须保持向前兼容）：

```jsonc
{
  "schema_version": "1.0",
  "run_id": "string",
  "created_at": "string",
  "client": {
    "name": "claude-code|codex-cli",
    "event": "UserPromptSubmit|cli",
    "session_id": "string?"
  },
  "inputs": {
    "prompt": "string",
    "signals": [
      {"type": "explicit|implicit|historical|code", "match": "string", "weight": "number"}
    ]
  },
  "tool_plan": {
    "tier_max": "number",
    "budget": {
      "wall_ms": "number",
      "max_concurrency": "number",
      "max_injected_chars": "number"
    },
    "tools": [
      {"tool": "string", "tier": "number", "reason": "string", "args": "object", "timeout_ms": "number"}
    ]
  },
  "tool_results": [
    {
      "tool": "string",
      "status": "ok|timeout|error|skipped",
      "started_at": "string",
      "duration_ms": "number",
      "summary": "string",
      "data": "object?",
      "error": {"message": "string", "code": "string?"},
      "redactions": [{"kind": "string", "count": "number"}],
      "truncated": "boolean"
