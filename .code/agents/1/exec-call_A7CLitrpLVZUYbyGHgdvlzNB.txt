#!/usr/bin/env node
/**
 * Code Intelligence MCP Server
 *
 * A thin MCP shell that delegates to shell scripts for code intelligence capabilities.
 * CON-TECH-002: MCP Server 使用 Node.js 薄壳调用 Shell 脚本
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { execFile } from "child_process";
import { promisify } from "util";
import { dirname, join } from "path";
import { fileURLToPath } from "url";

const execFileAsync = promisify(execFile);

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const SCRIPTS_DIR = join(__dirname, "..", "scripts");

const VERSION = "0.1.0";

// Configuration constants
const SCRIPT_TIMEOUT_MS = 60000; // 60s timeout
const MAX_BUFFER_SIZE = 10 * 1024 * 1024; // 10MB buffer

interface ExecError extends Error {
  stdout?: string;
  stderr?: string;
}

// Tool definitions
const TOOLS = [
  {
    name: "ci_search",
    description: "Semantic code search using embeddings or keywords",
    inputSchema: {
      type: "object" as const,
      properties: {
        query: { type: "string", description: "Search query" },
        limit: { type: "number", description: "Max results (default: 10)" },
        mode: {
          type: "string",
          enum: ["semantic", "keyword"],
          description: "Search mode (default: semantic)",
        },
      },
      required: ["query"],
    },
  },
  {
    name: "ci_call_chain",
    description: "Trace function call chains",
    inputSchema: {
      type: "object" as const,
      properties: {
        symbol: { type: "string", description: "Symbol to trace" },
        direction: {
          type: "string",
          enum: ["callers", "callees", "both"],
          description: "Trace direction (default: both)",
        },
        depth: { type: "number", description: "Max depth (default: 3)" },
      },
      required: ["symbol"],
    },
  },
  {
    name: "ci_bug_locate",
    description: "Locate potential bug locations based on error description",
    inputSchema: {
      type: "object" as const,
      properties: {
        error: { type: "string", description: "Error message or description" },
      },
      required: ["error"],
    },
  },
  {
    name: "ci_complexity",
    description: "Analyze code complexity metrics",
    inputSchema: {
      type: "object" as const,
      properties: {
        path: { type: "string", description: "File or directory path" },
        format: {
          type: "string",
          enum: ["text", "json"],
          description: "Output format (default: text)",
        },
      },
      required: ["path"],
    },
  },
  {
    name: "ci_graph_rag",
    description: "Get Graph-RAG context for a query",
    inputSchema: {
      type: "object" as const,
      properties: {
        query: { type: "string", description: "Query for context retrieval" },
        depth: { type: "number", description: "Graph traversal depth (default: 2)" },
        budget: { type: "number", description: "Token budget (default: 8000)" },
      },
      required: ["query"],
    },
  },
  {
    name: "ci_index_status",
    description: "Check or manage embedding index status",
    inputSchema: {
      type: "object" as const,
      properties: {
        action: {
          type: "string",
          enum: ["status", "build", "clear"],
          description: "Action to perform (default: status)",
        },
      },
    },
  },
  {
    name: "ci_hotspot",
    description: "Analyze code hotspots based on change frequency and complexity",
    inputSchema: {
      type: "object" as const,
      properties: {
        top: { type: "number", description: "Number of top hotspots to return (default: 20)" },
        days: { type: "number", description: "Number of days to analyze git history (default: 30)" },
        format: {
          type: "string",
          enum: ["text", "json"],
          description: "Output format (default: json)",
        },
        path: { type: "string", description: "Target directory to analyze (default: current directory)" },
      },
    },
  },
  {
    name: "ci_boundary",
    description: "Detect code boundary type (user/library/generated/vendor)",
    inputSchema: {
      type: "object" as const,
      properties: {
        file: { type: "string", description: "File or pattern to check" },
        format: {
          type: "string",
          enum: ["text", "json"],
          description: "Output format (default: json)",
        },
      },
      required: ["file"],
    },
  },
  {
    name: "ci_arch_check",
    description: "Check architecture rules and detect circular dependencies",
    inputSchema: {
      type: "object" as const,
      properties: {
        path: { type: "string", description: "Path to analyze (default: current directory)" },
        format: {
          type: "string",
          enum: ["text", "json"],
          description: "Output format (default: json)",
        },
        rules: { type: "string", description: "Path to architecture rules file (default: config/arch-rules.yaml)" },
      },
    },
  },
  {
    name: "ci_federation",
    description: "Cross-repo API contract tracking, symbol search, and virtual edges",
    inputSchema: {
      type: "object" as const,
      properties: {
        action: {
          type: "string",
          enum: ["status", "update", "search", "generate-virtual-edges", "query-virtual"],
          description: "Action to perform (default: status)",
        },
        query: { type: "string", description: "Symbol query for search/query-virtual action" },
        format: {
          type: "string",
          enum: ["text", "json"],
          description: "Output format (default: json)",
        },
        min_confidence: { type: "number", description: "Minimum confidence threshold for virtual edges (default: 0.5)" },
        local_repo: { type: "string", description: "Local repository path for generate-virtual-edges (default: current directory)" },
        sync: { type: "boolean", description: "Enable sync mode for generate-virtual-edges (update existing, remove stale)" },
      },
    },
  },
  {
    name: "ci_graph_store",
    description: "图存储操作（初始化、查询、统计）",
    inputSchema: {
      type: "object" as const,
      properties: {
        action: {
          type: "string",
          enum: ["init", "query", "stats"],
          description: "Action to perform: init (initialize database), query (execute SQL), stats (show statistics)",
        },
        payload: {
          type: "object",
          properties: {
            sql: { type: "string", description: "SQL query for query action" },
          },
          description: "Payload object for query action containing sql field",
        },
      },
      required: ["action"],
    },
  },
  // MP8.1: AST Delta 增量索引工具
  {
    name: "ci_ast_delta",
    description: "AST 增量索引操作（基于 tree-sitter 的快速代码变更检测）",
    inputSchema: {
      type: "object" as const,
      properties: {
        action: {
          type: "string",
          enum: ["update", "batch", "status", "clear-cache"],
          description: "Action to perform: update (single file), batch (multiple files), status, clear-cache",
        },
        file: { type: "string", description: "File path for update action" },
        since: { type: "string", description: "Git ref for batch action (default: HEAD~1)" },
      },
    },
  },
  // MP8.2: 影响分析工具
  {
    name: "ci_impact",
    description: "符号变更的传递性影响分析（多跳图遍历 + 置信度衰减）",
    inputSchema: {
      type: "object" as const,
      properties: {
        symbol: { type: "string", description: "Symbol to analyze impact for" },
        file: { type: "string", description: "File path for file-level analysis (alternative to symbol)" },
        depth: { type: "number", description: "Max traversal depth (default: 3, max: 5)" },
        decay: { type: "number", description: "Decay factor for impact calculation (default: 0.8)" },
        threshold: { type: "number", description: "Minimum impact threshold (default: 0.1)" },
        format: {
          type: "string",
          enum: ["json", "md", "mermaid"],
          description: "Output format (default: json)",
        },
      },
    },
  },
  // MP8.3: COD 架构可视化工具
  {
    name: "ci_cod",
    name: "ci_cod",
    description: "代码库架构可视化（生成 Mermaid 或 D3.js JSON 格式的架构图）",
    inputSchema: {
      type: "object" as const,
      properties: {
        action: {
          type: "string",
          enum: ["generate", "module"],
          description: "Action: generate (full codebase), module (specific module)",
        },
        level: {
          type: "number",
          enum: [1, 2, 3],
          description: "Visualization level: 1=system context, 2=module, 3=file (default: 2)",
        },
        module: { type: "string", description: "Module path for module action" },
        format: {
          type: "string",
          enum: ["mermaid", "d3json"],
          description: "Output format (default: mermaid)",
        },
        include_hotspots: { type: "boolean", description: "Include hotspot coloring (default: true)" },
        include_complexity: { type: "boolean", description: "Include complexity annotations (default: false)" },
      },
    },
  },
  // MP8.4: 意图偏好学习工具
  {
    name: "ci_intent",
    description: "用户查询意图历史记录和偏好学习",
    inputSchema: {
      type: "object" as const,
      properties: {
        action: {
          type: "string",
          enum: ["record", "get-preferences", "cleanup", "stats"],
          description: "Action: record (add query), get-preferences, cleanup, stats",
        },
        query: { type: "string", description: "Query text for record action" },
        symbols: {
          type: "array",
          items: { type: "string" },
          description: "Matched symbols for record action",
        },
        user_action: {
          type: "string",
          enum: ["view", "edit", "ignore"],
          description: "User action for record (default: view)",
        },
        top: { type: "number", description: "Number of top preferences to return (default: 10)" },
        prefix: { type: "string", description: "Filter preferences by path prefix" },
        days: { type: "number", description: "Days threshold for cleanup (default: 90)" },
      },
    },
  },
  // MP8.5: 安全漏洞追踪工具
  {
    name: "ci_vuln",
    description: "依赖安全漏洞扫描与追踪（集成 npm audit）",
    inputSchema: {
      type: "object" as const,
      properties: {
        action: {
          type: "string",
          enum: ["scan", "trace"],
          description: "Action: scan (vulnerability scan), trace (dependency trace)",
        },
        package: { type: "string", description: "Package name for trace action" },
        severity: {
          type: "string",
          enum: ["low", "moderate", "high", "critical"],
          description: "Minimum severity threshold (default: moderate)",
        },
        format: {
          type: "string",
          enum: ["json", "md"],
          description: "Output format (default: json)",
        },
        include_dev: { type: "boolean", description: "Include dev dependencies (default: false)" },
      },
    },
  },
];

async function runScript(
  script: string,
  args: string[]
): Promise<{ stdout: string; stderr: string }> {
  const scriptPath = join(SCRIPTS_DIR, script);
  // Use execFile instead of exec to avoid shell injection vulnerabilities
  // Arguments are passed as array, not interpolated into a shell command string

  try {
    const { stdout, stderr } = await execFileAsync("bash", [scriptPath, ...args], {
      timeout: SCRIPT_TIMEOUT_MS,
      maxBuffer: MAX_BUFFER_SIZE,
    });
    return { stdout, stderr };
  } catch (error: unknown) {
    const execError = error as ExecError;
    // Return partial output even on error
    return {
      stdout: execError.stdout || "",
      stderr: execError.stderr || execError.message || "Unknown error",
    };
  }
}

async function handleToolCall(
  name: string,
  args: Record<string, unknown>
): Promise<string> {
  switch (name) {
    case "ci_search": {
      const query = args.query as string;
      const limit = (args.limit as number) || 10;
      const mode = (args.mode as string) || "semantic";
      const { stdout, stderr } = await runScript("embedding.sh", [
        "search",
        query,
        "--limit",
        String(limit),
        "--mode",
        mode,
      ]);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_call_chain": {
      const symbol = args.symbol as string;
      const direction = (args.direction as string) || "both";
      const depth = (args.depth as number) || 3;
      const { stdout, stderr } = await runScript("call-chain.sh", [
        symbol,
        "--direction",
        direction,
        "--depth",
        String(depth),
      ]);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_bug_locate": {
      const error = args.error as string;
      const { stdout, stderr } = await runScript("bug-locator.sh", [
        "--error",
        error,
      ]);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_complexity": {
      const path = args.path as string;
      const format = (args.format as string) || "text";
      const { stdout, stderr } = await runScript("complexity.sh", [
        path,
        "--format",
        format,
      ]);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_graph_rag": {
      const query = args.query as string;
      const depth = (args.depth as number) || 2;
      const budget = (args.budget as number) || 8000;
      const { stdout, stderr } = await runScript("graph-rag.sh", [
        query,
        "--depth",
        String(depth),
        "--budget",
        String(budget),
      ]);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_index_status": {
      const action = (args.action as string) || "status";
      const { stdout, stderr } = await runScript("indexer.sh", [action]);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_hotspot": {
      const top = (args.top as number) || 20;
      const days = (args.days as number) || 30;
      const format = (args.format as string) || "json";
      const path = (args.path as string) || ".";
      const { stdout, stderr } = await runScript("hotspot-analyzer.sh", [
        "--top",
        String(top),
        "--days",
        String(days),
        "--format",
        format,
        "--path",
        path,
      ]);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_boundary": {
      const file = args.file as string;
      const format = (args.format as string) || "json";
      const { stdout, stderr } = await runScript("boundary-detector.sh", [
        "--format",
        format,
        file,
      ]);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_arch_check": {
      const path = (args.path as string) || ".";
      const format = (args.format as string) || "json";
      const rules = (args.rules as string) || "";
      const scriptArgs = ["--all", "--scope", path, "--format", format];
      if (rules) {
        scriptArgs.push("--rules", rules);
      }
      const { stdout, stderr } = await runScript("dependency-guard.sh", scriptArgs);
      return stderr ? `${stdout}\n[stderr]: ${stderr}` : stdout;
    }

    case "ci_federation": {
      const action = (args.action as string) || "status";
      const query = (args.query as string) || "";
      const format = (args.format as string) || "json";
      const minConfidence = args.min_confidence as number | undefined;
      const localRepo = args.local_repo as string | undefined;
      const sync = args.sync === true;

      const scriptArgs: string[] = [];
      switch (action) {
        case "status":
          scriptArgs.push("--status");
          break;
        case "update":
          scriptArgs.push("--update");
          break;
        case "search":
          scriptArgs.push("--search", query);
          break;
        case "generate-virtual-edges":
          scriptArgs.push("generate-virtual-edges");
          if (localRepo) {
            scriptArgs.push("--local-repo", localRepo);
          }
          if (minConfidence !== undefined) {
            scriptArgs.push("--min-confidence", String(minConfidence));
          }
          if (sync) {
            scriptArgs.push("--sync");
          }
          break;
        case "query-virtual":
          if (!query) {
            return "Error: query-virtual action requires query parameter";
          }
          scriptArgs.push("query-virtual", query);
          if (minConfidence !== undefined) {
            scriptArgs.push("--confidence", String(minConfidence));
#!/bin/bash
# DevBooks 后台索引守护进程
# 监听文件变化，自动触发 SCIP 索引更新

set -e

# 配置
DEBOUNCE_SECONDS=30      # 防抖：文件变化后等待秒数
INDEX_INTERVAL=300       # 最小索引间隔（秒）
WATCH_EXTENSIONS="ts,tsx,js,jsx,py,go,rs,java"
IGNORE_PATTERNS="node_modules|dist|build|\.git|__pycache__|\.lock"

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info()  { echo -e "${BLUE}[DevBooks]${NC} $1"; }
log_ok()    { echo -e "${GREEN}[DevBooks]${NC} $1"; }
log_warn()  { echo -e "${YELLOW}[DevBooks]${NC} $1"; }
log_error() { echo -e "${RED}[DevBooks]${NC} $1"; }

# 检测项目语言
detect_language() {
  local dir="$1"
  if [ -f "$dir/tsconfig.json" ] || [ -f "$dir/package.json" ]; then
    echo "typescript"
  elif [ -f "$dir/pyproject.toml" ] || [ -f "$dir/setup.py" ] || [ -f "$dir/requirements.txt" ]; then
    echo "python"
  elif [ -f "$dir/go.mod" ]; then
    echo "go"
  elif [ -f "$dir/Cargo.toml" ]; then
    echo "rust"
  else
    echo "unknown"
  fi
}

# 获取索引命令
get_index_command() {
  local lang="$1"
  case "$lang" in
    typescript)
      if command -v scip-typescript &>/dev/null; then
        echo "scip-typescript index --output index.scip"
      else
        echo ""
      fi
      ;;
    python)
      if command -v scip-python &>/dev/null; then
        echo "scip-python index . --output index.scip"
      else
        echo ""
      fi
      ;;
    go)
      if command -v scip-go &>/dev/null; then
        echo "scip-go --output index.scip"
      else
        echo ""
      fi
      ;;
    *)
      echo ""
      ;;
  esac
}

# 执行索引
do_index() {
  local dir="$1"
  local lang=$(detect_language "$dir")
  local cmd=$(get_index_command "$lang")

  if [ -z "$cmd" ]; then
    log_warn "无法为 $lang 项目生成索引（索引器未安装）"
    return 1
  fi

  log_info "开始索引 ($lang)..."
  local start_time=$(date +%s)

  if (cd "$dir" && eval "$cmd" 2>/dev/null); then
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    log_ok "索引完成 (${duration}s)"
    return 0
  else
    log_error "索引失败"
    return 1
  fi
}

# 检查文件监听工具
check_watcher() {
  if command -v fswatch &>/dev/null; then
    echo "fswatch"
  elif command -v inotifywait &>/dev/null; then
    echo "inotifywait"
  else
    echo ""
  fi
}

# 使用 fswatch 监听（macOS）
watch_with_fswatch() {
  local dir="$1"
  local last_index=0

  log_info "使用 fswatch 监听文件变化..."

  fswatch -r -e "$IGNORE_PATTERNS" \
    --include "\\.($WATCH_EXTENSIONS)$" \
    "$dir" | while read -r changed_file; do

    local now=$(date +%s)
    local since_last=$((now - last_index))

    # 防抖 + 最小间隔
    if [ $since_last -lt $INDEX_INTERVAL ]; then
      continue
    fi

    log_info "检测到变化: $(basename "$changed_file")"
    sleep $DEBOUNCE_SECONDS

    if do_index "$dir"; then
      last_index=$(date +%s)
    fi
  done
}

# 使用 inotifywait 监听（Linux）
watch_with_inotify() {
  local dir="$1"
  local last_index=0

  log_info "使用 inotifywait 监听文件变化..."

  inotifywait -r -m -e modify,create,delete \
    --exclude "$IGNORE_PATTERNS" \
    "$dir" | while read -r path action file; do

    # 检查文件扩展名
    if ! echo "$file" | grep -qE "\.($WATCH_EXTENSIONS)$"; then
      continue
    fi

    local now=$(date +%s)
    local since_last=$((now - last_index))

    if [ $since_last -lt $INDEX_INTERVAL ]; then
      continue
    fi

    log_info "检测到变化: $file ($action)"
    sleep $DEBOUNCE_SECONDS

    if do_index "$dir"; then
      last_index=$(date +%s)
    fi
  done
}

# 轮询模式（无监听工具时的降级方案）
watch_with_polling() {
  local dir="$1"
  local poll_interval=${INDEX_INTERVAL:-300}

  log_warn "未找到文件监听工具，使用轮询模式（每 ${poll_interval}s）"

  while true; do
    local index_file="$dir/index.scip"

    if [ ! -f "$index_file" ]; then
      do_index "$dir"
    else
      # 检查是否有比索引更新的文件
      local newer_files=$(find "$dir" \
        -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.py" -o -name "*.go" \) \
        -newer "$index_file" \
        ! -path "*/node_modules/*" ! -path "*/dist/*" ! -path "*/.git/*" \
        2>/dev/null | head -1)

      if [ -n "$newer_files" ]; then
        log_info "发现更新的文件，重新索引..."
        do_index "$dir"
      fi
    fi

    sleep $poll_interval
  done
}

# 主函数
main() {
  local project_dir="${1:-$(pwd)}"

  if [ ! -d "$project_dir" ]; then
    log_error "目录不存在: $project_dir"
    exit 1
  fi

  log_info "DevBooks 后台索引守护进程启动"
  log_info "项目目录: $project_dir"

  local lang=$(detect_language "$project_dir")
  log_info "检测到语言: $lang"

  # 首次索引
  if [ ! -f "$project_dir/index.scip" ]; then
    log_info "首次运行，生成初始索引..."
    do_index "$project_dir"
  else
    log_ok "索引已存在，跳过初始索引"
  fi

  # 选择监听方式
  local watcher=$(check_watcher)

  case "$watcher" in
    fswatch)
      watch_with_fswatch "$project_dir"
      ;;
    inotifywait)
      watch_with_inotify "$project_dir"
      ;;
    *)
      watch_with_polling "$project_dir"
      ;;
  esac
}

# 帮助信息
show_help() {
  cat << EOF
DevBooks 后台索引守护进程
DevBooks 后台索引守护进程

用法:
  $0 [项目目录]          启动守护进程
  $0 --install           安装为 LaunchAgent (macOS)
  $0 --uninstall         卸载 LaunchAgent
  $0 --status            检查状态
  $0 --help              显示帮助

环境变量:
  DEBOUNCE_SECONDS       防抖时间（默认 30s）
  INDEX_INTERVAL         最小索引间隔（默认 300s）

依赖:
  - fswatch (macOS) 或 inotifywait (Linux) 用于文件监听
  - scip-typescript / scip-python / scip-go 用于生成索引

EOF
}

# 安装为 LaunchAgent (macOS)
install_launchagent() {
  local plist_path="$HOME/Library/LaunchAgents/com.devbooks.indexer.plist"
  local script_path="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
  local project_dir="${1:-$(pwd)}"

  cat > "$plist_path" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.devbooks.indexer</string>
    <key>ProgramArguments</key>
    <array>
        <string>$script_path</string>
        <string>$project_dir</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>/tmp/devbooks-indexer.log</string>
    <key>StandardErrorPath</key>
    <string>/tmp/devbooks-indexer.log</string>
</dict>
</plist>
EOF

  launchctl load "$plist_path"
  log_ok "LaunchAgent 已安装并启动"
  log_info "日志: /tmp/devbooks-indexer.log"
}

# 解析参数
case "${1:-}" in
  --help|-h)
    show_help
    exit 0
    ;;
  --install)
    install_launchagent "${2:-$(pwd)}"
    exit 0
    ;;
  --uninstall)
    launchctl unload "$HOME/Library/LaunchAgents/com.devbooks.indexer.plist" 2>/dev/null || true
    rm -f "$HOME/Library/LaunchAgents/com.devbooks.indexer.plist"
    log_ok "LaunchAgent 已卸载"
    exit 0
    ;;
  --status)
    if launchctl list | grep -q "com.devbooks.indexer"; then
      log_ok "守护进程运行中"
    else
      log_warn "守护进程未运行"
    fi
    exit 0
    ;;
  *)
    main "$@"
    ;;
esac
#!/bin/bash
# scip-to-graph.sh - SCIP 索引解析转换脚本
# 版本: 1.0
# 用途: 将 SCIP 索引解析为图数据并写入 SQLite
#
# 覆盖 AC-002: SCIP -> 图数据转换成功
# 契约测试: CT-SP-001, CT-SP-002
#
# 环境变量:
#   SCIP_INDEX_PATH - SCIP 索引路径，默认 index.scip
#   GRAPH_DB_PATH - 数据库路径，默认 .devbooks/graph.db
#   DEVBOOKS_DIR - 工作目录，默认 .devbooks

set -euo pipefail

# 加载共享函数
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common.sh"

# 设置日志前缀
LOG_PREFIX="scip-to-graph"

# ==================== 配置 ====================

: "${DEVBOOKS_DIR:=.devbooks}"
: "${SCIP_INDEX_PATH:=index.scip}"
: "${GRAPH_DB_PATH:=$DEVBOOKS_DIR/graph.db}"

# SCIP proto 文件路径
SCIP_PROTO_PATH="/tmp/scip.proto"
SCIP_PROTO_URL="https://raw.githubusercontent.com/sourcegraph/scip/main/scip.proto"

# symbol_roles 映射（使用函数代替关联数组，兼容 bash 3）
# 1 -> DEFINES (Definition)
# 2 -> IMPORTS (Import)
# 4 -> MODIFIES (WriteAccess)
# 8 -> CALLS (ReadAccess)

# ==================== 辅助函数 ====================

# 确保 SCIP proto 文件存在
ensure_scip_proto() {
    if [[ ! -f "$SCIP_PROTO_PATH" ]]; then
        log_info "Downloading SCIP proto definition..."
        if command -v curl &>/dev/null; then
            curl -s "$SCIP_PROTO_URL" -o "$SCIP_PROTO_PATH" 2>/dev/null || return 1
        elif command -v wget &>/dev/null; then
            wget -q "$SCIP_PROTO_URL" -O "$SCIP_PROTO_PATH" 2>/dev/null || return 1
        else
            return 1
        fi
    fi
    return 0
}

# 检查 SCIP 索引是否比数据库新
is_scip_fresh() {
    local scip_path="$1"
    local db_path="$2"

    if [[ ! -f "$db_path" ]]; then
        return 0  # 数据库不存在，需要解析
    fi

    if [[ ! -f "$scip_path" ]]; then
        return 1  # SCIP 不存在
    fi

    # 比较修改时间
    if [[ "$scip_path" -nt "$db_path" ]]; then
        return 0  # SCIP 比数据库新
    fi

    return 1  # 数据库是最新的
}

# 映射 symbol_roles 到边类型
map_role_to_edge_type() {
    local role="$1"

    # 检查各个位
    if (( role & 1 )); then
        echo "DEFINES"
    elif (( role & 2 )); then
        echo "IMPORTS"
    elif (( role & 4 )); then
        echo "MODIFIES"
    elif (( role & 8 )); then
        echo "CALLS"
    else
        echo "CALLS"  # 默认为 CALLS
    fi
}

# 从符号字符串提取类型
extract_symbol_kind() {
    local symbol="$1"

    # SCIP 符号格式: scheme package descriptor
    # 例如: scip-typescript npm @types/node 18.0.0 path/`join`().
    if [[ "$symbol" == *"\`"*"()"* ]]; then
        echo "function"
    elif [[ "$symbol" == *"#"* ]]; then
        echo "class"
    elif [[ "$symbol" == *"."* ]]; then
        echo "variable"
    else
        echo "symbol"
    fi
}

# 生成节点 ID
generate_node_id() {
    local symbol="$1"
    # 使用 MD5 哈希生成稳定 ID
    hash_string_md5 "$symbol"
}

# ==================== SCIP 解析 (Node.js) ====================

# 使用 Node.js 解析 SCIP protobuf
parse_scip_with_node() {
    local scip_path="$1"
    local output_file="$2"

    # 确保 proto 文件存在
    ensure_scip_proto || return 1

    # 获取项目根目录（用于找到 node_modules）
    local project_root
    project_root=$(cd "$SCRIPT_DIR/.." && pwd)

    # 创建临时 Node.js 脚本（使用 .cjs 扩展名强制 CommonJS）
    local node_script="$project_root/.devbooks/parse-scip-temp.cjs"
    mkdir -p "$(dirname "$node_script")"

    cat > "$node_script" << 'NODEJS_SCRIPT'
const protobuf = require('protobufjs');
const fs = require('fs');

async function main() {
    const scipPath = process.argv[2];
    const outputPath = process.argv[3];

    try {
        const root = await protobuf.load('/tmp/scip.proto');
        const Index = root.lookupType('scip.Index');

        const buffer = fs.readFileSync(scipPath);
        const index = Index.decode(buffer);

        const result = {
            nodes: [],
            edges: [],
            stats: {
                documents: 0,
                symbols: 0,
                occurrences: 0,
                defines: 0,
                imports: 0,
                calls: 0,
                modifies: 0
            }
        };

        if (index.documents) {
            result.stats.documents = index.documents.length;

            index.documents.forEach(doc => {
                const filePath = doc.relativePath || '';

                // 处理符号定义
                if (doc.symbols) {
                    doc.symbols.forEach(sym => {
                        result.stats.symbols++;

                        const nodeId = sym.symbol;
                        const kind = sym.symbol.includes('`') && sym.symbol.includes('()') ? 'function' :
                                    sym.symbol.includes('#') ? 'class' : 'variable';

                        result.nodes.push({
                            id: nodeId,
                            symbol: sym.symbol,
                            kind: kind,
                            file_path: filePath
                        });

                        // 处理关系
                        if (sym.relationships) {
                            sym.relationships.forEach(rel => {
                                let edgeType = 'CALLS';

                                // MP1.1: IMPLEMENTS 边类型 (AC-U01)
                                if (rel.isImplementation) {
                                    edgeType = 'IMPLEMENTS';
                                }
                                // MP1.2: EXTENDS 边类型 (AC-U02)
                                else if (rel.isTypeDefinition && sym.symbol.includes('#')) {
                                    // 类继承关系
                                    edgeType = 'EXTENDS';
                                }
                                // 原有逻辑
                                else if (rel.isDefinition) {
                                    edgeType = 'DEFINES';
                                }
                                else if (rel.isReference) {
                                    edgeType = 'CALLS';
                                }

                                result.edges.push({
                                    source_id: nodeId,
                                    target_id: rel.symbol,
                                    edge_type: edgeType,
                                    file_path: filePath
                                });

                                if (edgeType === 'DEFINES') result.stats.defines++;
                                else if (edgeType === 'CALLS') result.stats.calls++;
                                else if (edgeType === 'IMPLEMENTS') {
                                    result.stats.implements = (result.stats.implements || 0) + 1;
                                }
                                else if (edgeType === 'EXTENDS') {
                                    result.stats.extends = (result.stats.extends || 0) + 1;
                                }
                            });
                        }
                    });
                }

                // 处理出现位置
                if (doc.occurrences) {
                    doc.occurrences.forEach(occ => {
                        result.stats.occurrences++;

                        const role = occ.symbolRoles || 0;
                        let edgeType = 'CALLS';

                        if (role & 1) { edgeType = 'DEFINES'; result.stats.defines++; }
                        else if (role & 2) { edgeType = 'IMPORTS'; result.stats.imports++; }
                        else if (role & 4) { edgeType = 'MODIFIES'; result.stats.modifies++; }
                        else if (role & 8) { edgeType = 'CALLS'; result.stats.calls++; }
                        else { result.stats.calls++; }

                        // MP1.3: RETURNS_TYPE 边类型 (AC-U09)
                        // 检测函数返回类型：通过符号名称模式识别
                        if (occ.symbol && occ.symbol.includes('()') && doc.text) {
                            const lines = doc.text.split('\n');
                            const occLine = occ.range && occ.range.length > 0 ? occ.range[0] : 0;
                            if (occLine < lines.length) {
                                const lineText = lines[occLine] || '';
                                // 检测显式返回类型声明 (TypeScript/Java 等)
                                if (lineText.match(/:\s*\w+/) || lineText.match(/\)\s*:\s*\w+/)) {
                                    edgeType = 'RETURNS_TYPE';
                                    result.stats.returns_type = (result.stats.returns_type || 0) + 1;
                                }
                            }
                        }

                        // 创建文件节点到符号的边
                        const fileNodeId = 'file:' + filePath;
                        const fileNodeId = 'file:' + filePath;
                        const line = occ.range && occ.range.length > 0 ? occ.range[0] : null;

                        // 确保文件节点存在
                        if (!result.nodes.find(n => n.id === fileNodeId)) {
                            result.nodes.push({
                                id: fileNodeId,
                                symbol: filePath,
                                kind: 'file',
                                file_path: filePath
                            });
                        }

                        result.edges.push({
                            source_id: fileNodeId,
                            target_id: occ.symbol,
                            edge_type: edgeType,
                            file_path: filePath,
                            line: line
                        });
                    });
                }
            });
        }

        fs.writeFileSync(outputPath, JSON.stringify(result, null, 2));
        console.log(JSON.stringify({
            success: true,
            symbols: result.stats.symbols,
            documents: result.stats.documents,
            occurrences: result.stats.occurrences,
            edges: result.edges.length
        }));

    } catch (err) {
        console.error(JSON.stringify({ success: false, error: err.message }));
        process.exit(1);
    }
}

main();
NODEJS_SCRIPT

    # 运行 Node.js 脚本（在项目目录中执行以找到 node_modules）
    local result
    if result=$(cd "$project_root" && node "$node_script" "$scip_path" "$output_file" 2>&1); then
        rm -f "$node_script"
        echo "$result"
        return 0
    else
        rm -f "$node_script"
        echo "$result"
        return 1
    fi
}

# ==================== 正则降级解析 ====================

# 使用 ripgrep 正则解析源代码（降级方案）
# MP1.4: 支持 IMPLEMENTS/EXTENDS/RETURNS_TYPE (AC-U10)
parse_with_regex() {
    local project_root="$1"
    local output_file="$2"

    local nodes=()
    local edges=()
    local symbols=0
    local defines=0
    local imports=0
    local calls=0
    local implements=0
    local extends=0
    local returns_type=0

    # 查找所有 TypeScript/JavaScript 文件
    local files
    files=$(find "$project_root" -type f \( -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" \) \
        -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null)

    for file in $files; do
        local rel_path="${file#$project_root/}"
        local file_node_id="file:$rel_path"

        # 添加文件节点
        nodes+=("{\"id\":\"$file_node_id\",\"symbol\":\"$rel_path\",\"kind\":\"file\",\"file_path\":\"$rel_path\"}")

        # 提取函数定义
        if command -v rg &>/dev/null; then
            while IFS=: read -r line_num match; do
                local func_name
                func_name=$(echo "$match" | sed -E 's/.*function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$func_name" && "$func_name" != "$match" ]]; then
                    local node_id="func:$rel_path:$func_name"
                    nodes+=("{\"id\":\"$node_id\",\"symbol\":\"$func_name\",\"kind\":\"function\",\"file_path\":\"$rel_path\",\"line_start\":$line_num}")
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$node_id\",\"edge_type\":\"DEFINES\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((symbols++))
                    ((defines++))

                    # MP1.4: 检测函数返回类型 (RETURNS_TYPE)
                    if echo "$match" | grep -qE '\):\s*[a-zA-Z_]'; then
                        local return_type
                        return_type=$(echo "$match" | grep -oE '\):\s*[a-zA-Z_][a-zA-Z0-9_<>]*' | sed 's/)://; s/^[[:space:]]*//' | head -1)
                        if [[ -n "$return_type" && "$return_type" != "function" ]]; then
                            local type_id="type:$return_type"
                            edges+=("{\"source_id\":\"$node_id\",\"target_id\":\"$type_id\",\"edge_type\":\"RETURNS_TYPE\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                            ((returns_type++))
                        fi
                    fi
                fi
            done < <(rg -n "function[[:space:]]+[a-zA-Z_]" "$file" 2>/dev/null || true)

            # 提取 import 语句
            while IFS=: read -r line_num match; do
                local import_from
                import_from=$(echo "$match" | sed -E "s/.*from[[:space:]]+['\"]([^'\"]+)['\"].*/\1/" | head -1)
                if [[ -n "$import_from" && "$import_from" != "$match" ]]; then
                    local target_id="module:$import_from"
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$target_id\",\"edge_type\":\"IMPORTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((imports++))
                fi
            done < <(rg -n "import.*from" "$file" 2>/dev/null || true)

            # MP1.4: 提取 IMPLEMENTS 关系
            while IFS=: read -r line_num match; do
                local class_name interface_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                interface_name=$(echo "$match" | sed -E 's/.*implements[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$interface_name" && "$class_name" != "$match" && "$interface_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local interface_id="interface:$interface_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$interface_id\",\"edge_type\":\"IMPLEMENTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((implements++))
                fi
            done < <(rg -n "class[[:space:]]+[a-zA-Z_].*implements" "$file" 2>/dev/null || true)

            # MP1.4: 提取 EXTENDS 关系
            while IFS=: read -r line_num match; do
                local class_name parent_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                parent_name=$(echo "$match" | sed -E 's/.*extends[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$parent_name" && "$class_name" != "$match" && "$parent_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local parent_id="class:$parent_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$parent_id\",\"edge_type\":\"EXTENDS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((extends++))
                fi
            done < <(rg -n "class[[:space:]]+[a-zA-Z_].*extends" "$file" 2>/dev/null || true)
        else
            # 使用 grep 作为后备
            while IFS=: read -r line_num match; do
                local func_name
                func_name=$(echo "$match" | sed -E 's/.*function[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$func_name" && "$func_name" != "$match" ]]; then
                    local node_id="func:$rel_path:$func_name"
                    nodes+=("{\"id\":\"$node_id\",\"symbol\":\"$func_name\",\"kind\":\"function\",\"file_path\":\"$rel_path\",\"line_start\":$line_num}")
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$node_id\",\"edge_type\":\"DEFINES\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((symbols++))
                    ((defines++))

                    # MP1.4: 检测函数返回类型 (RETURNS_TYPE) - grep 后备分支
                    if echo "$match" | grep -qE '\):\s*[a-zA-Z_]'; then
                        local return_type
                        return_type=$(echo "$match" | grep -oE '\):\s*[a-zA-Z_][a-zA-Z0-9_<>]*' | sed 's/)://; s/^[[:space:]]*//' | head -1)
                        if [[ -n "$return_type" && "$return_type" != "function" ]]; then
                            local type_id="type:$return_type"
                            edges+=("{\"source_id\":\"$node_id\",\"target_id\":\"$type_id\",\"edge_type\":\"RETURNS_TYPE\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                            ((returns_type++))
                        fi
                    fi
                fi
            done < <(grep -n "function[[:space:]]*[a-zA-Z_]" "$file" 2>/dev/null || true)

            # 提取 import 语句 - grep 后备分支
            while IFS=: read -r line_num match; do
                local import_from
                import_from=$(echo "$match" | sed -E "s/.*from[[:space:]]+['\"]([^'\"]+)['\"].*/\1/" | head -1)
                if [[ -n "$import_from" && "$import_from" != "$match" ]]; then
                    local target_id="module:$import_from"
                    edges+=("{\"source_id\":\"$file_node_id\",\"target_id\":\"$target_id\",\"edge_type\":\"IMPORTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((imports++))
                fi
            done < <(grep -n "import.*from" "$file" 2>/dev/null || true)

            # MP1.4: 提取 IMPLEMENTS 关系 - grep 后备分支
            while IFS=: read -r line_num match; do
                local class_name interface_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                interface_name=$(echo "$match" | sed -E 's/.*implements[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$interface_name" && "$class_name" != "$match" && "$interface_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local interface_id="interface:$interface_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$interface_id\",\"edge_type\":\"IMPLEMENTS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((implements++))
                fi
            done < <(grep -n "class[[:space:]]*[a-zA-Z_].*implements" "$file" 2>/dev/null || true)

            # MP1.4: 提取 EXTENDS 关系 - grep 后备分支
            while IFS=: read -r line_num match; do
                local class_name parent_name
                class_name=$(echo "$match" | sed -E 's/.*class[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                parent_name=$(echo "$match" | sed -E 's/.*extends[[:space:]]+([a-zA-Z_][a-zA-Z0-9_]*).*/\1/' | head -1)
                if [[ -n "$class_name" && -n "$parent_name" && "$class_name" != "$match" && "$parent_name" != "$match" ]]; then
                    local class_id="class:$rel_path:$class_name"
                    local parent_id="class:$parent_name"
                    edges+=("{\"source_id\":\"$class_id\",\"target_id\":\"$parent_id\",\"edge_type\":\"EXTENDS\",\"file_path\":\"$rel_path\",\"line\":$line_num}")
                    ((extends++))
                fi
            done < <(grep -n "class[[:space:]]*[a-zA-Z_].*extends" "$file" 2>/dev/null || true)
        fi
    done

    # 生成 JSON 输出
    local nodes_json
    local edges_json

    if [[ ${#nodes[@]} -gt 0 ]]; then
        nodes_json=$(printf '%s\n' "${nodes[@]}" | paste -sd ',' -)
    else
        nodes_json=""
    fi

    if [[ ${#edges[@]} -gt 0 ]]; then
        edges_json=$(printf '%s\n' "${edges[@]}" | paste -sd ',' -)
    else
        edges_json=""
    fi

    cat > "$output_file" << EOF
{
  "nodes": [${nodes_json}],
  "edges": [${edges_json}],
  "stats": {
    "symbols": $symbols,
    "defines": $defines,
    "imports": $imports,
    "calls": $calls,
    "implements": $implements,
    "extends": $extends,
    "returns_type": $returns_type
  }
}
EOF

    echo "{\"success\":true,\"symbols\":$symbols,\"confidence\":\"low\",\"source\":\"regex\"}"
}

# ==================== 命令: parse ====================

cmd_parse() {
    local incremental=false
    local force=false
    local format="text"
    local project_root="${PROJECT_ROOT:-$(pwd)}"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --incremental) incremental=true; shift ;;
            --force) force=true; shift ;;
            --format) format="$2"; shift 2 ;;
            --project-root) project_root="$2"; shift 2 ;;
            *) shift ;;
